ca65 V2.19 - Git c8aa9cc70
Main file   : neo6502_mon.asm
Current file: neo6502_mon.asm

000000r 1               ; > monmin.asm
000000r 1               ; minimal monitor for EhBASIC 2.22 running under the 2m5.de 6502 emulator
000000r 1               ; 25-mar-2014 - save/load to match V0.83 or higher DMA register
000000r 1               
000000r 1               ; some minor modifications are in the basic program itself
000000r 1               
000000r 1               ; RAM scan has been removed.
000000r 1               ; maximum RAM can be defined here, you can still configure less RAM during at coldstart
000000r 1               
000000r 1               ; 32k RAM mirrored = 12k EhBASIC code at top + 20k work space at bottom
000000r 1               
000000r 1               	.org	$A000
00A000  1               
00A000  1  4C CB C9     	JMP	RES_vec		;startup soft reset
00A003  1               
00A003  1               	.INCLUDE "basic.asm"
00A003  2               ; Enhanced BASIC to assemble under 6502 simulator, $ver 2.22p5a
00A003  2               ; Build with cc65 with:
00A003  2               ;   cl65 -t none -l --feature labels_without_colons -o ehbasic.bin ehbasic.asm 2> ehbasic.log
00A003  2               
00A003  2               
00A003  2               ; 2.00	new revision numbers start here
00A003  2               ; 2.01	fixed LCASE$() and UCASE$()
00A003  2               ; 2.02	new get value routine done
00A003  2               ; 2.03	changed RND() to galoise method
00A003  2               ; 2.04	fixed SPC()
00A003  2               ; 2.05	new get value routine fixed
00A003  2               ; 2.06	changed USR() code
00A003  2               ; 2.07	fixed STR$()
00A003  2               ; 2.08	changed INPUT and READ to remove need for $00 start to input buffer
00A003  2               ; 2.09	fixed RND()
00A003  2               ; 2.10	integrated missed changes from an earlier version
00A003  2               ; 2.20	added ELSE to IF .. THEN and fixed IF .. GOTO <statement> to cause error
00A003  2               ; 2.21	fixed IF .. THEN RETURN to not cause error
00A003  2               ; 2.22	fixed RND() breaking the get byte routine
00A003  2               ; 2.22a	JGH: added conditional assembly for target, added BBC target, some bugfixes:
00A003  2               ;  String variables can be assigned in direct mode
00A003  2               ;  Text input allows CHR$8/CHR$127 and CHR$10/CHR$13
00A003  2               ;  Svar correctly initialised to after end of program end marker
00A003  2               ;  INPUT allows empty string on input, INPUT "prompt"; doesn't print "?"
00A003  2               ;  FRE(0) returns unsigned integer
00A003  2               ;  A few other bits I've forgotten.
00A003  2               ; 2.22p   patched to disable use of decimal mode and fix Ibuff issues
00A003  2               ;           (bugsnquirks.txt notes 2, 4 and 5)
00A003  2               ;           tabs converted to spaces, tabwidth=6
00A003  2               ; 2.22p2  fixed can't continue error on 1st statement after direct mode
00A003  2               ;           changed INPUT to throw "break in line ##" on empty line input
00A003  2               ; 2.22p3  fixed RAM above code / Ibuff above EhBASIC patch breaks STR$()
00A003  2               ;           fix provided by github user mgcaret
00A003  2               ; 2.22p4  fixed string compare of equal strings in direct mode returns FALSE
00A003  2               ;           fixed FALSE stored to a variable after a string compare
00A003  2               ;             is > 0 and < 1E-16
00A003  2               ;           added additional stack floor protection for background interrupts
00A003  2               ;           fixed conditional LOOP & NEXT cannot find their data strucure on stack
00A003  2               ; 2.22p4a JGH: merged 2.22a and 2.22p4
00A003  2               ; 2.22p5    fixes issues reported by users Ruud and dclxvi on the 6502.org forum
00A003  2               ;      5.0     http://forum.6502.org/viewtopic.php?f=5&t=5500
00A003  2               ;              sanity check for RAM top allows values below RAM base
00A003  2               ;      5.1-7   http://forum.6502.org/viewtopic.php?f=5&t=5606
00A003  2               ;              1-7 coresponds to the bug# in the thread
00A003  2               ;      5.1     TO expression with a subtract may evaluate with the sign bit flipped
00A003  2               ;      5.3     call to LAB_1B5B may return to an address -$100 (page not incremented)
00A003  2               ;      5.4     string concatenate followed by MINUS or NOT() crashes EhBASIC
00A003  2               ;      5.5     garbage collection may cause an overlap with temporary strings
00A003  2               ;      5.6     floating point multiply rounding bug
00A003  2               ;      5.7     VAL() may cause string variables to be trashed
00A003  2               ; 2.22p5a JGH: merged 2.22p4a and 2.22p5
00A003  2               ;              USR() defaults to calling (address), CALL/USR passes/returns registers
00A003  2               ;		  MJM: NEO6502 additions
00A003  2               
00A003  2               RAW	=$000
00A003  2               BBC	=$BBC
00A003  2               C64	=$C64
00A003  2               
00A003  2               ; MJM: neo6502
00A003  2               .define TARGET	RAW
00A003  2               
00A003  2               .ifndef TARGET
00A003  2               .define TARGET	RAW
00A003  2               .endif
00A003  2               
00A003  2               .if TARGET=RAW
00A003  2               .define VERSION	"2.22p5a"
00A003  2               BREAK    =$03		; Code of keypress to interrupt program
00A003  2               MEMBOT   =$0300		; Bottom of user memory
00A003  2               MEMTOP   =$A000		; Top of user memory --NEO6502
00A003  2               ZPSTART  =$00		; Start of zero page workspace
00A003  2               ZPWARM   =$00		; WARM start at &0000
00A003  2               ZPEND    =$FF		; End of zero page workspace
00A003  2               ZPROUT   =1			; Subroutines in zero page
00A003  2               WSSTART  =$0200		; Start of vector and input buffer workspace
00A003  2               ;CODESTART=$2000		; Start of program code --NEO6502
00A003  2               IRQVEC   =$0
00A003  2               .endif
00A003  2               
00A003  2               
00A003  2               ; zero page use
00A003  2               ; -------------
00A003  2               LAB_WARM 	= ZPSTART+ZPWARM; $00=BASIC warm start entry point
00A003  2               Wrmjpl 		= LAB_WARM+1	; BASIC warm start vector jump low byte
00A003  2               Wrmjph 		= LAB_WARM+2	; BASIC warm start vector jump high byte
00A003  2               
00A003  2               Usrjmp		= ZPSTART+$0A	; USR function JMP address
00A003  2               UsrrgA		= Usrjmp-3	; USR A register
00A003  2               UsrrgX		= Usrjmp-2	; USR X register
00A003  2               UsrrgY		= Usrjmp-1	; USR Y register
00A003  2               Usrjpl		= Usrjmp+1	; USR function JMP vector low byte
00A003  2               Usrjph		= Usrjmp+2	; USR function JMP vector high byte
00A003  2               Nullct		= Usrjph+1	; nulls output after each line
00A003  2               TPos		= Nullct+1	; BASIC terminal position byte
00A003  2               TWidth		= TPos+1	; BASIC terminal width byte
00A003  2               Iclim		= TWidth+1	; input column limit
00A003  2               Itempl		= Iclim+1	; temporary integer low byte
00A003  2               Itemph		= Itempl+1	; temporary integer high byte
00A003  2               
00A003  2               nums_1		= Itempl	; number to bin/hex string convert MSB
00A003  2               nums_2		= nums_1+1	; number to bin/hex string convert
00A003  2               nums_3		= nums_1+2	; number to bin/hex string convert LSB
00A003  2               
00A003  2               .if ZPROUT
00A003  2               Srchc		= $5B
00A003  2               .else
00A003  2               Srchc		= nums_3+1	; search character
00A003  2               .endif
00A003  2               Temp3		= Srchc		; temp byte used in number routines
00A003  2               Scnquo		= Srchc+1	; scan-between-quotes flag
00A003  2               Asrch		= Scnquo	; alt search character
00A003  2               
00A003  2               XOAw_l		= Srchc		; eXclusive OR, OR and AND word low byte
00A003  2               XOAw_h		= Scnquo	; eXclusive OR, OR and AND word high byte
00A003  2               
00A003  2               Ibptr		= Scnquo+1	; input buffer pointer
00A003  2               Dimcnt		= Ibptr		; # of dimensions
00A003  2               Tindx		= Ibptr		; token index
00A003  2               
00A003  2               Defdim		= Ibptr+1	; default DIM flag
00A003  2               Dtypef		= Defdim+1	; data type flag, $FF=string, $00=numeric
00A003  2               Oquote		= Dtypef+1	; open quote flag (b7) (Flag: DATA scan; LIST quote; memory)
00A003  2               Gclctd		= Oquote	; garbage collected flag
00A003  2               Sufnxf		= Gclctd+1	; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
00A003  2               Imode		= Sufnxf+1	; input mode flag, $00=INPUT, $80=READ
00A003  2               
00A003  2               Cflag		= Imode+1	; comparison evaluation flag
00A003  2               
00A003  2               TabSiz		= Cflag+1	; TAB step size (was input flag)
00A003  2               
00A003  2               next_s		= TabSiz+1	; next descriptor stack address
00A003  2               
00A003  2               				; these two bytes form a word pointer to the item
00A003  2               				; currently on top of the descriptor stack
00A003  2               last_sl		= next_s+1	; last descriptor stack address low byte
00A003  2               last_sh		= last_sl+1	; last descriptor stack address high byte (always $00)
00A003  2               
00A003  2               des_sk		= last_sh+1	; descriptor stack start address (temp strings)
00A003  2               
00A003  2               ut1_pl		= des_sk+9	; utility pointer 1 low byte
00A003  2               ut1_ph		= ut1_pl+1	; utility pointer 1 high byte
00A003  2               ut2_pl		= ut1_ph+1	; utility pointer 2 low byte
00A003  2               ut2_ph		= ut2_pl+1	; utility pointer 2 high byte
00A003  2               
00A003  2               Temp_2		= ut1_pl	; temp byte for block move
00A003  2               
00A003  2               FACt_1		= ut2_ph+1	; FAC temp mantissa1
00A003  2               FACt_2		= FACt_1+1	; FAC temp mantissa2
00A003  2               FACt_3		= FACt_2+1	; FAC temp mantissa3
00A003  2               
00A003  2               dims_l		= FACt_2	; array dimension size low byte
00A003  2               dims_h		= FACt_3	; array dimension size high byte
00A003  2               
00A003  2               TempB		= FACt_1+3	; temp page 0 byte
00A003  2               
00A003  2               Smeml		= TempB+1	; start of mem low byte		(Start-of-Basic)
00A003  2               Smemh		= Smeml+1	; start of mem high byte	(Start-of-Basic)
00A003  2               Svarl		= Smemh+1	; start of vars low byte	(Start-of-Variables)
00A003  2               Svarh		= Svarl+1	; start of vars high byte	(Start-of-Variables)
00A003  2               Sarryl		= Svarh+1	; var mem end low byte		(Start-of-Arrays)
00A003  2               Sarryh		= Sarryl+1	; var mem end high byte		(Start-of-Arrays)
00A003  2               Earryl		= Sarryh+1	; array mem end low byte	(End-of-Arrays)
00A003  2               Earryh		= Earryl+1	; array mem end high byte	(End-of-Arrays)
00A003  2               Sstorl		= Earryh+1	; string storage low byte	(String storage (moving down))
00A003  2               Sstorh		= Sstorl+1	; string storage high byte	(String storage (moving down))
00A003  2               Sutill		= Sstorh+1	; string utility ptr low byte
00A003  2               Sutilh		= Sutill+1	; string utility ptr high byte
00A003  2               Ememl		= Sutilh+1	; end of mem low byte		(Limit-of-memory)
00A003  2               Ememh		= Ememl+1	; end of mem high byte		(Limit-of-memory)
00A003  2               Clinel		= Ememh+1	; current line low byte		(Basic line number)
00A003  2               Clineh		= Clinel+1	; current line high byte	(Basic line number)
00A003  2               Blinel		= Clineh+1	; break line low byte		(Previous Basic line number)
00A003  2               Blineh		= Blinel+1	; break line high byte		(Previous Basic line number)
00A003  2               
00A003  2               Cpntrl		= Blineh+1	; continue pointer low byte
00A003  2               Cpntrh		= Cpntrl+1	; continue pointer high byte
00A003  2               
00A003  2               Dlinel		= Cpntrh+1	; current DATA line low byte
00A003  2               Dlineh		= Dlinel+1	; current DATA line high byte
00A003  2               
00A003  2               Dptrl		= Dlineh+1	; DATA pointer low byte
00A003  2               Dptrh		= Dptrl+1	; DATA pointer high byte
00A003  2               
00A003  2               Rdptrl		= Dptrh+1	; read pointer low byte
00A003  2               Rdptrh		= Rdptrl+1	; read pointer high byte
00A003  2               
00A003  2               Varnm1		= Rdptrh+1	; current var name 1st byte
00A003  2               Varnm2		= Varnm1+1	; current var name 2nd byte
00A003  2               
00A003  2               Cvaral		= Varnm2+1	; current var address low byte
00A003  2               Cvarah		= Cvaral+1	; current var address high byte
00A003  2               
00A003  2               Frnxtl		= Cvarah+1	; var pointer for FOR/NEXT low byte
00A003  2               Frnxth		= Frnxtl+1	; var pointer for FOR/NEXT high byte
00A003  2               
00A003  2               Tidx1		= Frnxtl	; temp line index
00A003  2               
00A003  2               Lvarpl		= Frnxtl	; let var pointer low byte
00A003  2               Lvarph		= Frnxth	; let var pointer high byte
00A003  2               
00A003  2               prstk		= Frnxtl+2	; precedence stacked flag
00A003  2               
00A003  2               comp_f		= prstk+2	; compare function flag, bits 0,1 and 2 used
00A003  2               				; bit 2 set if >
00A003  2               				; bit 1 set if =
00A003  2               				; bit 0 set if <
00A003  2               
00A003  2               func_l		= comp_f+1	; function pointer low byte
00A003  2               func_h		= func_l+1	; function pointer high byte
00A003  2               
00A003  2               garb_l		= func_l	; garbage collection working pointer low byte
00A003  2               garb_h		= func_h	; garbage collection working pointer high byte
00A003  2               
00A003  2               des_2l		= func_h+1	; string descriptor_2 pointer low byte
00A003  2               des_2h		= des_2l+1	; string descriptor_2 pointer high byte
00A003  2               
00A003  2               g_step		= des_2l+2	; garbage collect step size
00A003  2               
00A003  2               Fnxjmp		= g_step+1	; jump vector for functions
00A003  2               Fnxjpl		= Fnxjmp+1	; functions jump vector low byte
00A003  2               Fnxjph		= Fnxjmp+2	; functions jump vector high byte
00A003  2               
00A003  2               g_indx		= Fnxjpl	; garbage collect temp index
00A003  2               
00A003  2               FAC2_r		= Fnxjmp+2	; FAC2 rounding byte
00A003  2               
00A003  2               Adatal		= FAC2_r+1	; array data pointer low byte
00A003  2               Adatah		= Adatal+1	; array data pointer high  byte
00A003  2               
00A003  2               Nbendl		= Adatal	; new block end pointer low byte
00A003  2               Nbendh		= Adatah	; new block end pointer high  byte
00A003  2               
00A003  2               Obendl		= Adatah+1	; old block end pointer low byte
00A003  2               Obendh		= Obendl+1	; old block end pointer high  byte
00A003  2               
00A003  2               numexp		= Obendh+1	; string to float number exponent count
00A003  2               expcnt		= numexp+1	; string to float exponent count
00A003  2               
00A003  2               numbit		= numexp	; bit count for array element calculations
00A003  2               
00A003  2               numdpf		= expcnt+1	; string to float decimal point flag
00A003  2               expneg		= numdpf+1	; string to float eval exponent -ve flag
00A003  2               
00A003  2               Astrtl		= numdpf	; array start pointer low byte
00A003  2               Astrth		= expneg	; array start pointer high  byte
00A003  2               
00A003  2               Histrl		= numdpf	; highest string low byte
00A003  2               Histrh		= expneg	; highest string high  byte
00A003  2               
00A003  2               Baslnl		= numdpf	; BASIC search line pointer low byte
00A003  2               Baslnh		= expneg	; BASIC search line pointer high  byte
00A003  2               
00A003  2               Fvar_l		= numdpf	; find/found variable pointer low byte
00A003  2               Fvar_h		= expneg	; find/found variable pointer high  byte
00A003  2               
00A003  2               Ostrtl		= numdpf	; old block start pointer low byte
00A003  2               Ostrth		= expneg	; old block start pointer high  byte
00A003  2               
00A003  2               Vrschl		= numdpf	; variable search pointer low byte
00A003  2               Vrschh		= expneg	; variable search pointer high  byte
00A003  2               
00A003  2               FAC1_e		= expneg+1	; FAC1 exponent
00A003  2               FAC1_1		= FAC1_e+1	; FAC1 mantissa1
00A003  2               FAC1_2		= FAC1_e+2	; FAC1 mantissa2
00A003  2               FAC1_3		= FAC1_e+3	; FAC1 mantissa3
00A003  2               FAC1_s		= FAC1_e+4	; FAC1 sign (b7)
00A003  2               
00A003  2               str_ln		= FAC1_e	; string length
00A003  2               str_pl		= FAC1_1	; string pointer low byte
00A003  2               str_ph		= FAC1_2	; string pointer high byte
00A003  2               
00A003  2               des_pl		= FAC1_2	; string descriptor pointer low byte
00A003  2               des_ph		= FAC1_3	; string descriptor pointer high byte
00A003  2               
00A003  2               mids_l		= FAC1_3	; MID$ string temp length byte
00A003  2               
00A003  2               negnum		= FAC1_e+5	; string to float eval -ve flag
00A003  2               numcon		= negnum	; series evaluation constant count
00A003  2               
00A003  2               FAC1_o		= negnum+1	; FAC1 overflow byte
00A003  2               
00A003  2               FAC2_e		= FAC1_o+1	; FAC2 exponent
00A003  2               FAC2_1		= FAC2_e+1	; FAC2 mantissa1
00A003  2               FAC2_2		= FAC2_e+2	; FAC2 mantissa2
00A003  2               FAC2_3		= FAC2_e+3	; FAC2 mantissa3
00A003  2               FAC2_s		= FAC2_e+4	; FAC2 sign (b7)
00A003  2               
00A003  2               FAC_sc		= FAC2_e+5	; FAC sign comparison, Acc#1 vs #2
00A003  2               FAC1_r		= FAC_sc+1	; FAC1 rounding byte
00A003  2               
00A003  2               ssptr_l		= FAC_sc	; string start pointer low byte
00A003  2               ssptr_h		= FAC1_r	; string start pointer high byte
00A003  2               
00A003  2               sdescr		= FAC_sc	; string descriptor pointer
00A003  2               
00A003  2               csidx		= FAC1_r+1	; line crunch save index
00A003  2               Asptl		= csidx		; array size/pointer low byte
00A003  2               Aspth		= csidx+1	; array size/pointer high byte
00A003  2               
00A003  2               Btmpl		= Asptl		; BASIC pointer temp low byte
00A003  2               Btmph		= Aspth		; BASIC pointer temp low byte
00A003  2               
00A003  2               Cptrl		= Asptl		; BASIC pointer temp low byte
00A003  2               Cptrh		= Aspth		; BASIC pointer temp low byte
00A003  2               
00A003  2               Sendl		= Asptl		; BASIC pointer temp low byte
00A003  2               Sendh		= Aspth		; BASIC pointer temp low byte
00A003  2               
00A003  2               .if ZPROUT
00A003  2               LAB_IGBY	= $BC		; get next BASIC byte subroutine
00A003  2               LAB_GBYT	= LAB_IGBY+6	; get current BASIC byte subroutine
00A003  2               Bpntrl		= LAB_GBYT+1	; BASIC execute (get byte) pointer low byte
00A003  2               Bpntrh		= Bpntrl+1	; BASIC execute (get byte) pointer high byte
00A003  2               
00A003  2               Rbyte4		= LAB_GBYT+22	; extra PRNG byte
00A003  2               .else
00A003  2               Bpntrl		= Sendh+1	; BASIC execute (get byte) pointer low byte
00A003  2               Bpntrh		= Bpntrl+1	; BASIC execute (get byte) pointer high byte
00A003  2               
00A003  2               Rbyte4		= Sendh+1	; extra PRNG byte
00A003  2               .endif
00A003  2               Rbyte1		= Rbyte4+1	; most significant PRNG byte
00A003  2               Rbyte2		= Rbyte4+2	; middle PRNG byte
00A003  2               Rbyte3		= Rbyte4+3	; least significant PRNG byte
00A003  2               
00A003  2               .ifdef IRQVEC
00A003  2               NmiBase		= Rbyte4+4	; NMI handler enabled/setup/triggered flags
00A003  2               				; bit	function
00A003  2               				; ===	========
00A003  2               				; 7	interrupt enabled
00A003  2               				; 6	interrupt setup
00A003  2               				; 5	interrupt happened
00A003  2               ;		= $DD		; NMI handler addr low byte
00A003  2               ;		= $DE		; NMI handler addr high byte
00A003  2               IrqBase		= $DF		; IRQ handler enabled/setup/triggered flags
00A003  2               ;		= $E0		; IRQ handler addr low byte
00A003  2               ;		= $E1		; IRQ handler addr high byte
00A003  2               irq_a_reg	= $E2		; save A during IRQ
00A003  2               Decss		= NmiBase+18	; number to decimal string start
00A003  2               .else
00A003  2               Decss		= Rbyte4+4	; number to decimal string start
00A003  2               .endif
00A003  2               Decssp1		= Decss+1	; number to decimal string start
00A003  2               ZPLastByte	= Decss+17
00A003  2               
00A003  2               .if ZPLastByte>ZPEND
00A003  2               .error	"Too much zero page used"
00A003  2               .endif
00A003  2               
00A003  2               
00A003  2               ; token values needed for BASIC
00A003  2               
00A003  2               ; primary command tokens (can start a statement)
00A003  2               
00A003  2               TK_END		= $80		; END token
00A003  2               TK_FOR		= TK_END+1	; FOR token
00A003  2               TK_NEXT		= TK_FOR+1	; NEXT token
00A003  2               TK_DATA		= TK_NEXT+1	; DATA token
00A003  2               TK_INPUT	= TK_DATA+1	; INPUT token
00A003  2               TK_DIM		= TK_INPUT+1	; DIM token
00A003  2               TK_READ		= TK_DIM+1	; READ token
00A003  2               TK_LET		= TK_READ+1	; LET token
00A003  2               TK_DEC		= TK_LET+1	; DEC token
00A003  2               TK_GOTO		= TK_DEC+1	; GOTO token
00A003  2               TK_RUN		= TK_GOTO+1	; RUN token
00A003  2               TK_IF		= TK_RUN+1	; IF token
00A003  2               TK_RESTORE	= TK_IF+1	; RESTORE token
00A003  2               TK_GOSUB	= TK_RESTORE+1	; GOSUB token
00A003  2               TK_RETIRQ	= TK_GOSUB+1	; RETIRQ token
00A003  2               TK_RETNMI	= TK_RETIRQ+1	; RETNMI token
00A003  2               TK_RETURN	= TK_RETNMI+1	; RETURN token
00A003  2               TK_REM		= TK_RETURN+1	; REM token
00A003  2               TK_STOP		= TK_REM+1	; STOP token
00A003  2               TK_ON		= TK_STOP+1	; ON token
00A003  2               TK_NULL		= TK_ON+1	; NULL token
00A003  2               TK_INC		= TK_NULL+1	; INC token
00A003  2               TK_WAIT		= TK_INC+1	; WAIT token
00A003  2               TK_LOAD		= TK_WAIT+1	; LOAD token
00A003  2               TK_SAVE		= TK_LOAD+1	; SAVE token
00A003  2               TK_DEF		= TK_SAVE+1	; DEF token
00A003  2               TK_POKE		= TK_DEF+1	; POKE token
00A003  2               TK_DOKE		= TK_POKE+1	; DOKE token
00A003  2               TK_CALL		= TK_DOKE+1	; CALL token
00A003  2               TK_DO		= TK_CALL+1	; DO token
00A003  2               TK_LOOP		= TK_DO+1	; LOOP token
00A003  2               TK_PRINT	= TK_LOOP+1	; PRINT token
00A003  2               TK_CONT		= TK_PRINT+1	; CONT token
00A003  2               TK_LIST		= TK_CONT+1	; LIST token
00A003  2               TK_CLEAR	= TK_LIST+1	; CLEAR token
00A003  2               TK_NEW		= TK_CLEAR+1	; NEW token
00A003  2               TK_WIDTH	= TK_NEW+1	; WIDTH token
00A003  2               TK_GET		= TK_WIDTH+1	; GET token
00A003  2               TK_SWAP		= TK_GET+1	; SWAP token
00A003  2               TK_BITSET	= TK_SWAP+1	; BITSET token
00A003  2               TK_BITCLR	= TK_BITSET+1	; BITCLR token
00A003  2               TK_IRQ		= TK_BITCLR+1	; IRQ token
00A003  2               TK_NMI		= TK_IRQ+1	; NMI token
00A003  2               TK_CLS		= TK_NMI+1	; CLS token
00A003  2               TK_MOVE		= TK_CLS+1	; MOVE token
00A003  2               TK_DRAW		= TK_MOVE+1	; DRAW token
00A003  2               TK_PIXEL	= TK_DRAW+1	; PIXEL token
00A003  2               TK_COLOR	= TK_PIXEL+1	; COLOR token
00A003  2               TK_PALETTE	= TK_COLOR+1	; PALETTE token
00A003  2               TK_VDU      = TK_PALETTE+1	; VDU token
00A003  2               TK_REFRESH  = TK_VDU+1 ; VDU refresh token
00A003  2               TK_RECT     = TK_REFRESH+1
00A003  2               TK_CIRCLE   = TK_RECT+1
00A003  2               TK_TRIANGLE = TK_CIRCLE+1
00A003  2               TK_PLAY     = TK_TRIANGLE+1
00A003  2               TK_SILENCE  = TK_PLAY+1
00A003  2               TK_SANE     = TK_SILENCE+1
00A003  2               TK_SPRITE   = TK_SANE+1
00A003  2               TK_SDRAW    = TK_SPRITE+1
00A003  2               TK_SCLEAR   = TK_SDRAW+1
00A003  2               TK_SMOVE    = TK_SCLEAR+1
00A003  2               TK_SDIM     = TK_SMOVE+1
00A003  2               TK_WDIM     = TK_SDIM+1
00A003  2               TK_CSPRITE  = TK_WDIM+1
00A003  2               TK_TILE     = TK_CSPRITE+1
00A003  2               TK_TDIM     = TK_TILE+1
00A003  2               
00A003  2               ; secondary command tokens, can't start a statement
00A003  2               
00A003  2               TK_TAB		= TK_TDIM+1 ; TAB token
00A003  2               TK_ELSE		= TK_TAB+1	; ELSE token
00A003  2               TK_TO		= TK_ELSE+1	; TO token
00A003  2               TK_FN		= TK_TO+1	; FN token
00A003  2               TK_SPC		= TK_FN+1	; SPC token
00A003  2               TK_THEN		= TK_SPC+1	; THEN token
00A003  2               TK_NOT		= TK_THEN+1	; NOT token
00A003  2               TK_STEP		= TK_NOT+1	; STEP token
00A003  2               TK_UNTIL	= TK_STEP+1	; UNTIL token
00A003  2               TK_WHILE	= TK_UNTIL+1	; WHILE token
00A003  2               TK_OFF		= TK_WHILE+1	; OFF token
00A003  2               
00A003  2               ; operator tokens
00A003  2               
00A003  2               TK_PLUS		= TK_OFF+1	; + token
00A003  2               TK_MINUS	= TK_PLUS+1	; - token
00A003  2               TK_MUL		= TK_MINUS+1	; * token
00A003  2               TK_DIV		= TK_MUL+1	; / token
00A003  2               TK_POWER	= TK_DIV+1	; ^ token
00A003  2               TK_AND		= TK_POWER+1	; AND token
00A003  2               TK_EOR		= TK_AND+1	; EOR token
00A003  2               TK_OR		= TK_EOR+1	; OR token
00A003  2               TK_RSHIFT	= TK_OR+1	; RSHIFT token
00A003  2               TK_LSHIFT	= TK_RSHIFT+1	; LSHIFT token
00A003  2               TK_GT		= TK_LSHIFT+1	; > token
00A003  2               TK_EQUAL	= TK_GT+1	; = token
00A003  2               TK_LT		= TK_EQUAL+1	; < token
00A003  2               
00A003  2               ; functions tokens
00A003  2               
00A003  2               TK_SGN		= TK_LT+1	; SGN token
00A003  2               TK_INT		= TK_SGN+1	; INT token
00A003  2               TK_ABS		= TK_INT+1	; ABS token
00A003  2               TK_USR		= TK_ABS+1	; USR token
00A003  2               TK_FRE		= TK_USR+1	; FRE token
00A003  2               TK_POS		= TK_FRE+1	; POS token
00A003  2               TK_SQR		= TK_POS+1	; SQR token
00A003  2               TK_RND		= TK_SQR+1	; RND token
00A003  2               TK_LOG		= TK_RND+1	; LOG token
00A003  2               TK_EXP		= TK_LOG+1	; EXP token
00A003  2               TK_COS		= TK_EXP+1	; COS token
00A003  2               TK_SIN		= TK_COS+1	; SIN token
00A003  2               TK_TAN		= TK_SIN+1	; TAN token
00A003  2               TK_ATN		= TK_TAN+1	; ATN token
00A003  2               TK_PEEK		= TK_ATN+1	; PEEK token
00A003  2               TK_DEEK		= TK_PEEK+1	; DEEK token
00A003  2               TK_SADD		= TK_DEEK+1	; SADD token
00A003  2               TK_LEN		= TK_SADD+1	; LEN token
00A003  2               TK_STRS		= TK_LEN+1	; STR$ token
00A003  2               TK_VAL		= TK_STRS+1	; VAL token
00A003  2               TK_ASC		= TK_VAL+1	; ASC token
00A003  2               TK_UCASES	= TK_ASC+1	; UCASE$ token
00A003  2               TK_LCASES	= TK_UCASES+1	; LCASE$ token
00A003  2               TK_CHRS		= TK_LCASES+1	; CHR$ token
00A003  2               TK_HEXS		= TK_CHRS+1	; HEX$ token
00A003  2               TK_BINS		= TK_HEXS+1	; BIN$ token
00A003  2               TK_BITTST	= TK_BINS+1	; BITTST token
00A003  2               TK_MAX		= TK_BITTST+1	; MAX token
00A003  2               TK_MIN		= TK_MAX+1	; MIN token
00A003  2               TK_PI		= TK_MIN+1	; PI token
00A003  2               TK_TWOPI	= TK_PI+1	; TWOPI token
00A003  2               TK_VPTR		= TK_TWOPI+1	; VARPTR token
00A003  2               TK_LEFTS	= TK_VPTR+1	; LEFT$ token
00A003  2               TK_RIGHTS	= TK_LEFTS+1	; RIGHT$ token
00A003  2               TK_MIDS		= TK_RIGHTS+1	; MID$ token
00A003  2               TK_COLLISION= TK_MIDS+1    ; COLLISION token
00A003  2               
00A003  2               ; offsets from a base of X or Y
00A003  2               
00A003  2               PLUS_0		= $00		; X or Y plus 0
00A003  2               PLUS_1		= $01		; X or Y plus 1
00A003  2               PLUS_2		= $02		; X or Y plus 2
00A003  2               PLUS_3		= $03		; X or Y plus 3
00A003  2               
00A003  2               LAB_STAK	= $0100		; stack bottom, no offset
00A003  2               
00A003  2               LAB_SKFE	= LAB_STAK+$FE	; flushed stack address
00A003  2               LAB_SKFF	= LAB_STAK+$FF	; flushed stack address
00A003  2               
00A003  2               ccflag		= WSSTART	; BASIC CTRL-C flag, 00 = enabled, 01 = disabled
00A003  2               ccbyte		= ccflag+1	; BASIC CTRL-C byte
00A003  2               ccnull		= ccbyte+1	; BASIC CTRL-C byte timeout
00A003  2               
00A003  2               VEC_CC		= ccnull+2	; CTRL-C check vector
00A003  2               VEC_IN		= VEC_CC+2	; input vector
00A003  2               VEC_OUT		= VEC_IN+2	; output vector
00A003  2               VEC_LD		= VEC_OUT+2	; load vector
00A003  2               VEC_SV		= VEC_LD+2	; save vector
00A003  2               
00A003  2               ; Ibuffs can now be anywhere in RAM, ensure that the max length is < $80,
00A003  2               ; the input buffer must not cross a page boundary and must not overlap with
00A003  2               ; program RAM pages.
00A003  2               
00A003  2               .ifdef IRQVEC
00A003  2               Ibuffs		= IRQVEC+$14	; start of input buffer after IRQ/NMI code
00A003  2               Ibuffe		= Ibuffs+$47	; end of input buffer
00A003  2               .else
00A003  2               Ibuffs		= VEC_SV+4	; aligned to $xx10
00A003  2               Ibuffe		= Ibuffs+$7B	; end of input buffer
00A003  2               .endif
00A003  2               
00A003  2               Ram_base	= MEMBOT	; start of user RAM
00A003  2               Ram_top		= MEMTOP	; end of user RAM+1
00A003  2               Stack_floor	= 16		; bytes left free on stack for background interrupts
00A003  2               
00A003  2               
00A003  2               ; BASIC cold start entry point
00A003  2               LAB_COLD
00A003  2               ; workspace initialisation, copy block to ccflag onwards
00A003  2  A2 05        	LDX	#PG2_TABE-PG2_TABS-1	; byte count-1
00A005  2               LAB_2D13
00A005  2  BD 5E C1     	LDA	PG2_TABS,X	; get byte
00A008  2  9D 00 02     	STA	ccflag,X	; store in workspace page
00A00B  2  CA           	DEX			; decrement count
00A00C  2  10 F7        	BPL	LAB_2D13	; loop if not done
00A00E  2  9A           	TXS			; reset stack pointer
00A00F  2  86 88        	STX	Clineh		; set current line high byte (set immediate mode)
00A011  2               
00A011  2  20 4B CA     	JSR	MON_INIT	; target-specific initialisation
00A014  2               
00A014  2  A9 4C        	LDA	#$4C		; code for JMP
00A016  2  85 A1        	STA	Fnxjmp		; save for jump vector for functions
00A018  2               
00A018  2               ; copy block from LAB_2CEE to $00BC - $00D3
00A018  2               .if ZPROUT
00A018  2  A2 1C        	LDX	#StrTab-LAB_2CEE; set byte count
00A01A  2               LAB_2D4E
00A01A  2  BD 63 C1     	LDA	LAB_2CEE-1,X	; get byte from table
00A01D  2  95 BB        	STA	LAB_IGBY-1,X	; save byte in page zero
00A01F  2  CA           	DEX			; decrement count
00A020  2  D0 F8        	BNE	LAB_2D4E	; loop if not all done
00A022  2               .endif
00A022  2               
00A022  2               ; copy block from StrTab to $0000 - $0012
00A022  2               LAB_GMEM
00A022  2  A2 12        	LDX	#EndTab-StrTab-1; set byte count-1
00A024  2               TabLoop
00A024  2  BD 80 C1     	LDA	StrTab,X	; get byte from table
00A027  2  95 00        	STA	LAB_WARM,X	; save byte in page zero
00A029  2  CA           	DEX			; decrement count
00A02A  2  10 F8        	BPL	TabLoop		; loop if not all done
00A02C  2               
00A02C  2               ; set up start values
00A02C  2  A9 00        	LDA	#$00		; clear A
00A02E  2               .ifdef IRQVEC
00A02E  2  85 DC        	STA	NmiBase		; clear NMI handler enabled flag
00A030  2  85 DF        	STA	IrqBase		; clear IRQ handler enabled flag
00A032  2               .endif
00A032  2  85 B2        	STA	FAC1_o		; clear FAC1 overflow byte
00A034  2  85 67        	STA	last_sh		; clear descriptor stack top item pointer high byte
00A036  2               
00A036  2  A9 0E        	LDA	#$0E		; set default tab size
00A038  2  85 64        	STA	TabSiz		; save it
00A03A  2  A9 03        	LDA	#$03		; set garbage collect step size for descriptor stack
00A03C  2  85 A0        	STA	g_step		; save it
00A03E  2  A2 68        	LDX	#des_sk		; descriptor stack start
00A040  2  86 65        	STX	next_s		; set descriptor stack pointer
00A042  2               .if MEMTOP<>0
00A042  2               ; probe memory for memory size
00A042  2  20 E1 A8     	JSR	LAB_CRLF	; print CR/LF
00A045  2  A9 93        	LDA	#<LAB_MSZM	; point to memory size message (low addr)
00A047  2  A0 C1        	LDY	#>LAB_MSZM	; point to memory size message (high addr)
00A049  2  20 22 A9     	JSR	LAB_18C3	; print null terminated string from memory
00A04C  2  20 5B A2     	JSR	LAB_INLN	; print "? " and get BASIC input
00A04F  2  86 C3        	STX	Bpntrl		; set BASIC execute pointer low byte
00A051  2  84 C4        	STY	Bpntrh		; set BASIC execute pointer high byte
00A053  2  20 C2 00     	JSR	LAB_GBYT	; get last byte back
00A056  2               
00A056  2  D0 1F        	BNE	LAB_2DAA	; branch if not null (user typed something)
00A058  2               
00A058  2  A0 00        	LDY	#$00		; else clear Y
00A05A  2               				; character was null so get memory size the hard way
00A05A  2               				; we get here with Y=0 and Itempl/h = Ram_base
00A05A  2               LAB_2D93
00A05A  2  E6 11        	INC	Itempl		; increment temporary integer low byte
00A05C  2  D0 08        	BNE	LAB_2D99	; branch if no overflow
00A05E  2               
00A05E  2  E6 12        	INC	Itemph		; increment temporary integer high byte
00A060  2  A5 12        	LDA	Itemph		; get high byte
00A062  2  C9 A0        	CMP	#>Ram_top	; compare with top of RAM+1
00A064  2  F0 1D        	BEQ	LAB_2DB6	; branch if match (end of user RAM)
00A066  2               
00A066  2               LAB_2D99
00A066  2  A9 55        	LDA	#$55		; set test byte
00A068  2  91 11        	STA	(Itempl),Y	; save via temporary integer
00A06A  2  D1 11        	CMP	(Itempl),Y	; compare via temporary integer
00A06C  2  D0 15        	BNE	LAB_2DB6	; branch if fail
00A06E  2               
00A06E  2  0A           	ASL			; shift test byte left (now $AA)
00A06F  2  91 11        	STA	(Itempl),Y	; save via temporary integer
00A071  2  D1 11        	CMP	(Itempl),Y	; compare via temporary integer
00A073  2  F0 E5        	BEQ	LAB_2D93	; if ok go do next byte
00A075  2               
00A075  2  D0 0C        	BNE	LAB_2DB6	; branch if fail
00A077  2               
00A077  2               LAB_2DAA
00A077  2  20 08 BA     	JSR	LAB_2887	; get FAC1 from string
00A07A  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00A07C  2  C9 98        	CMP	#$98		; compare with exponent = 2^24
00A07E  2  B0 A2        	BCS	LAB_GMEM	; if too large go try again
00A080  2               
00A080  2  20 49 B5     	JSR	LAB_F2FU	; save integer part of FAC1 in temporary integer
00A083  2               				; (no range check)
00A083  2               
00A083  2               LAB_2DB6
00A083  2  A5 11        	LDA	Itempl		; get temporary integer low byte
00A085  2  A4 12        	LDY	Itemph		; get temporary integer high byte
00A087  2  C0 04        	CPY	#>Ram_base+1	; compare with start of RAM+$100 high byte
00A089  2  90 97        	BCC	LAB_GMEM	; if too small go try again
00A08B  2               
00A08B  2               
00A08B  2               ; uncomment these lines if you want to check on the high limit of memory. Note if
00A08B  2               ; Ram_top is set too low then this will fail. default is ignore it and assume the
00A08B  2               ; users know what they're doing!
00A08B  2               
00A08B  2               ;	CPY	#>Ram_top	; compare with top of RAM high byte
00A08B  2               ;	BCC	MEM_OK		; branch if < RAM top
00A08B  2               
00A08B  2               ;	BNE	LAB_GMEM	; if too large go try again
00A08B  2               				; else was = so compare low bytes
00A08B  2               ;	CMP	#<Ram_top	; compare with top of RAM low byte
00A08B  2               ;	BEQ	MEM_OK		; branch if = RAM top
00A08B  2               
00A08B  2               ;	BCS	LAB_GMEM	; if too large go try again
00A08B  2               ;MEM_OK
00A08B  2               
00A08B  2  85 85        	STA	Ememl		; set end of mem low byte
00A08D  2  84 86        	STY	Ememh		; set end of mem high byte
00A08F  2  85 81        	STA	Sstorl		; set bottom of string space low byte
00A091  2  84 82        	STY	Sstorh		; set bottom of string space high byte
00A093  2  A0 00        	LDY	#<Ram_base	; set start addr low byte
00A095  2  A2 03        	LDX	#>Ram_base	; set start addr high byte
00A097  2  84 79        	STY	Smeml		; save start of mem low byte
00A099  2  86 7A        	STX	Smemh		; save start of mem high byte
00A09B  2               .else
00A09B  2               	JSR	MON_LIMITS	; Ask MOS for memory limits
00A09B  2               .endif
00A09B  2               
00A09B  2  A0 00        	LDY	#$00
00A09D  2  98           	TYA			; clear A
00A09E  2  91 79        	STA	(Smeml),Y	; clear first byte
00A0A0  2  E6 79        	INC	Smeml		; increment start of mem low byte
00A0A2  2               
00A0A2  2               ; these two lines are only needed if Ram_base is $xxFF
00A0A2  2               .if (Ram_base & $FF) = $FF
00A0A2  2               	BNE	LAB_2E05	; branch if no rollover
00A0A2  2               	INC	Smemh		; increment start of mem high byte
00A0A2  2               LAB_2E05
00A0A2  2               .endif
00A0A2  2               
00A0A2  2               .if TARGET<>BBC
00A0A2  2  20 E1 A8     	JSR	LAB_CRLF	; print CR/LF
00A0A5  2               .endif
00A0A5  2  A9 A2        	LDA	#<LAB_SMSG	; point to sign-on message (low addr)
00A0A7  2  A0 C1        	LDY	#>LAB_SMSG	; point to sign-on message (high addr)
00A0A9  2  20 22 A9     	JSR	LAB_18C3	; print null terminated string from memory
00A0AC  2  20 9D A3     	JSR	LAB_1463	; do "NEW" and "CLEAR"
00A0AF  2  A5 85        	LDA	Ememl		; get end of mem low byte
00A0B1  2  38           	SEC			; set carry for subtract
00A0B2  2  E5 79        	SBC	Smeml		; subtract start of mem low byte
00A0B4  2  AA           	TAX			; copy to X
00A0B5  2  A5 86        	LDA	Ememh		; get end of mem high byte
00A0B7  2  E5 7A        	SBC	Smemh		; subtract start of mem high byte
00A0B9  2  20 E4 BA     	JSR	LAB_295E	; print XA as unsigned integer (bytes free)
00A0BC  2  A9 BB        	LDA	#<LAB_FREE	; point to sign-on message (low addr)
00A0BE  2  A0 C1        	LDY	#>LAB_FREE	; point to sign-on message (high addr)
00A0C0  2  20 22 A9     	JSR	LAB_18C3	; print null terminated string from memory
00A0C3  2  A9 6A        	LDA	#<LAB_1274	; warm start vector low byte
00A0C5  2  A0 A1        	LDY	#>LAB_1274	; warm start vector high byte
00A0C7  2  85 01        	STA	Wrmjpl		; set warm start vector low byte
00A0C9  2  84 02        	STY	Wrmjph		; set warm start vector high byte
00A0CB  2  6C 01 00     	JMP	(Wrmjpl)	; go do warm start
00A0CE  2               
00A0CE  2               ; open up space in memory
00A0CE  2               ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
00A0CE  2               
00A0CE  2               ; Nbendl,Nbendh - new block end address (A/Y)
00A0CE  2               ; Obendl,Obendh - old block end address
00A0CE  2               ; Ostrtl,Ostrth - old block start address
00A0CE  2               
00A0CE  2               ; returns with ..
00A0CE  2               
00A0CE  2               ; Nbendl,Nbendh - new block start address (high byte - $100)
00A0CE  2               ; Obendl,Obendh - old block start address (high byte - $100)
00A0CE  2               ; Ostrtl,Ostrth - old block start address (unchanged)
00A0CE  2               
00A0CE  2               LAB_11CF
00A0CE  2  20 1B A1     	JSR	LAB_121F	; check available memory, "Out of memory" error if no room
00A0D1  2               				; addr to check is in AY (low/high)
00A0D1  2  85 7F        	STA	Earryl		; save new array mem end low byte
00A0D3  2  84 80        	STY	Earryh		; save new array mem end high byte
00A0D5  2               
00A0D5  2               ; open up space in memory
00A0D5  2               ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
00A0D5  2               ; don't set array end
00A0D5  2               
00A0D5  2               LAB_11D6
00A0D5  2  38           	SEC			; set carry for subtract
00A0D6  2  A5 A6        	LDA	Obendl		; get block end low byte
00A0D8  2  E5 AA        	SBC	Ostrtl		; subtract block start low byte
00A0DA  2  A8           	TAY			; copy MOD(block length/$100) byte to Y
00A0DB  2  A5 A7        	LDA	Obendh		; get block end high byte
00A0DD  2  E5 AB        	SBC	Ostrth		; subtract block start high byte
00A0DF  2  AA           	TAX			; copy block length high byte to X
00A0E0  2  E8           	INX			; +1 to allow for count=0 exit
00A0E1  2  98           	TYA			; copy block length low byte to A
00A0E2  2  F0 24        	BEQ	LAB_120A	; branch if length low byte=0
00A0E4  2               
00A0E4  2               				; block is (X-1)*256+Y bytes, do the Y bytes first
00A0E4  2               
00A0E4  2  38           	SEC			; set carry for add + 1, two's complement
00A0E5  2  49 FF        	EOR	#$FF		; invert low byte for subtract
00A0E7  2  65 A6        	ADC	Obendl		; add block end low byte
00A0E9  2               
00A0E9  2  85 A6        	STA	Obendl		; save corrected old block end low byte
00A0EB  2  B0 03        	BCS	LAB_11F3	; branch if no underflow
00A0ED  2               
00A0ED  2  C6 A7        	DEC	Obendh		; else decrement block end high byte
00A0EF  2  38           	SEC			; set carry for add + 1, two's complement
00A0F0  2               LAB_11F3
00A0F0  2  98           	TYA			; get MOD(block length/$100) byte
00A0F1  2  49 FF        	EOR	#$FF		; invert low byte for subtract
00A0F3  2  65 A4        	ADC	Nbendl		; add destination end low byte
00A0F5  2  85 A4        	STA	Nbendl		; save modified new block end low byte
00A0F7  2  B0 08        	BCS	LAB_1203	; branch if no underflow
00A0F9  2               
00A0F9  2  C6 A5        	DEC	Nbendh		; else decrement block end high byte
00A0FB  2  90 04        	BCC	LAB_1203	; branch always
00A0FD  2               
00A0FD  2               LAB_11FF
00A0FD  2  B1 A6        	LDA	(Obendl),Y	; get byte from source
00A0FF  2  91 A4        	STA	(Nbendl),Y	; copy byte to destination
00A101  2               LAB_1203
00A101  2  88           	DEY			; decrement index
00A102  2  D0 F9        	BNE	LAB_11FF	; loop until Y=0
00A104  2               
00A104  2               				; now do Y=0 indexed byte
00A104  2  B1 A6        	LDA	(Obendl),Y	; get byte from source
00A106  2  91 A4        	STA	(Nbendl),Y	; save byte to destination
00A108  2               LAB_120A
00A108  2  C6 A7        	DEC	Obendh		; decrement source pointer high byte
00A10A  2  C6 A5        	DEC	Nbendh		; decrement destination pointer high byte
00A10C  2  CA           	DEX			; decrement block count
00A10D  2  D0 F2        	BNE	LAB_1203	; loop until count = $0
00A10F  2               
00A10F  2  60           	RTS
00A110  2               
00A110  2               ; check room on stack for A bytes
00A110  2               ; stack too deep? do OM error
00A110  2               
00A110  2               LAB_1212
00A110  2               ; *** patch - additional stack floor protection for background interrupts
00A110  2               ; *** add
00A110  2               .if Stack_floor
00A110  2  18           	CLC			; prep ADC
00A111  2  69 10        	ADC	#Stack_floor	; stack pointer lower limit before interrupts
00A113  2               .endif
00A113  2               ; *** end patch
00A113  2  85 78        	STA	TempB		; save result in temp byte
00A115  2  BA           	TSX			; copy stack
00A116  2  E4 78        	CPX	TempB		; compare new "limit" with stack
00A118  2  90 30        	BCC	LAB_OMER	; if stack < limit do "Out of memory" error then warm start
00A11A  2               
00A11A  2  60           	RTS
00A11B  2               
00A11B  2               ; check available memory, "Out of memory" error if no room
00A11B  2               ; addr to check is in AY (low/high)
00A11B  2               
00A11B  2               LAB_121F
00A11B  2  C4 82        	CPY	Sstorh		; compare bottom of string mem high byte
00A11D  2  90 2A        	BCC	LAB_124B	; if less then exit (is ok)
00A11F  2               
00A11F  2  D0 04        	BNE	LAB_1229	; skip next test if greater (tested <)
00A121  2               
00A121  2               				; high byte was =, now do low byte
00A121  2  C5 81        	CMP	Sstorl		; compare with bottom of string mem low byte
00A123  2  90 24        	BCC	LAB_124B	; if less then exit (is ok)
00A125  2               
00A125  2               				; addr is > string storage ptr (oops!)
00A125  2               LAB_1229
00A125  2  48           	PHA			; push addr low byte
00A126  2  A2 08        	LDX	#$08		; set index to save Adatal to expneg inclusive
00A128  2  98           	TYA			; copy addr high byte (to push on stack)
00A129  2               
00A129  2               				; save misc numeric work area
00A129  2               LAB_122D
00A129  2  48           	PHA			; push byte
00A12A  2  B5 A3        	LDA	Adatal-1,X	; get byte from Adatal to expneg ( ,$00 not pushed)
00A12C  2  CA           	DEX			; decrement index
00A12D  2  10 FA        	BPL	LAB_122D	; loop until all done
00A12F  2               
00A12F  2  20 34 B2     	JSR	LAB_GARB	; garbage collection routine
00A132  2               
00A132  2               				; restore misc numeric work area
00A132  2  A2 00        	LDX	#$00		; clear the index to restore bytes
00A134  2               LAB_1238
00A134  2  68           	PLA			; pop byte
00A135  2  95 A4        	STA	Adatal,X	; save byte to Adatal to expneg
00A137  2  E8           	INX			; increment index
00A138  2  E0 08        	CPX	#$08		; compare with end + 1
00A13A  2  30 F8        	BMI	LAB_1238	; loop if more to do
00A13C  2               
00A13C  2  68           	PLA			; pop addr high byte
00A13D  2  A8           	TAY			; copy back to Y
00A13E  2  68           	PLA			; pop addr low byte
00A13F  2  C4 82        	CPY	Sstorh		; compare bottom of string mem high byte
00A141  2  90 06        	BCC	LAB_124B	; if less then exit (is ok)
00A143  2               
00A143  2  D0 05        	BNE	LAB_OMER	; if greater do "Out of memory" error then warm start
00A145  2               
00A145  2               				; high byte was =, now do low byte
00A145  2  C5 81        	CMP	Sstorl		; compare with bottom of string mem low byte
00A147  2  B0 01        	BCS	LAB_OMER	; if >= do "Out of memory" error then warm start
00A149  2               
00A149  2               				; ok exit, carry clear
00A149  2               LAB_124B
00A149  2  60           	RTS
00A14A  2               
00A14A  2               ; do "Out of memory" error then warm start
00A14A  2               LAB_OMER
00A14A  2  A2 0C        	LDX	#$0C		; error code $0C ("Out of memory" error)
00A14C  2               
00A14C  2               ; do error #X, then warm start
00A14C  2               LAB_XERR
00A14C  2  20 E1 A8     	JSR	LAB_CRLF	; print CR/LF
00A14F  2               
00A14F  2  BD 26 C8     	LDA	LAB_BAER+0,X	; get error message pointer low byte
00A152  2  BC 27 C8     	LDY	LAB_BAER+1,X	; get error message pointer high byte
00A155  2               LAB_ERR2
00A155  2  20 22 A9     	JSR	LAB_18C3	; print null terminated string from memory
00A158  2               
00A158  2  20 D6 A3     	JSR	LAB_1491	; flush stack and clear continue flag
00A15B  2  A9 8C        	LDA	#<LAB_EMSG	; point to " error" low addr
00A15D  2  A0 C9        	LDY	#>LAB_EMSG	; point to " error" high addr
00A15F  2               LAB_1269
00A15F  2  20 22 A9     	JSR	LAB_18C3	; print null terminated string from memory
00A162  2  A4 88        	LDY	Clineh		; get current line high byte
00A164  2  C8           	INY			; increment it
00A165  2  F0 03        	BEQ	LAB_1274	; go do warm start (was immediate mode)
00A167  2               
00A167  2               				; else print line number
00A167  2  20 D9 BA     	JSR	LAB_2953	; print " in line [LINE #]"
00A16A  2               
00A16A  2               ; BASIC warm start entry point
00A16A  2               ; wait for Basic command
00A16A  2               
00A16A  2               LAB_1274
00A16A  2               .ifdef IRQVEC
00A16A  2               				; clear ON IRQ/NMI bytes
00A16A  2  A9 00        	LDA	#$00		; clear A
00A16C  2  85 DF        	STA	IrqBase		; clear enabled byte
00A16E  2  85 DC        	STA	NmiBase		; clear enabled byte
00A170  2               .endif
00A170  2  A9 9D        	LDA	#<LAB_RMSG	; point to "Ready" message low byte
00A172  2  A0 C9        	LDY	#>LAB_RMSG	; point to "Ready" message high byte
00A174  2  20 22 A9     	JSR	LAB_18C3	; print string
00A177  2               
00A177  2               ; wait for Basic command (no "Ready" message)
00A177  2               LAB_127D
00A177  2  20 6D A2     	JSR	LAB_1357	; call for BASIC input
00A17A  2               LAB_1280
00A17A  2  86 C3        	STX	Bpntrl		; set BASIC execute pointer low byte
00A17C  2  84 C4        	STY	Bpntrh		; set BASIC execute pointer high byte
00A17E  2  20 C2 00     	JSR	LAB_GBYT	; get byte from Bpntr
00A181  2  F0 F4        	BEQ	LAB_127D	; loop while null
00A183  2               
00A183  2               ; go to interpret input line now ..
00A183  2  A2 FF        	LDX	#$FF		; current line to null value
00A185  2  86 88        	STX	Clineh		; set current line high byte
00A187  2  90 06        	BCC	LAB_1295	; branch if numeric character (handle new BASIC line)
00A189  2               
00A189  2               				; no line number .. immediate mode
00A189  2  20 AC A2     	JSR	LAB_13A6	; crunch keywords into Basic tokens
00A18C  2  4C 40 A5     	JMP	LAB_15F6	; go scan and interpret code
00A18F  2               
00A18F  2               ; handle new BASIC line
00A18F  2               LAB_1295
00A18F  2  20 A1 A7     	JSR	LAB_GFPN	; get fixed-point number into temp integer
00A192  2  20 AC A2     	JSR	LAB_13A6	; crunch keywords into Basic tokens
00A195  2  84 5D        	STY	Ibptr		; save index pointer to end of crunched line
00A197  2  20 71 A3     	JSR	LAB_SSLN	; search BASIC for temp integer line number
00A19A  2  90 44        	BCC	LAB_12E6	; branch if not found
00A19C  2               
00A19C  2               				; aroooogah! line already exists! delete it
00A19C  2  A0 01        	LDY	#$01		; set index to next line pointer high byte
00A19E  2  B1 AA        	LDA	(Baslnl),Y	; get next line pointer high byte
00A1A0  2  85 72        	STA	ut1_ph		; save it
00A1A2  2  A5 7B        	LDA	Svarl		; get start of vars low byte
00A1A4  2  85 71        	STA	ut1_pl		; save it
00A1A6  2  A5 AB        	LDA	Baslnh		; get found line pointer high byte
00A1A8  2  85 74        	STA	ut2_ph		; save it
00A1AA  2  A5 AA        	LDA	Baslnl		; get found line pointer low byte
00A1AC  2  88           	DEY			; decrement index
00A1AD  2  F1 AA        	SBC	(Baslnl),Y	; subtract next line pointer low byte
00A1AF  2  18           	CLC			; clear carry for add
00A1B0  2  65 7B        	ADC	Svarl		; add start of vars low byte
00A1B2  2  85 7B        	STA	Svarl		; save new start of vars low byte
00A1B4  2  85 73        	STA	ut2_pl		; save destination pointer low byte
00A1B6  2  A5 7C        	LDA	Svarh		; get start of vars high byte
00A1B8  2  69 FF        	ADC	#$FF		; -1 + carry
00A1BA  2  85 7C        	STA	Svarh		; save start of vars high byte
00A1BC  2  E5 AB        	SBC	Baslnh		; subtract found line pointer high byte
00A1BE  2  AA           	TAX			; copy to block count
00A1BF  2  38           	SEC			; set carry for subtract
00A1C0  2  A5 AA        	LDA	Baslnl		; get found line pointer low byte
00A1C2  2  E5 7B        	SBC	Svarl		; subtract start of vars low byte
00A1C4  2  A8           	TAY			; copy to bytes in first block count
00A1C5  2  B0 03        	BCS	LAB_12D0	; branch if overflow
00A1C7  2               
00A1C7  2  E8           	INX			; increment block count (correct for =0 loop exit)
00A1C8  2  C6 74        	DEC	ut2_ph		; decrement destination high byte
00A1CA  2               LAB_12D0
00A1CA  2  18           	CLC			; clear carry for add
00A1CB  2  65 71        	ADC	ut1_pl		; add source pointer low byte
00A1CD  2  90 03        	BCC	LAB_12D8	; branch if no overflow
00A1CF  2               
00A1CF  2  C6 72        	DEC	ut1_ph		; else decrement source pointer high byte
00A1D1  2  18           	CLC			; clear carry
00A1D2  2               
00A1D2  2               				; close up memory to delete old line
00A1D2  2               LAB_12D8
00A1D2  2  B1 71        	LDA	(ut1_pl),Y	; get byte from source
00A1D4  2  91 73        	STA	(ut2_pl),Y	; copy to destination
00A1D6  2  C8           	INY			; increment index
00A1D7  2  D0 F9        	BNE	LAB_12D8	; while <> 0 do this block
00A1D9  2               
00A1D9  2  E6 72        	INC	ut1_ph		; increment source pointer high byte
00A1DB  2  E6 74        	INC	ut2_ph		; increment destination pointer high byte
00A1DD  2  CA           	DEX			; decrement block count
00A1DE  2  D0 F2        	BNE	LAB_12D8	; loop until all done
00A1E0  2               
00A1E0  2               				; got new line in buffer and no existing same #
00A1E0  2               LAB_12E6
00A1E0  2  A5 14        	LDA	Ibuffs		; get byte from start of input buffer
00A1E2  2  F0 3F        	BEQ	LAB_1319	; if null line just go flush stack/vars and exit
00A1E4  2               
00A1E4  2               				; got new line and it isn't empty line
00A1E4  2  A5 85        	LDA	Ememl		; get end of mem low byte
00A1E6  2  A4 86        	LDY	Ememh		; get end of mem high byte
00A1E8  2  85 81        	STA	Sstorl		; set bottom of string space low byte
00A1EA  2  84 82        	STY	Sstorh		; set bottom of string space high byte
00A1EC  2  A5 7B        	LDA	Svarl		; get start of vars low byte	(end of BASIC)
00A1EE  2  85 A6        	STA	Obendl		; save old block end low byte
00A1F0  2  A4 7C        	LDY	Svarh		; get start of vars high byte	(end of BASIC)
00A1F2  2  84 A7        	STY	Obendh		; save old block end high byte
00A1F4  2  65 5D        	ADC	Ibptr		; add input buffer pointer	(also buffer length)
00A1F6  2  90 01        	BCC	LAB_1301	; branch if no overflow from add
00A1F8  2               
00A1F8  2  C8           	INY			; else increment high byte
00A1F9  2               LAB_1301
00A1F9  2  85 A4        	STA	Nbendl		; save new block end low byte	(move to, low byte)
00A1FB  2  84 A5        	STY	Nbendh		; save new block end high byte
00A1FD  2  20 CE A0     	JSR	LAB_11CF	; open up space in memory
00A200  2               				; old start pointer Ostrtl,Ostrth set by the find line call
00A200  2  A5 7F        	LDA	Earryl		; get array mem end low byte
00A202  2  A4 80        	LDY	Earryh		; get array mem end high byte
00A204  2  85 7B        	STA	Svarl		; save start of vars low byte
00A206  2  84 7C        	STY	Svarh		; save start of vars high byte
00A208  2  A4 5D        	LDY	Ibptr		; get input buffer pointer	(also buffer length)
00A20A  2  88           	DEY			; adjust for loop type
00A20B  2               LAB_1311
00A20B  2  B9 10 00     	LDA	Ibuffs-4,Y	; get byte from crunched line
00A20E  2  91 AA        	STA	(Baslnl),Y	; save it to program memory
00A210  2  88           	DEY			; decrement count
00A211  2  C0 03        	CPY	#$03		; compare with first byte-1
00A213  2  D0 F6        	BNE	LAB_1311	; continue while count <> 3
00A215  2               
00A215  2  A5 12        	LDA	Itemph		; get line # high byte
00A217  2  91 AA        	STA	(Baslnl),Y	; save it to program memory
00A219  2  88           	DEY			; decrement count
00A21A  2  A5 11        	LDA	Itempl		; get line # low byte
00A21C  2  91 AA        	STA	(Baslnl),Y	; save it to program memory
00A21E  2  88           	DEY			; decrement count
00A21F  2  A9 FF        	LDA	#$FF		; set byte to allow chain rebuild. if you didn't set this
00A221  2               				; byte then a zero already here would stop the chain rebuild
00A221  2               				; as it would think it was the [EOT] marker.
00A221  2  91 AA        	STA	(Baslnl),Y	; save it to program memory
00A223  2               
00A223  2               LAB_1319
00A223  2               ;; to do: if first byte >=$20, text file loaded
00A223  2               ;;      JSR   LAB_1477          ;; moved to LAB_133E: reset execution to start, clear vars and flush stack
00A223  2  A6 79        	LDX	Smeml		; get start of mem low byte
00A225  2  A5 7A        	LDA	Smemh		; get start of mem high byte
00A227  2  A0 01        	LDY	#$01		; index to high byte of next line pointer
00A229  2               LAB_1325
00A229  2  86 71        	STX	ut1_pl		; set line start pointer low byte
00A22B  2  85 72        	STA	ut1_ph		; set line start pointer high byte
00A22D  2  B1 71        	LDA	(ut1_pl),Y	; get it
00A22F  2  F0 18        	BEQ	LAB_133E	; exit if end of program
00A231  2               
00A231  2               ; rebuild chaining of Basic lines
00A231  2               
00A231  2  A0 04        	LDY	#$04		; point to first code byte of line
00A233  2               				; there is always 1 byte + [EOL] as null entries are deleted
00A233  2               LAB_1330
00A233  2  C8           	INY			; next code byte
00A234  2  B1 71        	LDA	(ut1_pl),Y	; get byte
00A236  2  D0 FB        	BNE	LAB_1330	; loop if not [EOL]
00A238  2               
00A238  2  38           	SEC			; set carry for add + 1
00A239  2  98           	TYA			; copy end index
00A23A  2  65 71        	ADC	ut1_pl		; add to line start pointer low byte
00A23C  2  AA           	TAX			; copy to X
00A23D  2  A0 00        	LDY	#$00		; clear index, point to this line's next line pointer
00A23F  2  91 71        	STA	(ut1_pl),Y	; set next line pointer low byte
00A241  2  98           	TYA			; clear A
00A242  2  65 72        	ADC	ut1_ph		; add line start pointer high byte + carry
00A244  2  C8           	INY			; increment index to high byte
00A245  2  91 71        	STA	(ut1_pl),Y	; save next line pointer low byte
00A247  2  90 E0        	BCC	LAB_1325	; go do next line, branch always, carry clear
00A249  2               
00A249  2               LAB_133E
00A249  2  8A           	TXA			; step past program end marker
00A24A  2  18           	CLC
00A24B  2  69 02        	ADC #2
00A24D  2  85 7B        	STA	Svarl		; set start of variables low byte
00A24F  2  A5 72        	LDA	ut1_ph		; get line start pointer high byte
00A251  2  69 00        	ADC	#0
00A253  2  85 7C        	STA	Svarh		; set start of variables high byte
00A255  2  20 B2 A3     	JSR	LAB_1477	; reset execution to start, clear vars and flush stack
00A258  2  4C 77 A1     	JMP	LAB_127D	; just wait for Basic command, no "Ready"
00A25B  2               
00A25B  2               ; print "? " and get BASIC input
00A25B  2               
00A25B  2               LAB_INLN
00A25B  2  20 3A A9     	JSR	LAB_18E3	; print "?" character
00A25E  2  20 37 A9     	JSR	LAB_18E0	; print " "
00A261  2  D0 0A        	BNE	LAB_1357	; call for BASIC input and return
00A263  2               
00A263  2               ; receive line from keyboard
00A263  2               				; $08 (BACKSPACE) and $7F (DELETE) as delete key
00A263  2               LAB_134B
00A263  2  8A           	TXA
00A264  2  F0 09        	BEQ	LAB_1359	; buffer is empty
00A266  2  A9 7F        	LDA	#$7F
00A268  2  20 3C A9     	JSR	LAB_PRNA	; print the character
00A26B  2  CA           	DEX			; decrement the buffer counter (delete)
00A26C  2  2C           	.byte	$2C		; make LDX into BIT abs
00A26D  2               
00A26D  2               ; input a line of text (main entry point)
00A26D  2               LAB_1357
00A26D  2  A2 00        	LDX	#$00		; clear BASIC line buffer pointer
00A26F  2               LAB_1359
00A26F  2  20 52 C1     	JSR	V_INPT		; call scan input device
00A272  2  90 FB        	BCC	LAB_1359	; loop if no byte
00A274  2  F0 F9        	BEQ	LAB_1359	; loop until valid input (ignore NULLs)
00A276  2               
00A276  2  C9 03        	CMP	#BREAK		; compare with [CTRL-C/ESCAPE/BREAK]
00A278  2  D0 03        	BNE	LAB_NOTBREAK
00A27A  2  4C 7F A5     	JMP	LAB_BREAK
00A27D  2               LAB_NOTBREAK
00A27D  2  C9 07        	CMP	#$07		; compare with [BELL]
00A27F  2  F0 1F        	BEQ	LAB_137F	; branch if [BELL]
00A281  2               
00A281  2  C9 0A        	CMP	#$0A		; compare with [LF]
00A283  2  F0 20        	BEQ	LAB_1384	; do CR/LF exit if [LF]
00A285  2  C9 0D        	CMP	#$0D		; compare with [CR]
00A287  2  F0 1C        	BEQ	LAB_1384	; do CR/LF exit if [CR]
00A289  2               
00A289  2  E0 00        	CPX	#$00		; compare pointer with $00
00A28B  2  D0 04        	BNE	LAB_1374	; branch if not empty
00A28D  2               
00A28D  2               ; next two lines ignore any nonprinting character and [SPACE] if input buffer empty
00A28D  2               
00A28D  2  C9 21        	CMP	#$21		; compare with [SP]+1
00A28F  2  90 DE        	BCC	LAB_1359	; if < ignore character
00A291  2               
00A291  2               LAB_1374
00A291  2  C9 08        	CMP	#$08		; compare with [BACKSPACE] (delete last character)
00A293  2  F0 CE        	BEQ	LAB_134B	; go to delete last character
00A295  2  C9 7F        	CMP	#$7F		; compare with [DELETE] (delete last character)
00A297  2  F0 CA        	BEQ	LAB_134B	; go to delete last character
00A299  2               
00A299  2               LAB_1378
00A299  2  E0 47        	CPX	#Ibuffe-Ibuffs	; compare character count with max
00A29B  2  B0 0B        	BCS	LAB_138E	; skip store and do [BELL] if buffer full
00A29D  2               
00A29D  2  95 14        	STA	Ibuffs,X	; else store in buffer
00A29F  2  E8           	INX			; increment pointer
00A2A0  2               LAB_137F
00A2A0  2  20 3C A9     	JSR	LAB_PRNA	; print the character (returns NE if A<>0)
00A2A3  2  D0 CA        	BNE	LAB_1359	; loop for next character
00A2A5  2               
00A2A5  2               LAB_1384
00A2A5  2  4C D9 A8     	JMP	LAB_1866	; do CR/LF, return to caller
00A2A8  2               
00A2A8  2               ; announce buffer full
00A2A8  2               
00A2A8  2               LAB_138E
00A2A8  2  A9 07        	LDA	#$07		; [BELL] character into A
00A2AA  2  D0 F4        	BNE	LAB_137F	; print the [BELL] but ignore input character
00A2AC  2               				; branch always
00A2AC  2               
00A2AC  2               ; crunch keywords into Basic tokens
00A2AC  2               ; position independent buffer version ..
00A2AC  2               ; faster, dictionary search version ....
00A2AC  2               
00A2AC  2               LAB_13A6
00A2AC  2  A0 FF        	LDY	#$FF		; set save index (makes for easy maths later)
00A2AE  2               
00A2AE  2  A2 00        	LDX	#$00
00A2B0  2  86 60        	STX	Oquote		; clear open quote/DATA flag
00A2B2  2  86 5C        	STX	Asrch
00A2B4  2  38           	SEC			; set carry for subtract
00A2B5  2  A5 C3        	LDA	Bpntrl		; get basic execute pointer low byte
00A2B7  2  E9 14        	SBC	#<Ibuffs	; subtract input buffer start pointer
00A2B9  2  AA           	TAX			; copy result to X (index past line number if any)
00A2BA  2               ;;      STX   Oquote ; but X is no longer $00 ;; clear open quote/DATA flag
00A2BA  2               
00A2BA  2               LAB_13AC
00A2BA  2  B5 14        	LDA	Ibuffs,X	; get byte from input buffer
00A2BC  2  F0 6A        	BEQ	LAB_13EC	; if null save byte then exit
00A2BE  2               
00A2BE  2               ; *** begin patch: lower case token recognition ***
00A2BE  2               ; ***              WARNING! changes documented behavior!
00A2BE  2               ; *** add
00A2BE  2  C9 7B              CMP   #'{'              ; convert lower to upper case
00A2C0  2  B0 66              BCS   LAB_13EC          ; is above lower case
00A2C2  2  C9 61              CMP   #'a'
00A2C4  2  90 02              BCC   PATCH_LC          ; is below lower case
00A2C6  2  29 DF              AND   #$DF              ; mask lower case bit
00A2C8  2               
00A2C8  2               PATCH_LC
00A2C8  2               ; *** end
00A2C8  2               
00A2C8  2  C9 5F        	CMP	#'_'		; compare with "_"
00A2CA  2  B0 5C        	BCS	LAB_13EC	; if >= is lower case, save byte then continue crunching
00A2CC  2               
00A2CC  2  C9 3C        	CMP	#'<'		; compare with "<"
00A2CE  2  B0 18        	BCS	LAB_13CC	; if >= is upper case or symbol, crunch
00A2D0  2               
00A2D0  2  C9 30        	CMP	#'0'		; compare with "0"
00A2D2  2  B0 54        	BCS	LAB_13EC	; if >= is digit, save byte then continue crunching
00A2D4  2               
00A2D4  2  85 5C        	STA	Scnquo		; save buffer byte as search character
00A2D6  2  C9 22        	CMP	#$22		; is it quote character?
00A2D8  2  F0 74        	BEQ	LAB_1410	; branch if so (copy quoted string)
00A2DA  2               
00A2DA  2  C9 2A        	CMP	#'*'		; compare with "*"
00A2DC  2  90 4A        	BCC	LAB_13EC	; if < go save byte then continue crunching
00A2DE  2  D0 08        	BNE	LAB_13CC
00A2E0  2  A9 00        	LDA	#$00
00A2E2  2  24 60        	BIT	Oquote		; test for "*" at start of statement
00A2E4  2  10 5E        	BPL	LAB_1405	; start of statement, copy rest of line
00A2E6  2  A9 2A        	LDA	#'*'
00A2E8  2               
00A2E8  2               				; else crunch now
00A2E8  2               LAB_13CC
00A2E8  2  24 60        	BIT	Oquote		; get open quote/DATA token flag
00A2EA  2  70 3C        	BVS	LAB_13EC	; branch if b6 of Oquote set (was DATA)
00A2EC  2               				; go save byte then continue crunching
00A2EC  2               
00A2EC  2  86 78        	STX	TempB		; save buffer read index
00A2EE  2  84 BA        	STY	csidx		; copy buffer save index
00A2F0  2  A0 AF        	LDY	#<TAB_1STC	; get keyword first character table low address
00A2F2  2  84 73        	STY	ut2_pl		; save pointer low byte
00A2F4  2  A0 C3        	LDY	#>TAB_1STC	; get keyword first character table high address
00A2F6  2  84 74        	STY	ut2_ph		; save pointer high byte
00A2F8  2  A0 00        	LDY	#$00		; clear table pointer
00A2FA  2               
00A2FA  2               LAB_13D0
00A2FA  2  D1 73        	CMP	(ut2_pl),Y	; compare with keyword first character table byte
00A2FC  2  F0 05        	BEQ	LAB_13D1	; go do word_table_chr if match
00A2FE  2               
00A2FE  2               ;	BCC	LAB_13EA	; if < keyword first character table byte go restore
00A2FE  2  90 62        	BCC	PATCH_LC2	; if < keyword first character table byte go restore
00A300  2               				; Y and save to crunched
00A300  2               
00A300  2  C8           	INY			; else increment pointer
00A301  2  D0 F7        	BNE	LAB_13D0	; and loop (branch always)
00A303  2               
00A303  2               ; have matched first character of some keyword
00A303  2               
00A303  2               LAB_13D1
00A303  2  98           	TYA			; copy matching index
00A304  2  0A           	ASL			; *2 (bytes per pointer)
00A305  2  AA           	TAX			; copy to new index
00A306  2  BD CD C3     	LDA	TAB_CHRT,X	; get keyword table pointer low byte
00A309  2  85 73        	STA	ut2_pl		; save pointer low byte
00A30B  2  BD CE C3     	LDA	TAB_CHRT+1,X	; get keyword table pointer high byte
00A30E  2  85 74        	STA	ut2_ph		; save pointer high byte
00A310  2               
00A310  2  A0 FF        	LDY	#$FF		; clear table pointer (make -1 for start)
00A312  2               
00A312  2  A6 78        	LDX	TempB		; restore buffer read index
00A314  2               
00A314  2               LAB_13D6
00A314  2  C8           	INY			; next table byte
00A315  2  B1 73        	LDA	(ut2_pl),Y	; get byte from table
00A317  2               LAB_13D8
00A317  2  30 0D        	BMI	LAB_13EA	; all bytes matched so go save token
00A319  2               
00A319  2  E8           	INX			; next buffer byte
00A31A  2  D5 14        	CMP	Ibuffs,X	; compare with byte from input buffer
00A31C  2  F0 F6        	BEQ	LAB_13D6	; go compare next if match
00A31E  2               
00A31E  2               ; *** add
00A31E  2  09 20              ORA #$20                ; repeat with lower case
00A320  2  D5 14              CMP Ibuffs,X            ; compare with byte from input buffer
00A322  2  F0 F0              BEQ LAB_13D6            ; go compare next if match
00A324  2               ; *** end
00A324  2               
00A324  2  D0 2F        	BNE	LAB_1417	; branch if >< (not found keyword)
00A326  2               
00A326  2               LAB_13EA
00A326  2  A4 BA        	LDY	csidx		; restore save index
00A328  2               
00A328  2               				; save crunched to output
00A328  2               LAB_13EC
00A328  2  E8           	INX			; increment buffer index (to next input byte)
00A329  2  C8           	INY			; increment save index (to next output byte)
00A32A  2  99 14 00     	STA	Ibuffs,Y	; save byte to output
00A32D  2  C9 00        	CMP	#$00		; set the flags, set carry
00A32F  2  F0 35        	BEQ	LAB_142A	; do exit if was null [EOL]
00A331  2               
00A331  2               				; A holds token or byte here
00A331  2  E9 3A        	SBC	#':'		; subtract ":" (carry set by CMP #00)
00A333  2  F0 06        	BEQ	LAB_13FF	; branch if it was ":" (is now $00)
00A335  2               
00A335  2               				; A now holds token-$3A
00A335  2  C9 49        	CMP	#TK_DATA-$3A	; compare with DATA token - $3A
00A337  2  F0 02        	BEQ	LAB_13FF	; branch if DATA
00A339  2  A9 80        	LDA	#$80
00A33B  2               				; token was : or DATA
00A33B  2               LAB_13FF
00A33B  2  85 60        	STA	Oquote		; save token-$3A (clear for ":", TK_DATA-$3A for DATA)
00A33D  2               LAB_1401
00A33D  2  49 57        	EOR	#TK_REM-$3A	; effectively subtract REM token offset
00A33F  2  F0 03            BEQ LAB_1405
00A341  2  4C BA A2     	JMP LAB_13AC
00A344  2               ;	BNE	LAB_13AC	; If wasn't REM then go crunch rest of line
00A344  2               LAB_1405
00A344  2  85 5C        	STA	Asrch		; else was REM so set search for [EOL]
00A346  2               
00A346  2               				; loop for REM, "..." etc.
00A346  2               LAB_1408
00A346  2  B5 14        	LDA	Ibuffs,X	; get byte from input buffer
00A348  2  F0 DE        	BEQ	LAB_13EC	; branch if null [EOL]
00A34A  2               
00A34A  2  C5 5C        	CMP	Asrch		; compare with stored character
00A34C  2  F0 DA        	BEQ	LAB_13EC	; branch if match (end quote)
00A34E  2               
00A34E  2               				; entry for copy string in quotes, don't crunch
00A34E  2               LAB_1410
00A34E  2  C8           	INY			; increment buffer save index
00A34F  2  99 14 00     	STA	Ibuffs,Y	; save byte to output
00A352  2  E8           	INX			; increment buffer read index
00A353  2  D0 F1        	BNE	LAB_1408	; loop while <> 0 (should never be 0!)
00A355  2               
00A355  2               				; not found keyword this go
00A355  2               LAB_1417
00A355  2  A6 78        	LDX	TempB		; compare has failed, restore buffer index (start byte!)
00A357  2               
00A357  2               				; now find the end of this word in the table
00A357  2               LAB_141B
00A357  2  B1 73        	LDA	(ut2_pl),Y	; get table byte
00A359  2  08           	PHP			; save status
00A35A  2  C8           	INY			; increment table index
00A35B  2  28           	PLP			; restore byte status
00A35C  2  10 F9        	BPL	LAB_141B	; if not end of keyword go do next
00A35E  2               
00A35E  2  B1 73        	LDA	(ut2_pl),Y	; get byte from keyword table
00A360  2  D0 B5        	BNE	LAB_13D8	; go test next word if not zero byte (end of table)
00A362  2               
00A362  2               ; *** add label
00A362  2               PATCH_LC2
00A362  2               ; *** end
00A362  2               ; *** end   patch: lower case token recognition ***
00A362  2               				; reached end of table with no match
00A362  2  B5 14        	LDA	Ibuffs,X	; restore byte from input buffer
00A364  2  10 C0        	BPL	LAB_13EA	; branch always (all bytes in buffer are $00-$7F)
00A366  2               				; go save byte in output and continue crunching
00A366  2               
00A366  2               				; reached [EOL]
00A366  2               LAB_142A
00A366  2  C8           	INY			; increment pointer
00A367  2  C8           	INY			; increment pointer (makes it next line pointer high byte)
00A368  2  99 14 00     	STA	Ibuffs,Y	; save [EOL] (marks [EOT] in immediate mode)
00A36B  2  C8           	INY			; adjust for line copy
00A36C  2  C8           	INY			; adjust for line copy
00A36D  2  C8           	INY			; adjust for line copy
00A36E  2               ; *** begin patch for when Ibuffs is $xx00 - Daryl Rictor ***
00A36E  2               ; *** insert
00A36E  2               .if (Ibuffs & $FF) = 0
00A36E  2               	LDA	Bpntrl		; test for $00
00A36E  2               	BNE	LAB_142P	; not $00
00A36E  2               	DEC	Bpntrh		; allow for increment when $xx00
00A36E  2               LAB_142P
00A36E  2               .endif
00A36E  2               ; *** end   patch for when Ibuffs is $xx00 - Daryl Rictor ***
00A36E  2               ; end of patch
00A36E  2  C6 C3        	DEC	Bpntrl		; allow for increment (change if buffer starts at $xxFF)
00A370  2  60           	RTS
00A371  2               
00A371  2               
00A371  2               ; search Basic for temp integer line number from start of mem
00A371  2               
00A371  2               LAB_SSLN
00A371  2  A5 79        	LDA	Smeml		; get start of mem low byte
00A373  2  A6 7A        	LDX	Smemh		; get start of mem high byte
00A375  2               
00A375  2               ; search Basic for temp integer line number from AX
00A375  2               ; returns carry set if found
00A375  2               ; returns Baslnl/Baslnh pointer to found or next higher (not found) line
00A375  2               
00A375  2               ; old 541 new 507
00A375  2               
00A375  2               LAB_SHLN
00A375  2  A0 01        	LDY	#$01		; set index
00A377  2  85 AA        	STA	Baslnl		; save low byte as current
00A379  2  86 AB        	STX	Baslnh		; save high byte as current
00A37B  2  B1 AA        	LDA	(Baslnl),Y	; get pointer high byte from addr
00A37D  2  F0 1A        	BEQ	LAB_145F	; pointer was zero so we're done, do 'not found' exit
00A37F  2               
00A37F  2  A0 03        	LDY	#$03		; set index to line # high byte
00A381  2  B1 AA        	LDA	(Baslnl),Y	; get line # high byte
00A383  2  88           	DEY			; decrement index (point to low byte)
00A384  2  C5 12        	CMP	Itemph		; compare with temporary integer high byte
00A386  2  D0 04        	BNE	LAB_1455	; if <> skip low byte check
00A388  2               
00A388  2  B1 AA        	LDA	(Baslnl),Y	; get line # low byte
00A38A  2  C5 11        	CMP	Itempl		; compare with temporary integer low byte
00A38C  2               LAB_1455
00A38C  2  B0 09        	BCS	LAB_145E	; else if temp < this line, exit (passed line#)
00A38E  2               
00A38E  2               LAB_1456
00A38E  2  88           	DEY			; decrement index to next line ptr high byte
00A38F  2  B1 AA        	LDA	(Baslnl),Y	; get next line pointer high byte
00A391  2  AA           	TAX			; copy to X
00A392  2  88           	DEY			; decrement index to next line ptr low byte
00A393  2  B1 AA        	LDA	(Baslnl),Y	; get next line pointer low byte
00A395  2  90 DE        	BCC	LAB_SHLN	; go search for line # in temp (Itempl/Itemph) from AX
00A397  2               				; (carry always clear)
00A397  2               
00A397  2               LAB_145E
00A397  2  F0 01        	BEQ	LAB_1460	; exit if temp = found line #, carry is set
00A399  2               
00A399  2               LAB_145F
00A399  2  18           	CLC			; clear found flag
00A39A  2               LAB_1460
00A39A  2  60           	RTS
00A39B  2               
00A39B  2               ; perform NEW
00A39B  2               
00A39B  2               LAB_NEW
00A39B  2  D0 FD        	BNE	LAB_1460	; exit if not end of statement (to do syntax error)
00A39D  2               
00A39D  2               LAB_1463
00A39D  2  A9 00        	LDA	#$00		; clear A
00A39F  2  A8           	TAY			; clear Y
00A3A0  2  91 79        	STA	(Smeml),Y	; clear first line, next line pointer, low byte
00A3A2  2  C8           	INY			; increment index
00A3A3  2  91 79        	STA	(Smeml),Y	; clear first line, next line pointer, high byte
00A3A5  2  18           	CLC			; clear carry
00A3A6  2  A5 79        	LDA	Smeml		; get start of mem low byte
00A3A8  2  69 02        	ADC	#$02		; calculate end of BASIC low byte
00A3AA  2  85 7B        	STA	Svarl		; save start of vars low byte
00A3AC  2  A5 7A        	LDA	Smemh		; get start of mem high byte
00A3AE  2  69 00        	ADC	#$00		; add any carry
00A3B0  2  85 7C        	STA	Svarh		; save start of vars high byte
00A3B2  2               
00A3B2  2               ; reset execution to start, clear vars and flush stack
00A3B2  2               
00A3B2  2               LAB_1477
00A3B2  2  18           	CLC			; clear carry
00A3B3  2  A5 79        	LDA	Smeml		; get start of mem low byte
00A3B5  2  69 FF        	ADC	#$FF		; -1
00A3B7  2  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
00A3B9  2  A5 7A        	LDA	Smemh		; get start of mem high byte
00A3BB  2  69 FF        	ADC	#$FF		; -1+carry
00A3BD  2  85 C4        	STA	Bpntrh		; save BASIC execute pointer high byte
00A3BF  2               
00A3BF  2               ; "CLEAR" command gets here
00A3BF  2               
00A3BF  2               LAB_147A
00A3BF  2  A5 85        	LDA	Ememl		; get end of mem low byte
00A3C1  2  A4 86        	LDY	Ememh		; get end of mem high byte
00A3C3  2  85 81        	STA	Sstorl		; set bottom of string space low byte
00A3C5  2  84 82        	STY	Sstorh		; set bottom of string space high byte
00A3C7  2  A5 7B        	LDA	Svarl		; get start of vars low byte
00A3C9  2  A4 7C        	LDY	Svarh		; get start of vars high byte
00A3CB  2  85 7D        	STA	Sarryl		; save var mem end low byte
00A3CD  2  84 7E        	STY	Sarryh		; save var mem end high byte
00A3CF  2  85 7F        	STA	Earryl		; save array mem end low byte
00A3D1  2  84 80        	STY	Earryh		; save array mem end high byte
00A3D3  2  20 8B A5     	JSR	LAB_161A	; perform RESTORE command
00A3D6  2               
00A3D6  2               ; flush stack and clear continue flag
00A3D6  2               
00A3D6  2               LAB_1491
00A3D6  2  A2 68        	LDX	#des_sk		; set descriptor stack pointer
00A3D8  2  86 65        	STX	next_s		; save descriptor stack pointer
00A3DA  2  68           	PLA			; pull return address low byte
00A3DB  2  AA           	TAX			; copy return address low byte
00A3DC  2  68           	PLA			; pull return address high byte
00A3DD  2  8E FE 01     	STX	LAB_SKFE	; save to cleared stack
00A3E0  2  8D FF 01     	STA	LAB_SKFF	; save to cleared stack
00A3E3  2  A2 FD        	LDX	#$FD		; new stack pointer
00A3E5  2  9A           	TXS			; reset stack
00A3E6  2  A9 00        	LDA	#$00		; clear byte
00A3E8  2               ;*** fix p2: no longer necessary as the continue pointer is saved anyway
00A3E8  2               ;      STA   Cpntrh            ; clear continue pointer high byte
00A3E8  2  85 61        	STA	Sufnxf		; clear subscript/FNX flag
00A3EA  2               LAB_14A6
00A3EA  2  60           	RTS
00A3EB  2               
00A3EB  2               ; perform CLEAR
00A3EB  2               
00A3EB  2               LAB_CLEAR
00A3EB  2  F0 D2        	BEQ	LAB_147A	; if no following token go to "CLEAR"
00A3ED  2               
00A3ED  2               				; else there was a following token (go to syntax error)
00A3ED  2  60           	RTS
00A3EE  2               
00A3EE  2               ; perform LIST [n][-m]
00A3EE  2               ; bigger, faster version (a _lot_ faster)
00A3EE  2               ; to do: output to file
00A3EE  2               
00A3EE  2               LAB_LIST
00A3EE  2  90 06        	BCC	LAB_14BD	; branch if next character numeric (LIST n..)
00A3F0  2               
00A3F0  2  F0 04        	BEQ	LAB_14BD	; branch if next character [NULL] (LIST)
00A3F2  2               
00A3F2  2  C9 CE        	CMP	#TK_MINUS	; compare with token for -
00A3F4  2  D0 F4        	BNE	LAB_14A6	; exit if not - (LIST -m)
00A3F6  2               
00A3F6  2               				; LIST [[n][-m]]
00A3F6  2               				; this bit sets the n , if present, as the start and end
00A3F6  2               LAB_14BD
00A3F6  2  20 A1 A7     	JSR	LAB_GFPN	; get fixed-point number into temp integer
00A3F9  2  20 71 A3     	JSR	LAB_SSLN	; search BASIC for temp integer line number
00A3FC  2               				; (pointer in Baslnl/Baslnh)
00A3FC  2  20 C2 00     	JSR	LAB_GBYT	; scan memory
00A3FF  2  F0 0C        	BEQ	LAB_14D4	; branch if no more characters
00A401  2               
00A401  2               				; this bit checks the - is present
00A401  2  C9 CE        	CMP	#TK_MINUS	; compare with token for -
00A403  2  D0 95        	BNE	LAB_1460	; return if not "-" (will be Syntax error)
00A405  2               
00A405  2               				; LIST [n]-m
00A405  2               				; the - was there so set m as the end value
00A405  2  20 BC 00     	JSR	LAB_IGBY	; increment and scan memory
00A408  2  20 A1 A7     	JSR	LAB_GFPN	; get fixed-point number into temp integer
00A40B  2  D0 8D        	BNE	LAB_1460	; exit if not ok
00A40D  2               
00A40D  2               LAB_14D4
00A40D  2  A5 11        	LDA	Itempl		; get temporary integer low byte
00A40F  2  05 12        	ORA	Itemph		; OR temporary integer high byte
00A411  2  D0 06        	BNE	LAB_14E2	; branch if start set
00A413  2               
00A413  2  A9 FF        	LDA	#$FF		; set for -1
00A415  2  85 11        	STA	Itempl		; set temporary integer low byte
00A417  2  85 12        	STA	Itemph		; set temporary integer high byte
00A419  2               LAB_14E2
00A419  2  A0 01        	LDY	#$01		; set index for line
00A41B  2  84 60        	STY	Oquote		; clear open quote flag
00A41D  2  20 E1 A8     	JSR	LAB_CRLF	; print CR/LF
00A420  2  B1 AA        	LDA	(Baslnl),Y	; get next line pointer high byte
00A422  2               				; pointer initially set by search at LAB_14BD
00A422  2  F0 3E        	BEQ	LAB_152B	; if null all done so exit
00A424  2  20 61 A5     	JSR	LAB_1629	; do CRTL-C check vector
00A427  2               
00A427  2  C8           	INY			; increment index for line
00A428  2  B1 AA        	LDA	(Baslnl),Y	; get line # low byte
00A42A  2  AA           	TAX			; copy to X
00A42B  2  C8           	INY			; increment index
00A42C  2  B1 AA        	LDA	(Baslnl),Y	; get line # high byte
00A42E  2  C5 12        	CMP	Itemph		; compare with temporary integer high byte
00A430  2  D0 04        	BNE	LAB_14FF	; branch if no high byte match
00A432  2               
00A432  2  E4 11        	CPX	Itempl		; compare with temporary integer low byte
00A434  2  F0 02        	BEQ	LAB_1501	; branch if = last line to do (< will pass next branch)
00A436  2               
00A436  2               LAB_14FF			; else ..
00A436  2  B0 2A        	BCS	LAB_152B	; if greater all done so exit
00A438  2               
00A438  2               LAB_1501
00A438  2  84 97        	STY	Tidx1		; save index for line
00A43A  2  20 E4 BA     	JSR	LAB_295E	; print XA as unsigned integer
00A43D  2  A9 20        	LDA	#$20		; space is the next character
00A43F  2               LAB_1508
00A43F  2  A4 97        	LDY	Tidx1		; get index for line
00A441  2  29 7F        	AND	#$7F		; mask top out bit of character
00A443  2               LAB_150C
00A443  2  20 3C A9     	JSR	LAB_PRNA	; go print the character
00A446  2  C9 22        	CMP	#$22		; was it " character
00A448  2  D0 06        	BNE	LAB_1519	; branch if not
00A44A  2               
00A44A  2               				; we are either entering or leaving a pair of quotes
00A44A  2  A5 60        	LDA	Oquote		; get open quote flag
00A44C  2  49 FF        	EOR	#$FF		; toggle it
00A44E  2  85 60        	STA	Oquote		; save it back
00A450  2               LAB_1519
00A450  2  C8           	INY			; increment index
00A451  2  B1 AA        	LDA	(Baslnl),Y	; get next byte
00A453  2  D0 0E        	BNE	LAB_152E	; branch if not [EOL] (go print character)
00A455  2  A8           	TAY			; else clear index
00A456  2  B1 AA        	LDA	(Baslnl),Y	; get next line pointer low byte
00A458  2  AA           	TAX			; copy to X
00A459  2  C8           	INY			; increment index
00A45A  2  B1 AA        	LDA	(Baslnl),Y	; get next line pointer high byte
00A45C  2  86 AA        	STX	Baslnl		; set pointer to line low byte
00A45E  2  85 AB        	STA	Baslnh		; set pointer to line high byte
00A460  2  D0 B7        	BNE	LAB_14E2	; go do next line if not [EOT]
00A462  2               				; else ..
00A462  2               LAB_152B
00A462  2  60           	RTS
00A463  2               
00A463  2               LAB_152E
00A463  2  10 DE        	BPL	LAB_150C	; just go print it if not token byte
00A465  2               
00A465  2               				; else was token byte so uncrunch it (maybe)
00A465  2  24 60        	BIT	Oquote		; test the open quote flag
00A467  2  30 DA        	BMI	LAB_150C	; just go print character if open quote set
00A469  2               
00A469  2  A2 C6        	LDX	#>LAB_KEYT	; get table address high byte
00A46B  2  0A           	ASL			; *2
00A46C  2  0A           	ASL			; *4
00A46D  2  90 02        	BCC	LAB_152F	; branch if no carry
00A46F  2               
00A46F  2  E8           	INX			; else increment high byte
00A470  2  18           	CLC			; clear carry for add
00A471  2               LAB_152F
00A471  2  69 2E        	ADC	#<LAB_KEYT	; add low byte
00A473  2  90 01        	BCC	LAB_1530	; branch if no carry
00A475  2               
00A475  2  E8           	INX			; else increment high byte
00A476  2               LAB_1530
00A476  2  85 73        	STA	ut2_pl		; save table pointer low byte
00A478  2  86 74        	STX	ut2_ph		; save table pointer high byte
00A47A  2  84 97        	STY	Tidx1		; save index for line
00A47C  2  A0 00        	LDY	#$00		; clear index
00A47E  2  B1 73        	LDA	(ut2_pl),Y	; get length
00A480  2  AA           	TAX			; copy length
00A481  2  C8           	INY			; increment index
00A482  2  B1 73        	LDA	(ut2_pl),Y	; get 1st character
00A484  2  CA           	DEX			; decrement length
00A485  2  F0 B8        	BEQ	LAB_1508	; if no more characters exit and print
00A487  2               
00A487  2  20 3C A9     	JSR	LAB_PRNA	; go print the character
00A48A  2  C8           	INY			; increment index
00A48B  2  B1 73        	LDA	(ut2_pl),Y	; get keyword address low byte
00A48D  2  48           	PHA			; save it for now
00A48E  2  C8           	INY			; increment index
00A48F  2  B1 73        	LDA	(ut2_pl),Y	; get keyword address high byte
00A491  2  A0 00        	LDY	#$00
00A493  2  85 74        	STA	ut2_ph		; save keyword pointer high byte
00A495  2  68           	PLA			; pull low byte
00A496  2  85 73        	STA	ut2_pl		; save keyword pointer low byte
00A498  2               LAB_1540
00A498  2  B1 73        	LDA	(ut2_pl),Y	; get character
00A49A  2  CA           	DEX			; decrement character count
00A49B  2  F0 A2        	BEQ	LAB_1508	; if last character exit and print
00A49D  2               
00A49D  2  20 3C A9     	JSR	LAB_PRNA	; go print the character
00A4A0  2  C8           	INY			; increment index
00A4A1  2  D0 F5        	BNE	LAB_1540	; loop for next character
00A4A3  2               
00A4A3  2               ; perform FOR
00A4A3  2               
00A4A3  2               LAB_FOR
00A4A3  2  A9 80        	LDA	#$80		; set FNX
00A4A5  2  85 61        	STA	Sufnxf		; set subscript/FNX flag
00A4A7  2  20 00 A8     	JSR	LAB_LET		; go do LET
00A4AA  2  68           	PLA			; pull return address
00A4AB  2  68           	PLA			; pull return address
00A4AC  2  A9 10        	LDA	#$10		; we need 16d bytes !
00A4AE  2  20 10 A1     	JSR	LAB_1212	; check room on stack for A bytes
00A4B1  2  20 E6 A6     	JSR	LAB_SNBS	; scan for next BASIC statement ([:] or [EOL])
00A4B4  2  18           	CLC			; clear carry for add
00A4B5  2  98           	TYA			; copy index to A
00A4B6  2  65 C3        	ADC	Bpntrl		; add BASIC execute pointer low byte
00A4B8  2  48           	PHA			; push onto stack
00A4B9  2  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
00A4BB  2  69 00        	ADC	#$00		; add carry
00A4BD  2  48           	PHA			; push onto stack
00A4BE  2  A5 88        	LDA	Clineh		; get current line high byte
00A4C0  2  48           	PHA			; push onto stack
00A4C1  2  A5 87        	LDA	Clinel		; get current line low byte
00A4C3  2  48           	PHA			; push onto stack
00A4C4  2  A9 C4        	LDA	#TK_TO		; get "TO" token
00A4C6  2  20 39 AC     	JSR	LAB_SCCA	; scan for CHR$(A) , else do syntax error then warm start
00A4C9  2  20 17 AB     	JSR	LAB_CTNM	; check if source is numeric, else do type mismatch
00A4CC  2  20 14 AB     	JSR	LAB_EVNM	; evaluate expression and check is numeric,
00A4CF  2               				; else do type mismatch
00A4CF  2               ; *** begin patch  2.22p5.1   TO expression may get sign bit flipped
00A4CF  2               ; *** add
00A4CF  2  20 3B B9     	JSR	LAB_27BA	; round FAC1
00A4D2  2               ; *** end   patch  2.22p5.1   TO expression may get sign bit flipped
00A4D2  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
00A4D4  2  09 7F        	ORA	#$7F		; set all non sign bits
00A4D6  2  25 AD        	AND	FAC1_1		; and FAC1 mantissa1
00A4D8  2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
00A4DA  2  A9 E5        	LDA	#<LAB_159F	; set return address low byte
00A4DC  2  A0 A4        	LDY	#>LAB_159F	; set return address high byte
00A4DE  2  85 71        	STA	ut1_pl		; save return address low byte
00A4E0  2  84 72        	STY	ut1_ph		; save return address high byte
00A4E2  2  4C CF AB     	JMP	LAB_1B66	; round FAC1 and put on stack (returns to next instruction)
00A4E5  2               
00A4E5  2               LAB_159F
00A4E5  2  A9 4D        	LDA	#<LAB_259C	; set 1 pointer low addr (default step size)
00A4E7  2  A0 C2        	LDY	#>LAB_259C	; set 1 pointer high addr
00A4E9  2  20 DF B8     	JSR	LAB_UFAC	; unpack memory (AY) into FAC1
00A4EC  2  20 C2 00     	JSR	LAB_GBYT	; scan memory
00A4EF  2  C9 C9        	CMP	#TK_STEP	; compare with STEP token
00A4F1  2  D0 06        	BNE	LAB_15B3	; jump if not "STEP"
00A4F3  2               
00A4F3  2               				;.was step so ..
00A4F3  2  20 BC 00     	JSR	LAB_IGBY	; increment and scan memory
00A4F6  2  20 14 AB     	JSR	LAB_EVNM	; evaluate expression and check is numeric,
00A4F9  2               				; else do type mismatch
00A4F9  2               LAB_15B3
00A4F9  2  20 4B B9     	JSR	LAB_27CA	; return A=FF,C=1/-ve A=01,C=0/+ve
00A4FC  2  85 B0        	STA	FAC1_s		; set FAC1 sign (b7)
00A4FE  2               				; this is +1 for +ve step and -1 for -ve step, in NEXT we
00A4FE  2               				; compare the FOR value and the TO value and return +1 if
00A4FE  2               				; FOR > TO, 0 if FOR = TO and -1 if FOR < TO. the value
00A4FE  2               				; here (+/-1) is then compared to that result and if they
00A4FE  2               				; are the same (+ve and FOR > TO or -ve and FOR < TO) then
00A4FE  2               				; the loop is done
00A4FE  2               
00A4FE  2               ; *** begin patch  2.22p5.3   potential return address -$100 (page not incremented) ***
00A4FE  2               ; *** add
00A4FE  2               ;.if (* & $FF) = $FD
00A4FE  2  EA           	NOP			; push code on so return address of JSR on same page
00A4FF  2               ;.endif
00A4FF  2               ; *** end   patch  2.22p5.3   potential return address -$100 (page not incremented) ***
00A4FF  2  20 C1 AB     	JSR	LAB_1B5B	; push sign, round FAC1 and put on stack
00A502  2  A5 98        	LDA	Frnxth		; get var pointer for FOR/NEXT high byte
00A504  2  48           	PHA			; push on stack
00A505  2  A5 97        	LDA	Frnxtl		; get var pointer for FOR/NEXT low byte
00A507  2  48           	PHA			; push on stack
00A508  2  A9 81        	LDA	#TK_FOR		; get FOR token
00A50A  2  48           	PHA			; push on stack
00A50B  2               
00A50B  2               ; interpreter inner loop
00A50B  2               
00A50B  2               LAB_15C2
00A50B  2  20 61 A5     	JSR	LAB_1629	; do CRTL-C check
00A50E  2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
00A510  2  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte
00A512  2               
00A512  2  A6 88        	LDX	Clineh		; continue line is $FFxx for immediate mode
00A514  2               				; ($00xx for RUN from immediate mode)
00A514  2  E8           	INX			; increment it (now $00 if immediate mode)
00A515  2               ;*** fix p2: skip no longer necessary as the continue pointer is saved anyway
00A515  2               ;      BEQ   LAB_15D1          ; branch if null (immediate mode)
00A515  2               
00A515  2  85 8B        	STA	Cpntrl		; save continue pointer low byte
00A517  2  84 8C        	STY	Cpntrh		; save continue pointer high byte
00A519  2               LAB_15D1
00A519  2  A0 00        	LDY	#$00		; clear index
00A51B  2  B1 C3        	LDA	(Bpntrl),Y	; get next byte
00A51D  2  F0 07        	BEQ	LAB_15DC	; branch if null [EOL]
00A51F  2               
00A51F  2  C9 3A        	CMP	#':'		; compare with ":"
00A521  2  F0 1D        	BEQ	LAB_15F6	; branch if = (statement separator)
00A523  2               
00A523  2               LAB_15D9
00A523  2  4C 4A AC     	JMP	LAB_SNER	; else syntax error then warm start
00A526  2               
00A526  2               				; have reached [EOL]
00A526  2               LAB_15DC
00A526  2  A0 02        	LDY	#$02		; set index
00A528  2  B1 C3        	LDA	(Bpntrl),Y	; get next line pointer high byte
00A52A  2  18           	CLC			; clear carry for no "BREAK" message
00A52B  2  F0 50        	BEQ	LAB_1651	; if null go to immediate mode (was immediate or [EOT]
00A52D  2               				; marker)
00A52D  2               
00A52D  2  C8           	INY			; increment index
00A52E  2  B1 C3        	LDA	(Bpntrl),Y	; get line # low byte
00A530  2  85 87        	STA	Clinel		; save current line low byte
00A532  2  C8           	INY			; increment index
00A533  2  B1 C3        	LDA	(Bpntrl),Y	; get line # high byte
00A535  2  85 88        	STA	Clineh		; save current line high byte
00A537  2  98           	TYA			; A now = 4
00A538  2  65 C3        	ADC	Bpntrl		; add BASIC execute pointer low byte
00A53A  2  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
00A53C  2  90 02        	BCC	LAB_15F6	; branch if no overflow
00A53E  2               
00A53E  2  E6 C4        	INC	Bpntrh		; else increment BASIC execute pointer high byte
00A540  2               LAB_15F6
00A540  2  20 BC 00     	JSR	LAB_IGBY	; increment and scan memory
00A543  2               
00A543  2               LAB_15F9
00A543  2  20 49 A5     	JSR	LAB_15FF	; interpret BASIC code from (Bpntrl)
00A546  2               
00A546  2               LAB_15FC
00A546  2  4C 0B A5     	JMP	LAB_15C2	; loop
00A549  2               
00A549  2               
00A549  2               ; interpret BASIC code from (Bpntrl)
00A549  2               
00A549  2               LAB_15FF
00A549  2  F0 4E        	BEQ	LAB_1628	; exit if zero [EOL]
00A54B  2               
00A54B  2               LAB_1602
00A54B  2               .if TARGET=BBC
00A54B  2               	CMP	#'*'
00A54B  2               	BNE	NOT_OSCLI
00A54B  2               	JMP	LAB_OSCLI
00A54B  2               NOT_OSCLI
00A54B  2               .endif
00A54B  2  0A           	ASL			; *2 bytes per vector and normalise token
00A54C  2  B0 03        	BCS	LAB_1609	; branch if was token
00A54E  2               
00A54E  2  4C 00 A8     	JMP	LAB_LET		; else go do implied LET
00A551  2               
00A551  2               LAB_1609
00A551  2  C9 84        	CMP	#(TK_TAB-$80)*2	; compare normalised token * 2 with TAB
00A553  2  B0 CE        	BCS	LAB_15D9	; branch if A>=TAB (do syntax error then warm start)
00A555  2               				; only tokens before TAB can start a line
00A555  2  A8           	TAY			; copy to index
00A556  2  B9 75 C2     	LDA	LAB_CTBL+1,Y	; get vector high byte
00A559  2  48           	PHA			; onto stack
00A55A  2  B9 74 C2     	LDA	LAB_CTBL,Y	; get vector low byte
00A55D  2  48           	PHA			; onto stack
00A55E  2  4C BC 00     	JMP	LAB_IGBY	; jump to increment and scan memory
00A561  2               				; then "return" to vector
00A561  2               
00A561  2               ; Program interupt check. This is called as a subroutine but exits back via a
00A561  2               ; jump if a key press is detected.
00A561  2               
00A561  2               LAB_1629
00A561  2  6C 04 02     	JMP	(VEC_CC)	; ctrl c check vector
00A564  2               
00A564  2               ; if there was a key press it gets back here ..
00A564  2               
00A564  2               LAB_1636
00A564  2  C9 03        	CMP	#BREAK		; compare with CTRL-C/BREAK/ESCAPE/etc
00A566  2               
00A566  2               ; perform STOP
00A566  2               
00A566  2               LAB_STOP
00A566  2  B0 01        	BCS	LAB_163B	; branch if token follows STOP
00A568  2               				; else just END
00A568  2               ; END
00A568  2               
00A568  2               LAB_END
00A568  2  18           	CLC			; clear the carry, indicate a normal program end
00A569  2               LAB_163B
00A569  2  D0 61        	BNE	LAB_167A	; if wasn't CTRL-C or there is a following byte return
00A56B  2               
00A56B  2  A5 C4        	LDA	Bpntrh		; get the BASIC execute pointer high byte
00A56D  2               ;*** fix p2: skip no longer necessary as the continue pointer is saved anyway
00A56D  2               ;	EOR	#>Ibuffs	; compare with buffer address high byte (Cb unchanged)
00A56D  2               ;	BEQ	LAB_164F	; branch if the BASIC pointer is in the input buffer
00A56D  2               ;				; (can't continue in immediate mode)
00A56D  2               ;				; else ..
00A56D  2               ;	EOR	#>Ibuffs	; correct the bits
00A56D  2  A4 C3        	LDY	Bpntrl		; get BASIC execute pointer low byte
00A56F  2  84 8B        	STY	Cpntrl		; save continue pointer low byte
00A571  2  85 8C        	STA	Cpntrh		; save continue pointer high byte
00A573  2               LAB_1647
00A573  2  A5 87        	LDA	Clinel		; get current line low byte
00A575  2  A4 88        	LDY	Clineh		; get current line high byte
00A577  2  85 89        	STA	Blinel		; save break line low byte
00A579  2  84 8A        	STY	Blineh		; save break line high byte
00A57B  2               LAB_164F
00A57B  2  68           	PLA			; pull return address low
00A57C  2  68           	PLA			; pull return address high
00A57D  2               LAB_1651
00A57D  2  90 07        	BCC	LAB_165E	; if was program end just do warm start
00A57F  2               
00A57F  2               				; else ..
00A57F  2               LAB_BREAK
00A57F  2  A9 84        	LDA	#<LAB_BMSG	; point to "Break" low byte
00A581  2  A0 C9        	LDY	#>LAB_BMSG	; point to "Break" high byte
00A583  2  4C 5F A1     	JMP	LAB_1269	; print "Break" and do warm start
00A586  2               
00A586  2               LAB_165E
00A586  2  4C 6A A1     	JMP	LAB_1274	; go to warm start
00A589  2               
00A589  2               ; perform RESTORE
00A589  2               
00A589  2               LAB_RESTORE
00A589  2  D0 0F        	BNE	LAB_RESTOREn	; branch if next character not null (RESTORE n)
00A58B  2               
00A58B  2               LAB_161A
00A58B  2  38           	SEC			; set carry for subtract
00A58C  2  A5 79        	LDA	Smeml		; get start of mem low byte
00A58E  2  E9 01        	SBC	#$01		; -1
00A590  2  A4 7A        	LDY	Smemh		; get start of mem high byte
00A592  2  B0 01        	BCS	LAB_1624	; branch if no underflow
00A594  2               
00A594  2               LAB_uflow
00A594  2  88           	DEY			; else decrement high byte
00A595  2               LAB_1624
00A595  2  85 8F        	STA	Dptrl		; save DATA pointer low byte
00A597  2  84 90        	STY	Dptrh		; save DATA pointer high byte
00A599  2               LAB_1628
00A599  2  60           	RTS
00A59A  2               
00A59A  2               				; is RESTORE n
00A59A  2               LAB_RESTOREn
00A59A  2  20 A1 A7     	JSR	LAB_GFPN	; get fixed-point number into temp integer
00A59D  2  20 E9 A6     	JSR	LAB_SNBL	; scan for next BASIC line
00A5A0  2  A5 88        	LDA	Clineh		; get current line high byte
00A5A2  2  C5 12        	CMP	Itemph		; compare with temporary integer high byte
00A5A4  2  B0 0B        	BCS	LAB_reset_search; branch if >= (start search from beginning)
00A5A6  2               
00A5A6  2  98           	TYA			; else copy line index to A
00A5A7  2  38           	SEC			; set carry (+1)
00A5A8  2  65 C3        	ADC	Bpntrl		; add BASIC execute pointer low byte
00A5AA  2  A6 C4        	LDX	Bpntrh		; get BASIC execute pointer high byte
00A5AC  2  90 07        	BCC	LAB_go_search	; branch if no overflow to high byte
00A5AE  2               
00A5AE  2  E8           	INX			; increment high byte
00A5AF  2  B0 04        	BCS	LAB_go_search	; branch always (can never be carry clear)
00A5B1  2               
00A5B1  2               ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
00A5B1  2               
00A5B1  2               LAB_reset_search
00A5B1  2  A5 79        	LDA	Smeml		; get start of mem low byte
00A5B3  2  A6 7A        	LDX	Smemh		; get start of mem high byte
00A5B5  2               
00A5B5  2               ; search for line # in temp (Itempl/Itemph) from (AX)
00A5B5  2               
00A5B5  2               LAB_go_search
00A5B5  2               
00A5B5  2  20 75 A3     	JSR	LAB_SHLN	; search Basic for temp integer line number from AX
00A5B8  2  B0 03        	BCS	LAB_line_found	; if carry set go set pointer
00A5BA  2               
00A5BA  2  4C BB A6     	JMP	LAB_16F7	; else go do "Undefined statement" error
00A5BD  2               
00A5BD  2               LAB_line_found
00A5BD  2               				; carry already set for subtract
00A5BD  2  A5 AA        	LDA	Baslnl		; get pointer low byte
00A5BF  2  E9 01        	SBC	#$01		; -1
00A5C1  2  A4 AB        	LDY	Baslnh		; get pointer high byte
00A5C3  2  B0 D0        	BCS	LAB_1624	; branch if no underflow (save DATA pointer and return)
00A5C5  2               
00A5C5  2  90 CD        	BCC	LAB_uflow	; else decrement high byte then save DATA pointer and
00A5C7  2               				; return (branch always)
00A5C7  2               
00A5C7  2               ; perform NULL
00A5C7  2               
00A5C7  2               LAB_NULL
00A5C7  2  20 E5 B4     	JSR	LAB_GTBY	; get byte parameter
00A5CA  2  86 0D        	STX	Nullct		; save new NULL count
00A5CC  2               LAB_167A
00A5CC  2  60           	RTS
00A5CD  2               
00A5CD  2               ; perform CONT
00A5CD  2               
00A5CD  2               LAB_CONT
00A5CD  2  D0 FD        	BNE	LAB_167A	; if following byte exit to do syntax error
00A5CF  2               
00A5CF  2  A4 8C        	LDY	Cpntrh		; get continue pointer high byte
00A5D1  2  C0 00              CPY   #>Ibuffs          ; *** fix p2: test direct mode
00A5D3  2  D0 05        	BNE	LAB_166C	; go to continue if we can
00A5D5  2               
00A5D5  2  A2 1E        	LDX	#$1E		; error code $1E ("Can't continue" error)
00A5D7  2  4C 4C A1     	JMP	LAB_XERR	; do error #X, then warm start
00A5DA  2               
00A5DA  2               				; we can continue so ..
00A5DA  2               LAB_166C
00A5DA  2               .ifdef IRQVEC
00A5DA  2  A9 93        	LDA	#TK_ON		; set token for ON
00A5DC  2  20 7C BF     	JSR	LAB_IRQ		; set IRQ flags
00A5DF  2  A9 93        	LDA	#TK_ON		; set token for ON
00A5E1  2  20 7F BF     	JSR	LAB_NMI		; set NMI flags
00A5E4  2               .endif
00A5E4  2               
00A5E4  2  84 C4        	STY	Bpntrh		; save BASIC execute pointer high byte
00A5E6  2  A5 8B        	LDA	Cpntrl		; get continue pointer low byte
00A5E8  2  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
00A5EA  2  A5 89        	LDA	Blinel		; get break line low byte
00A5EC  2  A4 8A        	LDY	Blineh		; get break line high byte
00A5EE  2  85 87        	STA	Clinel		; set current line low byte
00A5F0  2  84 88        	STY	Clineh		; set current line high byte
00A5F2  2  60           	RTS
00A5F3  2               
00A5F3  2               ; perform RUN
00A5F3  2               
00A5F3  2               LAB_RUN
00A5F3  2  D0 03        	BNE	LAB_1696	; branch if RUN n
00A5F5  2  4C B2 A3     	JMP	LAB_1477	; reset execution to start, clear variables, flush stack and
00A5F8  2               				; return
00A5F8  2               
00A5F8  2               ; does RUN n
00A5F8  2               
00A5F8  2               LAB_1696
00A5F8  2  20 BF A3     	JSR	LAB_147A	; go do "CLEAR"
00A5FB  2  F0 2E        	BEQ	LAB_16B0	; get n and do GOTO n (branch always as CLEAR sets Z=1)
00A5FD  2               
00A5FD  2               ; perform DO
00A5FD  2               
00A5FD  2               LAB_DO
00A5FD  2  A9 05        	LDA	#$05		; need 5 bytes for DO
00A5FF  2  20 10 A1     	JSR	LAB_1212	; check room on stack for A bytes
00A602  2  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
00A604  2  48           	PHA			; push on stack
00A605  2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
00A607  2  48           	PHA			; push on stack
00A608  2  A5 88        	LDA	Clineh		; get current line high byte
00A60A  2  48           	PHA			; push on stack
00A60B  2  A5 87        	LDA	Clinel		; get current line low byte
00A60D  2  48           	PHA			; push on stack
00A60E  2  A9 9D        	LDA	#TK_DO		; token for DO
00A610  2  48           	PHA			; push on stack
00A611  2  20 C2 00     	JSR	LAB_GBYT	; scan memory
00A614  2  4C 0B A5     	JMP	LAB_15C2	; go do interpreter inner loop
00A617  2               
00A617  2               ; perform GOSUB
00A617  2               
00A617  2               LAB_GOSUB
00A617  2  A9 05        	LDA	#$05		; need 5 bytes for GOSUB
00A619  2  20 10 A1     	JSR	LAB_1212	; check room on stack for A bytes
00A61C  2  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
00A61E  2  48           	PHA			; push on stack
00A61F  2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
00A621  2  48           	PHA			; push on stack
00A622  2  A5 88        	LDA	Clineh		; get current line high byte
00A624  2  48           	PHA			; push on stack
00A625  2  A5 87        	LDA	Clinel		; get current line low byte
00A627  2  48           	PHA			; push on stack
00A628  2  A9 8D        	LDA	#TK_GOSUB	; token for GOSUB
00A62A  2  48           	PHA			; push on stack
00A62B  2               LAB_16B0
00A62B  2  20 C2 00     	JSR	LAB_GBYT	; scan memory
00A62E  2  20 34 A6     	JSR	LAB_GOTO	; perform GOTO n
00A631  2  4C 0B A5     	JMP	LAB_15C2	; go do interpreter inner loop
00A634  2               				; (can't RTS, we used the stack!)
00A634  2               
00A634  2               ; perform GOTO
00A634  2               
00A634  2               LAB_GOTO
00A634  2  20 A1 A7     	JSR	LAB_GFPN	; get fixed-point number into temp integer
00A637  2  20 E9 A6     	JSR	LAB_SNBL	; scan for next BASIC line
00A63A  2  A5 88        	LDA	Clineh		; get current line high byte
00A63C  2  C5 12        	CMP	Itemph		; compare with temporary integer high byte
00A63E  2  B0 0B        	BCS	LAB_16D0	; branch if >= (start search from beginning)
00A640  2               
00A640  2  98           	TYA			; else copy line index to A
00A641  2  38           	SEC			; set carry (+1)
00A642  2  65 C3        	ADC	Bpntrl		; add BASIC execute pointer low byte
00A644  2  A6 C4        	LDX	Bpntrh		; get BASIC execute pointer high byte
00A646  2  90 07        	BCC	LAB_16D4	; branch if no overflow to high byte
00A648  2               
00A648  2  E8           	INX			; increment high byte
00A649  2  B0 04        	BCS	LAB_16D4	; branch always (can never be carry)
00A64B  2               
00A64B  2               ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
00A64B  2               
00A64B  2               LAB_16D0
00A64B  2  A5 79        	LDA	Smeml		; get start of mem low byte
00A64D  2  A6 7A        	LDX	Smemh		; get start of mem high byte
00A64F  2               
00A64F  2               ; search for line # in temp (Itempl/Itemph) from (AX)
00A64F  2               
00A64F  2               LAB_16D4
00A64F  2  20 75 A3     	JSR	LAB_SHLN	; search Basic for temp integer line number from AX
00A652  2  90 67        	BCC	LAB_16F7	; if carry clear go do "Undefined statement" error
00A654  2               				; (unspecified statement)
00A654  2               
00A654  2               				; carry already set for subtract
00A654  2  A5 AA        	LDA	Baslnl		; get pointer low byte
00A656  2  E9 01        	SBC	#$01		; -1
00A658  2  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
00A65A  2  A5 AB        	LDA	Baslnh		; get pointer high byte
00A65C  2  E9 00        	SBC	#$00		; subtract carry
00A65E  2  85 C4        	STA	Bpntrh		; save BASIC execute pointer high byte
00A660  2               LAB_16E5
00A660  2  60           	RTS
00A661  2               
00A661  2               LAB_DONOK
00A661  2  A2 22        	LDX	#$22		; error code $22 ("LOOP without DO" error)
00A663  2  4C 4C A1     	JMP	LAB_XERR	; do error #X, then warm start
00A666  2               
00A666  2               ; perform LOOP
00A666  2               
00A666  2               LAB_LOOP
00A666  2  A8           	TAY			; save following token
00A667  2  BA           	TSX			; copy stack pointer
00A668  2  BD 03 01     	LDA	LAB_STAK+3,X	; get token byte from stack
00A66B  2  C9 9D        	CMP	#TK_DO		; compare with DO token
00A66D  2  D0 F2        	BNE	LAB_DONOK	; branch if no matching DO
00A66F  2               
00A66F  2  E8           	INX			; dump calling routine return address
00A670  2  E8           	INX			; dump calling routine return address
00A671  2  9A           	TXS			; correct stack
00A672  2  98           	TYA			; get saved following token back
00A673  2  F0 20        	BEQ	LoopAlways	; if no following token loop forever
00A675  2               				; (stack pointer in X)
00A675  2               
00A675  2  C9 3A        	CMP	#':'		; could be ':'
00A677  2  F0 1C        	BEQ	LoopAlways	; if :... loop forever
00A679  2               
00A679  2  E9 CA        	SBC	#TK_UNTIL	; subtract token for UNTIL, we know carry is set here
00A67B  2  AA           	TAX			; copy to X (if it was UNTIL then Y will be correct)
00A67C  2  F0 04        	BEQ	DoRest		; branch if was UNTIL
00A67E  2               
00A67E  2  CA           	DEX			; decrement result
00A67F  2  D0 62        	BNE	LAB_16FC	; if not WHILE go do syntax error and warm start
00A681  2               				; only if the token was WHILE will this fail
00A681  2               
00A681  2  CA           	DEX			; set invert result byte
00A682  2               DoRest
00A682  2  86 98        	STX	Frnxth		; save invert result byte
00A684  2  20 BC 00     	JSR	LAB_IGBY	; increment and scan memory
00A687  2  20 28 AB     	JSR	LAB_EVEX	; evaluate expression
00A68A  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00A68C  2  F0 02        	BEQ	DoCmp		; if =0 go do straight compare
00A68E  2               
00A68E  2  A9 FF        	LDA	#$FF		; else set all bits
00A690  2               DoCmp
00A690  2  BA           	TSX			; copy stack pointer
00A691  2  45 98        	EOR	Frnxth		; EOR with invert byte
00A693  2  D0 1A        	BNE	LoopDone	; if <> 0 clear stack and back to interpreter loop
00A695  2               
00A695  2               				; loop condition wasn't met so do it again
00A695  2               LoopAlways
00A695  2  BD 02 01     	LDA	LAB_STAK+2,X	; get current line low byte
00A698  2  85 87        	STA	Clinel		; save current line low byte
00A69A  2  BD 03 01     	LDA	LAB_STAK+3,X	; get current line high byte
00A69D  2  85 88        	STA	Clineh		; save current line high byte
00A69F  2  BD 04 01     	LDA	LAB_STAK+4,X	; get BASIC execute pointer low byte
00A6A2  2  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
00A6A4  2  BD 05 01     	LDA	LAB_STAK+5,X	; get BASIC execute pointer high byte
00A6A7  2  85 C4        	STA	Bpntrh		; save BASIC execute pointer high byte
00A6A9  2  20 C2 00     	JSR	LAB_GBYT	; scan memory
00A6AC  2  4C 0B A5     	JMP	LAB_15C2	; go do interpreter inner loop
00A6AF  2               
00A6AF  2               				; clear stack and back to interpreter loop
00A6AF  2               LoopDone
00A6AF  2  E8           	INX			; dump DO token
00A6B0  2  E8           	INX			; dump current line low byte
00A6B1  2  E8           	INX			; dump current line high byte
00A6B2  2  E8           	INX			; dump BASIC execute pointer low byte
00A6B3  2  E8           	INX			; dump BASIC execute pointer high byte
00A6B4  2  9A           	TXS			; correct stack
00A6B5  2  4C D5 A6     	JMP	LAB_DATA	; go perform DATA (find : or [EOL])
00A6B8  2               
00A6B8  2               ; do the return without gosub error
00A6B8  2               
00A6B8  2               LAB_16F4
00A6B8  2  A2 04        	LDX	#$04		; error code $04 ("RETURN without GOSUB" error)
00A6BA  2  2C           	.byte	$2C		; makes next line BIT LAB_0EA2
00A6BB  2               
00A6BB  2               LAB_16F7			; do undefined statement error
00A6BB  2  A2 0E        	LDX	#$0E		; error code $0E ("Undefined statement" error)
00A6BD  2  4C 4C A1     	JMP	LAB_XERR	; do error #X, then warm start
00A6C0  2               
00A6C0  2               ; perform RETURN
00A6C0  2               
00A6C0  2               LAB_RETURN
00A6C0  2  D0 9E        	BNE	LAB_16E5	; exit if following token (to allow syntax error)
00A6C2  2               
00A6C2  2               LAB_16E8
00A6C2  2  68           	PLA			; dump calling routine return address
00A6C3  2  68           	PLA			; dump calling routine return address
00A6C4  2  68           	PLA			; pull token
00A6C5  2  C9 8D        	CMP	#TK_GOSUB	; compare with GOSUB token
00A6C7  2  D0 EF        	BNE	LAB_16F4	; branch if no matching GOSUB
00A6C9  2               
00A6C9  2               LAB_16FF
00A6C9  2  68           	PLA			; pull current line low byte
00A6CA  2  85 87        	STA	Clinel		; save current line low byte
00A6CC  2  68           	PLA			; pull current line high byte
00A6CD  2  85 88        	STA	Clineh		; save current line high byte
00A6CF  2  68           	PLA			; pull BASIC execute pointer low byte
00A6D0  2  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
00A6D2  2  68           	PLA			; pull BASIC execute pointer high byte
00A6D3  2  85 C4        	STA	Bpntrh		; save BASIC execute pointer high byte
00A6D5  2               
00A6D5  2               				; now do the DATA statement as we could be returning into
00A6D5  2               				; the middle of an ON <var> GOSUB n,m,p,q line
00A6D5  2               				; (the return address used by the DATA statement is the one
00A6D5  2               				; pushed before the GOSUB was executed!)
00A6D5  2               
00A6D5  2               ; perform DATA
00A6D5  2               
00A6D5  2               LAB_DATA
00A6D5  2  20 E6 A6     	JSR	LAB_SNBS	; scan for next BASIC statement ([:] or [EOL])
00A6D8  2               
00A6D8  2               				; set BASIC execute pointer
00A6D8  2               LAB_170F
00A6D8  2  98           	TYA			; copy index to A
00A6D9  2  18           	CLC			; clear carry for add
00A6DA  2  65 C3        	ADC	Bpntrl		; add BASIC execute pointer low byte
00A6DC  2  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
00A6DE  2  90 02        	BCC	LAB_1719	; skip next if no carry
00A6E0  2               
00A6E0  2  E6 C4        	INC	Bpntrh		; else increment BASIC execute pointer high byte
00A6E2  2               LAB_1719
00A6E2  2  60           	RTS
00A6E3  2               
00A6E3  2               LAB_16FC
00A6E3  2  4C 4A AC     	JMP	LAB_SNER	; do syntax error then warm start
00A6E6  2               
00A6E6  2               ; scan for next BASIC statement ([:] or [EOL])
00A6E6  2               ; returns Y as index to [:] or [EOL]
00A6E6  2               
00A6E6  2               LAB_SNBS
00A6E6  2  A2 3A        	LDX	#':'		; set look for character = ":"
00A6E8  2  2C           	.byte	$2C		; makes next line BIT $00A2
00A6E9  2               
00A6E9  2               ; scan for next BASIC line
00A6E9  2               ; returns Y as index to [EOL]
00A6E9  2               
00A6E9  2               LAB_SNBL
00A6E9  2  A2 00        	LDX	#$00		; set alt search character = [EOL]
00A6EB  2  A0 00        	LDY	#$00		; set search character = [EOL]
00A6ED  2  84 5C        	STY	Asrch		; store search character
00A6EF  2               LAB_1725
00A6EF  2  8A           	TXA			; get alt search character
00A6F0  2  45 5C        	EOR	Asrch		; toggle search character, effectively swap with $00
00A6F2  2  85 5C        	STA	Asrch		; save swapped search character
00A6F4  2               LAB_172D
00A6F4  2  B1 C3        	LDA	(Bpntrl),Y	; get next byte
00A6F6  2  F0 EA        	BEQ	LAB_1719	; exit if null [EOL]
00A6F8  2               
00A6F8  2  C5 5C        	CMP	Asrch		; compare with search character
00A6FA  2  F0 E6        	BEQ	LAB_1719	; exit if found
00A6FC  2               
00A6FC  2  C8           	INY			; increment index
00A6FD  2  C9 22        	CMP	#$22		; compare current character with open quote
00A6FF  2  D0 F3        	BNE	LAB_172D	; if not open quote go get next character
00A701  2               
00A701  2  F0 EC        	BEQ	LAB_1725	; if found go swap search character for alt search character
00A703  2               
00A703  2               ; perform IF
00A703  2               
00A703  2               LAB_IF
00A703  2  20 28 AB     	JSR	LAB_EVEX	; evaluate the expression
00A706  2  20 C2 00     	JSR	LAB_GBYT	; scan memory
00A709  2  C9 C7        	CMP	#TK_THEN	; compare with THEN token
00A70B  2  F0 11        	BEQ	LAB_174B	; if it was THEN go do IF
00A70D  2               
00A70D  2               				; wasn't IF .. THEN so must be IF .. GOTO
00A70D  2  C9 89        	CMP	#TK_GOTO	; compare with GOTO token
00A70F  2  D0 D2        	BNE	LAB_16FC	; if it wasn't GOTO go do syntax error
00A711  2               
00A711  2  A6 C3        	LDX	Bpntrl		; save the basic pointer low byte
00A713  2  A4 C4        	LDY	Bpntrh		; save the basic pointer high byte
00A715  2  20 BC 00     	JSR	LAB_IGBY	; increment and scan memory
00A718  2  B0 C9        	BCS	LAB_16FC	; if not numeric go do syntax error
00A71A  2               
00A71A  2  86 C3        	STX	Bpntrl		; restore the basic pointer low byte
00A71C  2  84 C4        	STY	Bpntrh		; restore the basic pointer high byte
00A71E  2               LAB_174B
00A71E  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00A720  2  F0 1E        	BEQ	LAB_174E	; if the result was zero go look for an ELSE
00A722  2               
00A722  2  20 BC 00     	JSR	LAB_IGBY	; else increment and scan memory
00A725  2  B0 03        	BCS	LAB_174D	; if not numeric go do var or keyword
00A727  2               
00A727  2               LAB_174C
00A727  2  4C 34 A6     	JMP	LAB_GOTO	; else was numeric so do GOTO n
00A72A  2               
00A72A  2               				; is var or keyword
00A72A  2               LAB_174D
00A72A  2               ; *** patch       allow NEXT, LOOP & RETURN to find FOR, DO or GOSUB structure on stack
00A72A  2               ; *** replace
00A72A  2               ;      CMP   #TK_RETURN        ; compare the byte with the token for RETURN
00A72A  2               ;      BNE   LAB_174G          ; if it wasn't RETURN go interpret BASIC code from (Bpntrl)
00A72A  2               ;                              ; and return to this code to process any following code
00A72A  2               ;
00A72A  2               ;      JMP   LAB_1602          ; else it was RETURN so interpret BASIC code from (Bpntrl)
00A72A  2               ;                              ; but don't return here
00A72A  2               ;
00A72A  2               ;LAB_174G
00A72A  2               ;      JSR   LAB_15FF          ; interpret BASIC code from (Bpntrl)
00A72A  2               ;
00A72A  2               ;; the IF was executed and there may be a following ELSE so the code needs to return
00A72A  2               ;; here to check and ignore the ELSE if present
00A72A  2               ;
00A72A  2               ;      LDY   #$00              ; clear the index
00A72A  2               ;      LDA   (Bpntrl),Y        ; get the next BASIC byte
00A72A  2               ;      CMP   #TK_ELSE          ; compare it with the token for ELSE
00A72A  2               ;      BEQ   LAB_DATA          ; if ELSE ignore the following statement
00A72A  2               ;
00A72A  2               ;; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
00A72A  2               ;; following ELSE will, correctly, cause a syntax error
00A72A  2               ;
00A72A  2               ;      RTS                     ; else return to the interpreter inner loop
00A72A  2               ;
00A72A  2               ; *** with
00A72A  2  68           	PLA			; discard interpreter loop return address
00A72B  2  68           	PLA			; so data structures are at the correct stack offset
00A72C  2  20 C2 00     	JSR	LAB_GBYT	; restore token or variable
00A72F  2  20 49 A5     	JSR	LAB_15FF	; interpret BASIC code from (Bpntrl)
00A732  2               
00A732  2               ; the IF was executed and there may be a following ELSE so the code needs to return
00A732  2               ; here to check and ignore the ELSE if present
00A732  2               
00A732  2  A0 00        	LDY	#$00		; clear the index
00A734  2  B1 C3        	LDA	(Bpntrl),Y	; get the next BASIC byte
00A736  2  C9 C3        	CMP	#TK_ELSE	; compare it with the token for ELSE
00A738  2  D0 03        	BNE	LAB_no_ELSE	; no - continue on this line
00A73A  2  20 D5 A6     	JSR	LAB_DATA	; yes - skip the rest of the line
00A73D  2               
00A73D  2               ; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
00A73D  2               ; following ELSE will, correctly, cause a syntax error
00A73D  2               
00A73D  2               LAB_no_ELSE
00A73D  2  4C 0B A5     	JMP	LAB_15C2	; return to the interpreter inner loop
00A740  2               ; *** end patch  allow NEXT, LOOP & RETURN to find FOR, DO or GOSUB structure on stack
00A740  2               
00A740  2               ; perform ELSE after IF
00A740  2               
00A740  2               LAB_174E
00A740  2  A0 00        	LDY	#$00		; clear the BASIC byte index
00A742  2  A2 01        	LDX	#$01		; clear the nesting depth
00A744  2               LAB_1750
00A744  2  C8           	INY			; increment the BASIC byte index
00A745  2  B1 C3        	LDA	(Bpntrl),Y	; get the next BASIC byte
00A747  2  F0 0F        	BEQ	LAB_1753	; if EOL go add the pointer and return
00A749  2               
00A749  2  C9 8B        	CMP	#TK_IF		; compare the byte with the token for IF
00A74B  2  D0 03        	BNE	LAB_1752	; if not IF token skip the depth increment
00A74D  2               
00A74D  2  E8           	INX			; else increment the nesting depth ..
00A74E  2  D0 F4        	BNE	LAB_1750	; .. and continue looking
00A750  2               
00A750  2               LAB_1752
00A750  2  C9 C3        	CMP	#TK_ELSE	; compare the byte with the token for ELSE
00A752  2  D0 F0        	BNE	LAB_1750	; if not ELSE token continue looking
00A754  2               
00A754  2  CA           	DEX			; was ELSE so decrement the nesting depth
00A755  2  D0 ED        	BNE	LAB_1750	; loop if still nested
00A757  2               
00A757  2  C8           	INY			; increment the BASIC byte index past the ELSE
00A758  2               
00A758  2               ; found the matching ELSE, now do <{n|statement}>
00A758  2               
00A758  2               LAB_1753
00A758  2  98           	TYA			; else copy line index to A
00A759  2  18           	CLC			; clear carry for add
00A75A  2  65 C3        	ADC	Bpntrl		; add the BASIC execute pointer low byte
00A75C  2  85 C3        	STA	Bpntrl		; save the BASIC execute pointer low byte
00A75E  2  90 02        	BCC	LAB_1754	; branch if no overflow to high byte
00A760  2               
00A760  2  E6 C4        	INC	Bpntrh		; else increment the BASIC execute pointer high byte
00A762  2               LAB_1754
00A762  2  20 C2 00     	JSR	LAB_GBYT	; scan memory
00A765  2  90 C0        	BCC	LAB_174C	; if numeric do GOTO n
00A767  2               				; the code will return to the interpreter loop at the
00A767  2               				; tail end of the GOTO <n>
00A767  2               
00A767  2  4C 49 A5     	JMP	LAB_15FF	; interpret BASIC code from (Bpntrl)
00A76A  2               				; the code will return to the interpreter loop at the
00A76A  2               				; tail end of the <statement>
00A76A  2               
00A76A  2               ; BBC *command
00A76A  2               .if TARGET=BBC
00A76A  2               LAB_OSCLI
00A76A  2               	LDX	Bpntrl		; get XY=>basic line
00A76A  2               	LDY	Bpntrh
00A76A  2               	INX
00A76A  2               	BNE	LAB_OSCLI2
00A76A  2               	INY
00A76A  2               LAB_OSCLI2
00A76A  2               	LDA	#$FF		; A=maximum string length
00A76A  2               	JSR	BBCSTRG		; Convert <00>-string to <cr>-string
00A76A  2               	JSR	$FFF7		; Call MOS command interpreter
00A76A  2               .endif
00A76A  2               
00A76A  2               ; perform REM, skip (rest of) line
00A76A  2               LAB_REM
00A76A  2  20 E9 A6     	JSR	LAB_SNBL	; scan for next BASIC line
00A76D  2  4C D8 A6     	JMP	LAB_170F	; go set BASIC execute pointer and return, branch always
00A770  2               
00A770  2               LAB_16FD
00A770  2  4C 4A AC     	JMP	LAB_SNER	; do syntax error then warm start
00A773  2               
00A773  2               ; perform ON
00A773  2               
00A773  2               LAB_ON
00A773  2               .ifdef IRQVEC
00A773  2  C9 A9        	CMP	#TK_IRQ		; was it IRQ token ?
00A775  2  D0 03        	BNE	LAB_NOIN	; if not go check NMI
00A777  2  4C A0 BF     	JMP	LAB_SIRQ	; else go to set up IRQ
00A77A  2               .endif
00A77A  2               
00A77A  2               LAB_NOIN
00A77A  2               .ifdef IRQVEC
00A77A  2  C9 AA        	CMP	#TK_NMI		; was it NMI token ?
00A77C  2  D0 03        	BNE	LAB_NONM	; if not go do normal ON command
00A77E  2  4C A4 BF     	JMP	LAB_SNMI	; else go to set up NMI
00A781  2               .endif
00A781  2               
00A781  2               LAB_NONM
00A781  2  20 E5 B4     	JSR	LAB_GTBY	; get byte parameter
00A784  2  48           	PHA			; push GOTO/GOSUB token
00A785  2  C9 8D        	CMP	#TK_GOSUB	; compare with GOSUB token
00A787  2  F0 04        	BEQ	LAB_176B	; branch if GOSUB
00A789  2               
00A789  2  C9 89        	CMP	#TK_GOTO	; compare with GOTO token
00A78B  2               LAB_1767
00A78B  2  D0 E3        	BNE	LAB_16FD	; if not GOTO do syntax error then warm start
00A78D  2               
00A78D  2               
00A78D  2               ; next character was GOTO or GOSUB
00A78D  2               
00A78D  2               LAB_176B
00A78D  2  C6 AF        	DEC	FAC1_3		; decrement index (byte value)
00A78F  2  D0 04        	BNE	LAB_1773	; branch if not zero
00A791  2               
00A791  2  68           	PLA			; pull GOTO/GOSUB token
00A792  2  4C 4B A5     	JMP	LAB_1602	; go execute it
00A795  2               
00A795  2               LAB_1773
00A795  2  20 BC 00     	JSR	LAB_IGBY	; increment and scan memory
00A798  2  20 A1 A7     	JSR	LAB_GFPN	; get fixed-point number into temp integer (skip this n)
00A79B  2               				; (we could LDX #',' and JSR LAB_SNBL+2, then we
00A79B  2               				; just BNE LAB_176B for the loop. should be quicker ..
00A79B  2               				; no we can't, what if we meet a colon or [EOL]?)
00A79B  2  C9 2C        	CMP	#$2C		; compare next character with ","
00A79D  2  F0 EE        	BEQ	LAB_176B	; loop if ","
00A79F  2               
00A79F  2               LAB_177E
00A79F  2  68           	PLA			; else pull keyword token (run out of options)
00A7A0  2               				; also dump +/-1 pointer low byte and exit
00A7A0  2               LAB_177F
00A7A0  2  60           	RTS
00A7A1  2               
00A7A1  2               ; takes n * 106 + 11 cycles where n is the number of digits
00A7A1  2               
00A7A1  2               ; get fixed-point number into temp integer
00A7A1  2               ; enter with A=first digit, carry clear
00A7A1  2               
00A7A1  2               LAB_GFPN
00A7A1  2  A2 00        	LDX	#$00		; clear reg
00A7A3  2  86 11        	STX	Itempl		; clear temporary integer low byte
00A7A5  2               LAB_1785
00A7A5  2  86 12        	STX	Itemph		; save temporary integer high byte
00A7A7  2  B0 F7        	BCS	LAB_177F	; return if carry set, end of scan, character was
00A7A9  2               				; not 0-9
00A7A9  2               
00A7A9  2  E0 19        	CPX	#$19		; compare high byte with $19
00A7AB  2  A8           	TAY			; ensure Zb = 0 if the branch is taken
00A7AC  2  B0 DD        	BCS	LAB_1767	; branch if >=, makes max line = 63999 because next
00A7AE  2               				; bit does *$0A, = 64000, compare at target will fail
00A7AE  2               				; and do syntax error
00A7AE  2               
00A7AE  2  E9 2F        	SBC	#'0'-1		; subtract "0", $2F + carry, from byte
00A7B0  2  A8           	TAY			; copy binary digit
00A7B1  2  A5 11        	LDA	Itempl		; get temporary integer low byte
00A7B3  2  0A           	ASL			; *2 low byte
00A7B4  2  26 12        	ROL	Itemph		; *2 high byte
00A7B6  2  0A           	ASL			; *2 low byte
00A7B7  2  26 12        	ROL	Itemph		; *2 high byte, *4
00A7B9  2  65 11        	ADC	Itempl		; + low byte, *5
00A7BB  2  85 11        	STA	Itempl		; save it
00A7BD  2  8A           	TXA			; get high byte copy to A
00A7BE  2  65 12        	ADC	Itemph		; + high byte, *5
00A7C0  2  06 11        	ASL	Itempl		; *2 low byte, *10d
00A7C2  2  2A           	ROL			; *2 high byte, *10d
00A7C3  2  AA           	TAX			; copy high byte back to X
00A7C4  2  98           	TYA			; get binary digit back
00A7C5  2  65 11        	ADC	Itempl		; add number low byte
00A7C7  2  85 11        	STA	Itempl		; save number low byte
00A7C9  2  90 01        	BCC	LAB_17B3	; if no overflow to high byte get next character
00A7CB  2               
00A7CB  2  E8           	INX			; else increment high byte
00A7CC  2               LAB_17B3
00A7CC  2  20 BC 00     	JSR	LAB_IGBY	; increment and fetch from memory
00A7CF  2  4C A5 A7     	JMP	LAB_1785	; loop for next character
00A7D2  2               
00A7D2  2               ; perform DEC
00A7D2  2               
00A7D2  2               LAB_DEC
00A7D2  2  A9 51        	LDA	#<LAB_2AFD	; set -1 pointer low byte
00A7D4  2  2C           	.byte	$2C		; BIT abs to skip the LDA below
00A7D5  2               
00A7D5  2               ; perform INC
00A7D5  2               
00A7D5  2               LAB_INC
00A7D5  2  A9 4D        	LDA	#<LAB_259C	; set 1 pointer low byte
00A7D7  2               LAB_17B5
00A7D7  2  48           	PHA			; save +/-1 pointer low byte
00A7D8  2               LAB_17B7
00A7D8  2  20 00 AE     	JSR	LAB_GVAR	; get var address
00A7DB  2  A6 5F        	LDX	Dtypef		; get data type flag, $FF=string, $00=numeric
00A7DD  2  30 1E        	BMI	IncrErr		; exit if string
00A7DF  2               
00A7DF  2  85 97        	STA	Lvarpl		; save var address low byte
00A7E1  2  84 98        	STY	Lvarph		; save var address high byte
00A7E3  2  20 DF B8     	JSR	LAB_UFAC	; unpack memory (AY) into FAC1
00A7E6  2  68           	PLA			; get +/-1 pointer low byte
00A7E7  2  48           	PHA			; save +/-1 pointer low byte
00A7E8  2  A0 C2        	LDY	#>LAB_259C	; set +/-1 pointer high byte (both the same)
00A7EA  2  20 20 B6     	JSR	LAB_246C	; add (AY) to FAC1
00A7ED  2  20 05 B9     	JSR	LAB_PFAC	; pack FAC1 into variable (Lvarpl)
00A7F0  2               
00A7F0  2  20 C2 00     	JSR	LAB_GBYT	; scan memory
00A7F3  2  C9 2C        	CMP	#','		; compare with ","
00A7F5  2  D0 A8        	BNE	LAB_177E	; exit if not "," (either end or error)
00A7F7  2               
00A7F7  2               				; was "," so another INCR variable to do
00A7F7  2  20 BC 00     	JSR	LAB_IGBY	; increment and scan memory
00A7FA  2  4C D8 A7     	JMP	LAB_17B7	; go do next var
00A7FD  2               
00A7FD  2               IncrErr
00A7FD  2  4C 23 AB     	JMP	LAB_1ABC	; do "Type mismatch" error then warm start
00A800  2               
00A800  2               ; perform LET
00A800  2               
00A800  2               LAB_LET
00A800  2  20 00 AE     	JSR	LAB_GVAR	; get var address
00A803  2  85 97        	STA	Lvarpl		; save var address low byte
00A805  2  84 98        	STY	Lvarph		; save var address high byte
00A807  2  A9 D8        	LDA	#TK_EQUAL	; get = token
00A809  2  20 39 AC     	JSR	LAB_SCCA	; scan for CHR$(A), else do syntax error then warm start
00A80C  2  A5 5F        	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
00A80E  2  48           	PHA			; push data type flag
00A80F  2  20 28 AB     	JSR	LAB_EVEX	; evaluate expression
00A812  2  68           	PLA			; pop data type flag
00A813  2  2A           	ROL			; set carry if type = string
00A814  2               ; *** begin patch  result of a string compare stores string pointer to variable
00A814  2               ;                  but should store FAC1 (true/false value)
00A814  2               ; *** replace
00A814  2               ;	JSR	LAB_CKTM	; type match check, set C for string
00A814  2               ;	BNE	LAB_17D5	; branch if string
00A814  2               ; *** with
00A814  2  20 1A AB     	JSR	LAB_CKTM	; type match check, keep C (expected type)
00A817  2  B0 03        	BCS	LAB_17D5	; branch if string
00A819  2               ; *** end patch
00A819  2               
00A819  2  4C 05 B9     	JMP	LAB_PFAC	; pack FAC1 into variable (Lvarpl) and return
00A81C  2               
00A81C  2               ; string LET
00A81C  2               
00A81C  2               LAB_17D5
00A81C  2  A0 02        	LDY	#$02		; set index to pointer high byte
00A81E  2  B1 AE        	LDA	(des_pl),Y	; get string pointer high byte
00A820  2  C9 00        	CMP	#>Ibuffs
00A822  2  F0 22        	BEQ	LAB_17FB	; string in immediate command
00A824  2  C5 82        	CMP	Sstorh		; compare bottom of string space high byte
00A826  2  90 17        	BCC	LAB_17F4	; if less assign value and exit (was in program memory)
00A828  2               
00A828  2  D0 07        	BNE	LAB_17E6	; branch if >
00A82A  2               				; else was equal so compare low bytes
00A82A  2  88           	DEY			; decrement index
00A82B  2  B1 AE        	LDA	(des_pl),Y	; get pointer low byte
00A82D  2  C5 81        	CMP	Sstorl		; compare bottom of string space low byte
00A82F  2  90 0E        	BCC	LAB_17F4	; if less assign value and exit (was in program memory)
00A831  2               
00A831  2               				; pointer was >= to bottom of string space pointer
00A831  2               LAB_17E6
00A831  2  A4 AF        	LDY	des_ph		; get descriptor pointer high byte
00A833  2  C4 7C        	CPY	Svarh		; compare start of vars high byte
00A835  2  90 08        	BCC	LAB_17F4	; branch if less (descriptor is on stack)
00A837  2               
00A837  2  D0 0D        	BNE	LAB_17FB	; branch if greater (descriptor is not on stack)
00A839  2               
00A839  2               				; else high bytes were equal so ..
00A839  2  A5 AE        	LDA	des_pl		; get descriptor pointer low byte
00A83B  2  C5 7B        	CMP	Svarl		; compare start of vars low byte
00A83D  2  B0 07        	BCS	LAB_17FB	; branch if >= (descriptor is not on stack)
00A83F  2               
00A83F  2               LAB_17F4
00A83F  2  A5 AE        	LDA	des_pl		; get descriptor pointer low byte
00A841  2  A4 AF        	LDY	des_ph		; get descriptor pointer high byte
00A843  2  4C 5C A8     	JMP	LAB_1811	; clean stack, copy descriptor to variable and return
00A846  2               
00A846  2               				; make space and copy string
00A846  2               LAB_17FB
00A846  2  A0 00        	LDY	#$00		; index to length
00A848  2  B1 AE        	LDA	(des_pl),Y	; get string length
00A84A  2  20 85 B1     	JSR	LAB_209C	; copy string
00A84D  2  A5 9E        	LDA	des_2l		; get descriptor pointer low byte
00A84F  2  A4 9F        	LDY	des_2h		; get descriptor pointer high byte
00A851  2  85 B8        	STA	ssptr_l		; save descriptor pointer low byte
00A853  2  84 B9        	STY	ssptr_h		; save descriptor pointer high byte
00A855  2  20 6A B3     	JSR	LAB_228A	; copy string from descriptor (sdescr) to (Sutill)
00A858  2  A9 AC        	LDA	#<FAC1_e	; set descriptor pointer low byte
00A85A  2  A0 00        	LDY	#>FAC1_e	; get descriptor pointer high byte
00A85C  2               
00A85C  2               				; clean stack and assign value to string variable
00A85C  2               LAB_1811
00A85C  2  85 9E        	STA	des_2l		; save descriptor_2 pointer low byte
00A85E  2  84 9F        	STY	des_2h		; save descriptor_2 pointer high byte
00A860  2  20 CC B3     	JSR	LAB_22EB	; clean descriptor stack, YA = pointer
00A863  2  A0 00        	LDY	#$00		; index to length
00A865  2  B1 9E        	LDA	(des_2l),Y	; get string length
00A867  2  91 97        	STA	(Lvarpl),Y	; copy to let string variable
00A869  2  C8           	INY			; index to string pointer low byte
00A86A  2  B1 9E        	LDA	(des_2l),Y	; get string pointer low byte
00A86C  2  91 97        	STA	(Lvarpl),Y	; copy to let string variable
00A86E  2  C8           	INY			; index to string pointer high byte
00A86F  2  B1 9E        	LDA	(des_2l),Y	; get string pointer high byte
00A871  2  91 97        	STA	(Lvarpl),Y	; copy to let string variable
00A873  2  60           	RTS
00A874  2               
00A874  2               ; perform GET
00A874  2               
00A874  2               LAB_GET
00A874  2  20 00 AE     	JSR	LAB_GVAR	; get var address
00A877  2  85 97        	STA	Lvarpl		; save var address low byte
00A879  2  84 98        	STY	Lvarph		; save var address high byte
00A87B  2  20 68 BF     	JSR	INGET		; get input byte
00A87E  2  A6 5F        	LDX	Dtypef		; get data type flag, $FF=string, $00=numeric
00A880  2  30 07        	BMI	LAB_GETS	; go get string character
00A882  2               
00A882  2               				; was numeric get
00A882  2  A8           	TAY			; copy character to Y
00A883  2  20 BD B0     	JSR	LAB_1FD0	; convert Y to byte in FAC1
00A886  2  4C 05 B9     	JMP	LAB_PFAC	; pack FAC1 into variable (Lvarpl) and return
00A889  2               
00A889  2               LAB_GETS
00A889  2  48           	PHA			; save character
00A88A  2  A9 01        	LDA	#$01		; string is single byte
00A88C  2  B0 01        	BCS	LAB_IsByte	; branch if byte received
00A88E  2               
00A88E  2  68           	PLA			; string is null
00A88F  2               LAB_IsByte
00A88F  2  20 8D B1     	JSR	LAB_MSSP	; make string space A bytes long A=$AC=length,
00A892  2               				; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
00A892  2  F0 05        	BEQ	LAB_NoSt	; skip store if null string
00A894  2               
00A894  2  68           	PLA			; get character back
00A895  2  A0 00        	LDY	#$00		; clear index
00A897  2  91 AD        	STA	(str_pl),Y	; save byte in string (byte IS string!)
00A899  2               LAB_NoSt
00A899  2  20 DA B1     	JSR	LAB_RTST	; check for space on descriptor stack then put address
00A89C  2               				; and length on descriptor stack and update stack pointers
00A89C  2               
00A89C  2  4C 1C A8     	JMP	LAB_17D5	; do string LET and return
00A89F  2               
00A89F  2               ; perform PRINT
00A89F  2               
00A89F  2               LAB_1829
00A89F  2  20 25 A9     	JSR	LAB_18C6	; print string from Sutill/Sutilh
00A8A2  2               LAB_182C
00A8A2  2  20 C2 00     	JSR	LAB_GBYT	; scan memory
00A8A5  2               
00A8A5  2               ; PRINT
00A8A5  2               
00A8A5  2               LAB_PRINT
00A8A5  2  F0 3A        	BEQ	LAB_CRLF	; if nothing following just print CR/LF
00A8A7  2               
00A8A7  2               LAB_1831
00A8A7  2  C9 C2        	CMP	#TK_TAB		; compare with TAB( token
00A8A9  2  F0 55        	BEQ	LAB_18A2	; go do TAB/SPC
00A8AB  2               
00A8AB  2  C9 C6        	CMP	#TK_SPC		; compare with SPC( token
00A8AD  2  F0 51        	BEQ	LAB_18A2	; go do TAB/SPC
00A8AF  2               
00A8AF  2  C9 2C        	CMP	#','		; compare with ","
00A8B1  2  F0 37        	BEQ	LAB_188B	; go do move to next TAB mark
00A8B3  2               
00A8B3  2  C9 3B        	CMP	#';'		; compare with ";"
00A8B5  2  F0 65        	BEQ	LAB_18BD	; if ";" continue with PRINT processing
00A8B7  2               
00A8B7  2  20 28 AB     	JSR	LAB_EVEX	; evaluate expression
00A8BA  2  24 5F        	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
00A8BC  2  30 E1        	BMI	LAB_1829	; branch if string
00A8BE  2               
00A8BE  2  20 F7 BA     	JSR	LAB_296E	; convert FAC1 to string, returns YA=>string
00A8C1  2  20 97 B1     	JSR	LAB_20AE	; print " terminated string to Sutill/Sutilh
00A8C4  2  A0 00        	LDY	#$00		; clear index
00A8C6  2               
00A8C6  2               ; don't check fit if terminal width byte is zero
00A8C6  2               
00A8C6  2  A5 0F        	LDA	TWidth		; get terminal width byte
00A8C8  2  F0 0A        	BEQ	LAB_185E	; skip check if zero
00A8CA  2               
00A8CA  2  38           	SEC			; set carry for subtract
00A8CB  2  E5 0E        	SBC	TPos		; subtract terminal position
00A8CD  2  F1 AE        	SBC	(des_pl),Y	; subtract string length
00A8CF  2  B0 03        	BCS	LAB_185E	; branch if less than terminal width
00A8D1  2               
00A8D1  2  20 E1 A8     	JSR	LAB_CRLF	; else print CR/LF
00A8D4  2               LAB_185E
00A8D4  2  20 25 A9     	JSR	LAB_18C6	; print string from Sutill/Sutilh
00A8D7  2  F0 C9        	BEQ	LAB_182C	; always go continue processing line
00A8D9  2               
00A8D9  2               ; CR/LF return to BASIC from BASIC input handler
00A8D9  2               
00A8D9  2               LAB_1866
00A8D9  2  A9 00        	LDA	#$00		; clear byte
00A8DB  2  95 14        	STA	Ibuffs,X	; null terminate input
00A8DD  2  A2 14        	LDX	#<Ibuffs	; set X to buffer start-1 low byte
00A8DF  2  A0 00        	LDY	#>Ibuffs	; set Y to buffer start-1 high byte
00A8E1  2               
00A8E1  2               ; print CR/LF
00A8E1  2               
00A8E1  2               LAB_CRLF
00A8E1  2  A9 0D        	LDA	#$0D		; load [CR]
00A8E3  2  20 3C A9     	JSR	LAB_PRNA	; print the character
00A8E6  2  A9 0A        	LDA	#$0A		; load [LF]
00A8E8  2  D0 52        	BNE	LAB_PRNA	; print the character and return, branch always
00A8EA  2               
00A8EA  2               LAB_188B
00A8EA  2  A5 0E        	LDA	TPos		; get terminal position
00A8EC  2  C5 10        	CMP	Iclim		; compare with input column limit
00A8EE  2  90 05        	BCC	LAB_1897	; branch if less
00A8F0  2               
00A8F0  2  20 E1 A8     	JSR	LAB_CRLF	; else print CR/LF (next line)
00A8F3  2  D0 27        	BNE	LAB_18BD	; continue with PRINT processing (branch always)
00A8F5  2               
00A8F5  2               LAB_1897
00A8F5  2  38           	SEC			; set carry for subtract
00A8F6  2               LAB_1898
00A8F6  2  E5 64        	SBC	TabSiz		; subtract TAB size
00A8F8  2  B0 FC        	BCS	LAB_1898	; loop if result was +ve
00A8FA  2               
00A8FA  2  49 FF        	EOR	#$FF		; complement it
00A8FC  2  69 01        	ADC	#$01		; +1 (twos complement)
00A8FE  2  D0 12        	BNE	LAB_18B6	; always print A spaces (result is never $00)
00A900  2               
00A900  2               				; do TAB/SPC
00A900  2               LAB_18A2
00A900  2  48           	PHA			; save token
00A901  2  20 E2 B4     	JSR	LAB_SGBY	; scan and get byte parameter
00A904  2  C9 29        	CMP	#$29		; is next character )
00A906  2  D0 7B        	BNE	LAB_1910	; if not do syntax error then warm start
00A908  2               
00A908  2  68           	PLA			; get token back
00A909  2  C9 C2        	CMP	#TK_TAB		; was it TAB ?
00A90B  2  D0 06        	BNE	LAB_18B7	; if not go do SPC
00A90D  2               
00A90D  2               				; calculate TAB offset
00A90D  2  8A           	TXA			; copy integer value to A
00A90E  2  E5 0E        	SBC	TPos		; subtract terminal position
00A910  2  90 0A        	BCC	LAB_18BD	; branch if result was < 0 (can't TAB backwards)
00A912  2               
00A912  2               				; print A spaces
00A912  2               LAB_18B6
00A912  2  AA           	TAX			; copy result to X
00A913  2               LAB_18B7
00A913  2  8A           	TXA			; set flags on size for SPC
00A914  2  F0 06        	BEQ	LAB_18BD	; branch if result was = $0, already here
00A916  2               
00A916  2               				; print X spaces
00A916  2               LAB_18BA
00A916  2  20 37 A9     	JSR	LAB_18E0	; print " "
00A919  2  CA           	DEX			; decrement count
00A91A  2  D0 FA        	BNE	LAB_18BA	; loop if not all done
00A91C  2               
00A91C  2               				; continue with PRINT processing
00A91C  2               LAB_18BD
00A91C  2  20 BC 00     	JSR	LAB_IGBY	; increment and scan memory
00A91F  2  D0 86        	BNE	LAB_1831	; if more to print go do it
00A921  2               
00A921  2  60           	RTS
00A922  2               
00A922  2               ; print null terminated string from memory
00A922  2               
00A922  2               LAB_18C3
00A922  2  20 97 B1     	JSR	LAB_20AE	; print " terminated string to Sutill/Sutilh
00A925  2               
00A925  2               ; print string from Sutill/Sutilh
00A925  2               
00A925  2               LAB_18C6
00A925  2  20 97 B3     	JSR	LAB_22B6	; pop string off descriptor stack, or from top of string
00A928  2               				; space returns with A = length, X=$71=pointer low byte,
00A928  2               				; Y=$72=pointer high byte
00A928  2  A0 00        	LDY	#$00		; reset index
00A92A  2  AA           	TAX			; copy length to X
00A92B  2  F0 49        	BEQ	LAB_188C	; exit (RTS) if null string
00A92D  2               
00A92D  2               LAB_18CD
00A92D  2               
00A92D  2  B1 71        	LDA	(ut1_pl),Y	; get next byte
00A92F  2  20 3C A9     	JSR	LAB_PRNA	; go print the character
00A932  2  C8           	INY			; increment index
00A933  2  CA           	DEX			; decrement count
00A934  2  D0 F7        	BNE	LAB_18CD	; loop if not done yet
00A936  2               
00A936  2  60           	RTS
00A937  2               
00A937  2               				; Print single format character
00A937  2               ; print " "
00A937  2               
00A937  2               LAB_18E0
00A937  2  A9 20        	LDA	#$20		; load " "
00A939  2  2C           	.byte	$2C		; change next line to BIT LAB_3FA9
00A93A  2               
00A93A  2               ; print "?" character
00A93A  2               
00A93A  2               LAB_18E3
00A93A  2  A9 3F        	LDA	#$3F		; load "?" character
00A93C  2               
00A93C  2               ; print character in A
00A93C  2               ; now includes the null handler
00A93C  2               ; also includes infinite line length code
00A93C  2               ; note! some routines expect this one to exit with Zb=0
00A93C  2               
00A93C  2               LAB_PRNA
00A93C  2  C9 20        	CMP	#' '		; compare with " "
00A93E  2  90 19        	BCC	LAB_18F9	; branch if less (non printing)
00A940  2               
00A940  2               				; else printable character
00A940  2  48           	PHA			; save the character
00A941  2               
00A941  2               ; don't check fit if terminal width byte is zero
00A941  2               
00A941  2  A5 0F        	LDA	TWidth		; get terminal width
00A943  2  D0 0A        	BNE	LAB_18F0	; branch if not zero (not infinite length)
00A945  2               
00A945  2               ; is "infinite line" so check TAB position
00A945  2               
00A945  2  A5 0E        	LDA	TPos		; get position
00A947  2  E5 64        	SBC	TabSiz		; subtract TAB size, carry set by CMP #$20 above
00A949  2  D0 0B        	BNE	LAB_18F7	; skip reset if different
00A94B  2               
00A94B  2  85 0E        	STA	TPos		; else reset position
00A94D  2  F0 07        	BEQ	LAB_18F7	; go print character
00A94F  2               
00A94F  2               LAB_18F0
00A94F  2  C5 0E        	CMP	TPos		; compare with terminal character position
00A951  2  D0 03        	BNE	LAB_18F7	; branch if not at end of line
00A953  2               
00A953  2  20 E1 A8     	JSR	LAB_CRLF	; else print CR/LF
00A956  2               LAB_18F7
00A956  2  E6 0E        	INC	TPos		; increment terminal position
00A958  2  68           	PLA			; get character back
00A959  2               LAB_18F9
00A959  2  20 55 C1     	JSR	V_OUTP		; output byte via output vector
00A95C  2  C9 0D        	CMP	#$0D		; compare with [CR]
00A95E  2  D0 14        	BNE	LAB_188A	; branch if not [CR]
00A960  2               
00A960  2               				; else print nullct nulls after the [CR]
00A960  2  86 78        	STX	TempB		; save buffer index
00A962  2  A6 0D        	LDX	Nullct		; get null count
00A964  2  F0 0A        	BEQ	LAB_1886	; branch if no nulls
00A966  2               
00A966  2  A9 00        	LDA	#$00		; load [NULL]
00A968  2               LAB_1880
00A968  2  20 3C A9     	JSR	LAB_PRNA	; go print the character
00A96B  2  CA           	DEX			; decrement count
00A96C  2  D0 FA        	BNE	LAB_1880	; loop if not all done
00A96E  2               
00A96E  2  A9 0D        	LDA	#$0D		; restore the character (and set the flags)
00A970  2               LAB_1886
00A970  2  86 0E        	STX	TPos		; clear terminal position (X always = zero when we get here)
00A972  2  A6 78        	LDX	TempB		; restore buffer index
00A974  2               LAB_188A
00A974  2  29 FF        	AND	#$FF		; set the flags
00A976  2               LAB_188C
00A976  2  60           	RTS
00A977  2               
00A977  2               ; handle bad input data
00A977  2               
00A977  2               LAB_1904
00A977  2  A5 62        	LDA	Imode		; get input mode flag, $00=INPUT, $00=READ
00A979  2  10 0B        	BPL	LAB_1913	; branch if INPUT (go do redo)
00A97B  2               
00A97B  2  A5 8D        	LDA	Dlinel		; get current DATA line low byte
00A97D  2  A4 8E        	LDY	Dlineh		; get current DATA line high byte
00A97F  2  85 87        	STA	Clinel		; save current line low byte
00A981  2  84 88        	STY	Clineh		; save current line high byte
00A983  2               LAB_1910
00A983  2  4C 4A AC     	JMP	LAB_SNER	; do syntax error then warm start
00A986  2               
00A986  2               				; mode was INPUT
00A986  2               LAB_1913
00A986  2  A9 B8        	LDA	#<LAB_REDO	; point to redo message (low addr)
00A988  2  A0 C9        	LDY	#>LAB_REDO	; point to redo message (high addr)
00A98A  2  20 22 A9     	JSR	LAB_18C3	; print null terminated string from memory
00A98D  2  A5 8B        	LDA	Cpntrl		; get continue pointer low byte
00A98F  2  A4 8C        	LDY	Cpntrh		; get continue pointer high byte
00A991  2  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
00A993  2  84 C4        	STY	Bpntrh		; save BASIC execute pointer high byte
00A995  2  60           	RTS
00A996  2               
00A996  2               ; perform INPUT
00A996  2               LAB_INPUT
00A996  2  C9 22        	CMP	#$22		; compare next byte with open quote
00A998  2  D0 0E        	BNE	LAB_1934	; branch if no prompt string
00A99A  2               
00A99A  2  20 06 AC     	JSR	LAB_1BC1	; evaluate string to Sutill/Sutilh
00A99D  2               ;;	JSR	LAB_18C6	; print string from Sutill/Sutilh
00A99D  2               ;;	JSR	LAB_GBYT
00A99D  2               ;;	CMP	#$3B
00A99D  2               ;;	BNE	LAB_193A	; Not ";", skip "?" prompt
00A99D  2               ;;	JSR	LAB_IGBY	; Step past ";"
00A99D  2  A9 3B        	LDA	#$3B		; load A with ";"
00A99F  2  20 39 AC     	JSR	LAB_SCCA	; scan for CHR$(A), else do syntax error then warm start
00A9A2  2  20 25 A9     	JSR	LAB_18C6	; print string from Sutill/Sutilh
00A9A5  2  4C AE A9     	JMP	LAB_193A	; done with prompt, now get data
00A9A8  2               
00A9A8  2               LAB_1934
00A9A8  2  20 3A A9     	JSR	LAB_18E3	; print "?" character
00A9AB  2  20 37 A9     	JSR	LAB_18E0	; print " "
00A9AE  2               
00A9AE  2               				; done with prompt, now get data
00A9AE  2               LAB_193A
00A9AE  2  20 C1 B0     	JSR	LAB_CKRN	; check not Direct, back here if ok
00A9B1  2  20 6D A2     	JSR	LAB_1357	; get text input
00A9B4  2  A9 00        	LDA	#$00		; set mode = INPUT
00A9B6  2  F0 06        	BEQ	LAB_1953	; jump to read input data
00A9B8  2               ;
00A9B8  2               ; bugfix, allow empty string to be entered
00A9B8  2               ;	CMP	Ibuffs		; test first byte in buffer
00A9B8  2               ;	BNE	LAB_1953	; branch if not null input
00A9B8  2               ;
00A9B8  2               ;	CLC			; was null input so clear carry to exit program
00A9B8  2               ;	JMP	LAB_1647	; go to BREAK exit
00A9B8  2               
00A9B8  2               
00A9B8  2               ; perform READ
00A9B8  2               LAB_READ
00A9B8  2  A6 8F        	LDX	Dptrl		; get DATA pointer low byte
00A9BA  2  A4 90        	LDY	Dptrh		; get DATA pointer high byte
00A9BC  2  A9 80        	LDA	#$80		; set mode = READ
00A9BE  2               
00A9BE  2               LAB_1953
00A9BE  2  85 62        	STA	Imode		; set input mode flag, $00=INPUT, $80=READ
00A9C0  2  86 91        	STX	Rdptrl		; save READ pointer low byte
00A9C2  2  84 92        	STY	Rdptrh		; save READ pointer high byte
00A9C4  2               
00A9C4  2               				; READ or INPUT next variable from list
00A9C4  2               LAB_195B
00A9C4  2  20 00 AE     	JSR	LAB_GVAR	; get (var) address
00A9C7  2  85 97        	STA	Lvarpl		; save address low byte
00A9C9  2  84 98        	STY	Lvarph		; save address high byte
00A9CB  2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
00A9CD  2  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte
00A9CF  2  85 11        	STA	Itempl		; save as temporary integer low byte
00A9D1  2  84 12        	STY	Itemph		; save as temporary integer high byte
00A9D3  2  A6 91        	LDX	Rdptrl		; get READ pointer low byte
00A9D5  2  A4 92        	LDY	Rdptrh		; get READ pointer high byte
00A9D7  2  86 C3        	STX	Bpntrl		; set BASIC execute pointer low byte
00A9D9  2  84 C4        	STY	Bpntrh		; set BASIC execute pointer high byte
00A9DB  2  20 C2 00     	JSR	LAB_GBYT	; scan memory
00A9DE  2  D0 07        	BNE	LAB_1988	; branch if not null
00A9E0  2               
00A9E0  2               				; pointer was to null entry
00A9E0  2  24 62        	BIT	Imode		; test input mode flag, $00=INPUT, $80=READ
00A9E2  2  30 5B        	BMI	LAB_19DD	; branch if READ
00A9E4  2               
00A9E4  2               				; mode was INPUT
00A9E4  2               ;	JSR	LAB_18E3	; print "?" character (double ? for extended input)
00A9E4  2               ;	JSR	LAB_INLN	; print "? " and get BASIC input
00A9E4  2               ;	STX	Bpntrl		; set BASIC execute pointer low byte
00A9E4  2               ;	STY	Bpntrh		; set BASIC execute pointer high byte
00A9E4  2               LAB_1985
00A9E4  2  20 C2 00     	JSR	LAB_GBYT	; scan memory
00A9E7  2               LAB_1988
00A9E7  2  24 5F        	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
00A9E9  2  10 24        	BPL	LAB_19B0	; branch if numeric
00A9EB  2               
00A9EB  2               				; else get string
00A9EB  2  85 5B        	STA	Srchc		; save search character
00A9ED  2  C9 22        	CMP	#$22		; was it " ?
00A9EF  2  F0 07        	BEQ	LAB_1999	; branch if so
00A9F1  2               
00A9F1  2  A9 3A        	LDA	#':'		; else search character is ":"
00A9F3  2  85 5B        	STA	Srchc		; set new search character
00A9F5  2  A9 2C        	LDA	#','		; other search character is ","
00A9F7  2  18           	CLC			; clear carry for add
00A9F8  2               LAB_1999
00A9F8  2  85 5C        	STA	Asrch		; set second search character
00A9FA  2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
00A9FC  2  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte
00A9FE  2               
00A9FE  2  69 00        	ADC	#$00		; c is =1 if we came via the BEQ LAB_1999, else =0
00AA00  2  90 01        	BCC	LAB_19A4	; branch if no execute pointer low byte rollover
00AA02  2               
00AA02  2  C8           	INY			; else increment high byte
00AA03  2               LAB_19A4
00AA03  2  20 9D B1     	JSR	LAB_20B4	; print Srchc or Asrch terminated string to Sutill/Sutilh
00AA06  2  20 21 B5     	JSR	LAB_23F3	; restore BASIC execute pointer from temp (Btmpl/Btmph)
00AA09  2  20 1C A8     	JSR	LAB_17D5	; go do string LET
00AA0C  2  4C 15 AA     	JMP	LAB_19B6	; go check string terminator
00AA0F  2               
00AA0F  2               				; get numeric INPUT
00AA0F  2               LAB_19B0
00AA0F  2  20 08 BA     	JSR	LAB_2887	; get FAC1 from string
00AA12  2  20 05 B9     	JSR	LAB_PFAC	; pack FAC1 into (Lvarpl)
00AA15  2               LAB_19B6
00AA15  2  20 C2 00     	JSR	LAB_GBYT	; scan memory
00AA18  2  F0 0A        	BEQ	LAB_19C5	; branch if null (last entry)
00AA1A  2               
00AA1A  2  C9 2C        	CMP	#','		; else compare with ","
00AA1C  2  F0 03        	BEQ	LAB_19C2	; branch if ","
00AA1E  2               
00AA1E  2  4C 77 A9     	JMP	LAB_1904	; else go handle bad input data
00AA21  2               
00AA21  2               				; got good input data
00AA21  2               LAB_19C2
00AA21  2  20 BC 00     	JSR	LAB_IGBY	; increment and scan memory
00AA24  2               LAB_19C5
00AA24  2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte (temp READ/INPUT ptr)
00AA26  2  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte (temp READ/INPUT ptr)
00AA28  2  85 91        	STA	Rdptrl		; save for now
00AA2A  2  84 92        	STY	Rdptrh		; save for now
00AA2C  2  A5 11        	LDA	Itempl		; get temporary integer low byte (temp BASIC execute ptr)
00AA2E  2  A4 12        	LDY	Itemph		; get temporary integer high byte (temp BASIC execute ptr)
00AA30  2  85 C3        	STA	Bpntrl		; set BASIC execute pointer low byte
00AA32  2  84 C4        	STY	Bpntrh		; set BASIC execute pointer high byte
00AA34  2  20 C2 00     	JSR	LAB_GBYT	; scan memory
00AA37  2  F0 2C        	BEQ	LAB_1A03	; if null go do extra ignored message
00AA39  2               
00AA39  2  20 46 AC     	JSR	LAB_1C01	; else scan for "," , else do syntax error then warm start
00AA3C  2  4C C4 A9     	JMP	LAB_195B	; go INPUT next variable from list
00AA3F  2               
00AA3F  2               				; find next DATA statement or do "Out of DATA" error
00AA3F  2               LAB_19DD
00AA3F  2  20 E6 A6     	JSR	LAB_SNBS	; scan for next BASIC statement ([:] or [EOL])
00AA42  2  C8           	INY			; increment index
00AA43  2  AA           	TAX			; copy character ([:] or [EOL])
00AA44  2  D0 12        	BNE	LAB_19F6	; branch if [:]
00AA46  2               
00AA46  2  A2 06        	LDX	#$06		; set for "Out of DATA" error
00AA48  2  C8           	INY			; increment index, now points to next line pointer high byte
00AA49  2  B1 C3        	LDA	(Bpntrl),Y	; get next line pointer high byte
00AA4B  2  F0 73        	BEQ	LAB_1A54	; branch if end (eventually does error X)
00AA4D  2               
00AA4D  2  C8           	INY			; increment index
00AA4E  2  B1 C3        	LDA	(Bpntrl),Y	; get next line # low byte
00AA50  2  85 8D        	STA	Dlinel		; save current DATA line low byte
00AA52  2  C8           	INY			; increment index
00AA53  2  B1 C3        	LDA	(Bpntrl),Y	; get next line # high byte
00AA55  2  C8           	INY			; increment index
00AA56  2  85 8E        	STA	Dlineh		; save current DATA line high byte
00AA58  2               LAB_19F6
00AA58  2  B1 C3        	LDA	(Bpntrl),Y	; get byte
00AA5A  2  C8           	INY			; increment index
00AA5B  2  AA           	TAX			; copy to X
00AA5C  2  20 D8 A6     	JSR	LAB_170F	; set BASIC execute pointer
00AA5F  2  E0 83        	CPX	#TK_DATA	; compare with "DATA" token
00AA61  2  F0 81        	BEQ	LAB_1985	; was "DATA" so go do next READ
00AA63  2               
00AA63  2  D0 DA        	BNE	LAB_19DD	; go find next statement if not "DATA"
00AA65  2               
00AA65  2               ; end of INPUT/READ routine
00AA65  2               
00AA65  2               LAB_1A03
00AA65  2  A5 91        	LDA	Rdptrl		; get temp READ pointer low byte
00AA67  2  A4 92        	LDY	Rdptrh		; get temp READ pointer high byte
00AA69  2  A6 62        	LDX	Imode		; get input mode flag, $00=INPUT, $80=READ
00AA6B  2  10 03        	BPL	LAB_1A0E	; branch if INPUT
00AA6D  2               
00AA6D  2  4C 95 A5     	JMP	LAB_1624	; save AY as DATA pointer and return
00AA70  2               
00AA70  2               				; we were getting INPUT
00AA70  2               LAB_1A0E
00AA70  2  A0 00        	LDY	#$00		; clear index
00AA72  2  B1 91        	LDA	(Rdptrl),Y	; get next byte
00AA74  2  D0 01        	BNE	LAB_1A1B	; error if not end of INPUT
00AA76  2               
00AA76  2  60           	RTS
00AA77  2               
00AA77  2               				; user typed too much
00AA77  2               LAB_1A1B
00AA77  2  A9 A7        	LDA	#<LAB_IMSG	; point to extra ignored message (low addr)
00AA79  2  A0 C9        	LDY	#>LAB_IMSG	; point to extra ignored message (high addr)
00AA7B  2  4C 22 A9     	JMP	LAB_18C3	; print null terminated string from memory and return
00AA7E  2               
00AA7E  2               ; search the stack for FOR activity
00AA7E  2               ; exit with z=1 if FOR else exit with z=0
00AA7E  2               
00AA7E  2               LAB_11A1
00AA7E  2  BA           	TSX			; copy stack pointer
00AA7F  2  E8           	INX			; +1 pass return address
00AA80  2  E8           	INX			; +2 pass return address
00AA81  2  E8           	INX			; +3 pass calling routine return address
00AA82  2  E8           	INX			; +4 pass calling routine return address
00AA83  2               LAB_11A6
00AA83  2  BD 01 01     	LDA	LAB_STAK+1,X	; get token byte from stack
00AA86  2  C9 81        	CMP	#TK_FOR		; is it FOR token
00AA88  2  D0 21        	BNE	LAB_11CE	; exit if not FOR token
00AA8A  2               
00AA8A  2               				; was FOR token
00AA8A  2  A5 98        	LDA	Frnxth		; get var pointer for FOR/NEXT high byte
00AA8C  2  D0 0A        	BNE	LAB_11BB	; branch if not null
00AA8E  2               
00AA8E  2  BD 02 01     	LDA	LAB_STAK+2,X	; get FOR variable pointer low byte
00AA91  2  85 97        	STA	Frnxtl		; save var pointer for FOR/NEXT low byte
00AA93  2  BD 03 01     	LDA	LAB_STAK+3,X	; get FOR variable pointer high byte
00AA96  2  85 98        	STA	Frnxth		; save var pointer for FOR/NEXT high byte
00AA98  2               LAB_11BB
00AA98  2  DD 03 01     	CMP	LAB_STAK+3,X	; compare var pointer with stacked var pointer (high byte)
00AA9B  2  D0 07        	BNE	LAB_11C7	; branch if no match
00AA9D  2               
00AA9D  2  A5 97        	LDA	Frnxtl		; get var pointer for FOR/NEXT low byte
00AA9F  2  DD 02 01     	CMP	LAB_STAK+2,X	; compare var pointer with stacked var pointer (low byte)
00AAA2  2  F0 07        	BEQ	LAB_11CE	; exit if match found
00AAA4  2               
00AAA4  2               LAB_11C7
00AAA4  2  8A           	TXA			; copy index
00AAA5  2  18           	CLC			; clear carry for add
00AAA6  2  69 10        	ADC	#$10		; add FOR stack use size
00AAA8  2  AA           	TAX			; copy back to index
00AAA9  2  D0 D8        	BNE	LAB_11A6	; loop if not at start of stack
00AAAB  2               
00AAAB  2               LAB_11CE
00AAAB  2  60           	RTS
00AAAC  2               
00AAAC  2               ; perform NEXT
00AAAC  2               
00AAAC  2               LAB_NEXT
00AAAC  2  D0 04        	BNE	LAB_1A46	; branch if NEXT var
00AAAE  2               
00AAAE  2  A0 00        	LDY	#$00		; else clear Y
00AAB0  2  F0 03        	BEQ	LAB_1A49	; branch always (no variable to search for)
00AAB2  2               
00AAB2  2               ; NEXT var
00AAB2  2               
00AAB2  2               LAB_1A46
00AAB2  2  20 00 AE     	JSR	LAB_GVAR	; get variable address
00AAB5  2               LAB_1A49
00AAB5  2  85 97        	STA	Frnxtl		; store variable pointer low byte
00AAB7  2  84 98        	STY	Frnxth		; store variable pointer high byte
00AAB9  2               				; (both cleared if no variable defined)
00AAB9  2  20 7E AA     	JSR	LAB_11A1	; search the stack for FOR activity
00AABC  2  F0 04        	BEQ	LAB_1A56	; branch if found
00AABE  2               
00AABE  2  A2 00        	LDX	#$00		; else set error $00 ("NEXT without FOR" error)
00AAC0  2               LAB_1A54
00AAC0  2  F0 63        	BEQ	LAB_1ABE	; do error #X, then warm start
00AAC2  2               
00AAC2  2               LAB_1A56
00AAC2  2  9A           	TXS			; set stack pointer, X set by search, dumps return addresses
00AAC3  2               
00AAC3  2  8A           	TXA			; copy stack pointer
00AAC4  2  38           	SEC			; set carry for subtract
00AAC5  2  E9 F7        	SBC	#$F7		; point to TO var
00AAC7  2  85 73        	STA	ut2_pl		; save pointer to TO var for compare
00AAC9  2  69 FB        	ADC	#$FB		; point to STEP var
00AACB  2               
00AACB  2  A0 01        	LDY	#>LAB_STAK	; point to stack page high byte
00AACD  2  20 DF B8     	JSR	LAB_UFAC	; unpack memory (STEP value) into FAC1
00AAD0  2  BA           	TSX			; get stack pointer back
00AAD1  2  BD 08 01     	LDA	LAB_STAK+8,X	; get step sign
00AAD4  2  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
00AAD6  2  A5 97        	LDA	Frnxtl		; get FOR variable pointer low byte
00AAD8  2  A4 98        	LDY	Frnxth		; get FOR variable pointer high byte
00AADA  2  20 20 B6     	JSR	LAB_246C	; add (FOR variable) to FAC1
00AADD  2  20 05 B9     	JSR	LAB_PFAC	; pack FAC1 into (FOR variable)
00AAE0  2  A0 01        	LDY	#>LAB_STAK	; point to stack page high byte
00AAE2  2  20 7B B9     	JSR	LAB_27FA	; compare FAC1 with (Y,ut2_pl) (TO value)
00AAE5  2  BA           	TSX			; get stack pointer back
00AAE6  2  DD 08 01     	CMP	LAB_STAK+8,X	; compare step sign
00AAE9  2  F0 17        	BEQ	LAB_1A9B	; branch if = (loop complete)
00AAEB  2               
00AAEB  2               				; loop back and do it all again
00AAEB  2  BD 0D 01     	LDA	LAB_STAK+$0D,X	; get FOR line low byte
00AAEE  2  85 87        	STA	Clinel		; save current line low byte
00AAF0  2  BD 0E 01     	LDA	LAB_STAK+$0E,X	; get FOR line high byte
00AAF3  2  85 88        	STA	Clineh		; save current line high byte
00AAF5  2  BD 10 01     	LDA	LAB_STAK+$10,X	; get BASIC execute pointer low byte
00AAF8  2  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
00AAFA  2  BD 0F 01     	LDA	LAB_STAK+$0F,X	; get BASIC execute pointer high byte
00AAFD  2  85 C4        	STA	Bpntrh		; save BASIC execute pointer high byte
00AAFF  2               LAB_1A98
00AAFF  2  4C 0B A5     	JMP	LAB_15C2	; go do interpreter inner loop
00AB02  2               
00AB02  2               				; loop complete so carry on
00AB02  2               LAB_1A9B
00AB02  2  8A           	TXA			; stack copy to A
00AB03  2  69 0F        	ADC	#$0F		; add $10 ($0F+carry) to dump FOR structure
00AB05  2  AA           	TAX			; copy back to index
00AB06  2  9A           	TXS			; copy to stack pointer
00AB07  2  20 C2 00     	JSR	LAB_GBYT	; scan memory
00AB0A  2  C9 2C        	CMP	#','		; compare with ","
00AB0C  2  D0 F1        	BNE	LAB_1A98	; branch if not "," (go do interpreter inner loop)
00AB0E  2               
00AB0E  2               				; was "," so another NEXT variable to do
00AB0E  2  20 BC 00     	JSR	LAB_IGBY	; else increment and scan memory
00AB11  2  20 B2 AA     	JSR	LAB_1A46	; do NEXT (var)
00AB14  2               
00AB14  2               ; evaluate expression and check is numeric, else do type mismatch
00AB14  2               
00AB14  2               LAB_EVNM
00AB14  2  20 28 AB     	JSR	LAB_EVEX	; evaluate expression
00AB17  2               
00AB17  2               ; check if source is numeric, else do type mismatch
00AB17  2               
00AB17  2               LAB_CTNM
00AB17  2  18           	CLC			; destination is numeric
00AB18  2  24           	.byte	$24		; makes next line BIT $38
00AB19  2               
00AB19  2               ; check if source is string, else do type mismatch
00AB19  2               
00AB19  2               LAB_CTST
00AB19  2  38           	SEC			; required type is string
00AB1A  2               
00AB1A  2               ; type match check, set C for string, clear C for numeric
00AB1A  2               
00AB1A  2               LAB_CKTM
00AB1A  2  24 5F        	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
00AB1C  2  30 03        	BMI	LAB_1ABA	; branch if data type is string
00AB1E  2               
00AB1E  2               				; else data type was numeric
00AB1E  2  B0 03        	BCS	LAB_1ABC	; if required type is string do type mismatch error
00AB20  2               LAB_1AB9
00AB20  2  60           	RTS
00AB21  2               
00AB21  2               				; data type was string, now check required type
00AB21  2               LAB_1ABA
00AB21  2  B0 FD        	BCS	LAB_1AB9	; exit if required type is string
00AB23  2               
00AB23  2               				; else do type mismatch error
00AB23  2               LAB_1ABC
00AB23  2  A2 18        	LDX	#$18		; error code $18 ("Type mismatch" error)
00AB25  2               LAB_1ABE
00AB25  2  4C 4C A1     	JMP	LAB_XERR	; do error #X, then warm start
00AB28  2               
00AB28  2               ; evaluate expression
00AB28  2               
00AB28  2               LAB_EVEX
00AB28  2  A6 C3        	LDX	Bpntrl		; get BASIC execute pointer low byte
00AB2A  2  D0 02        	BNE	LAB_1AC7	; skip next if not zero
00AB2C  2               
00AB2C  2  C6 C4        	DEC	Bpntrh		; else decrement BASIC execute pointer high byte
00AB2E  2               LAB_1AC7
00AB2E  2  C6 C3        	DEC	Bpntrl		; decrement BASIC execute pointer low byte
00AB30  2               
00AB30  2               LAB_EVEZ
00AB30  2  A9 00        	LDA	#$00		; set null precedence (flag done)
00AB32  2               LAB_1ACC
00AB32  2  48           	PHA			; push precedence byte
00AB33  2  A9 02        	LDA	#$02		; 2 bytes
00AB35  2  20 10 A1     	JSR	LAB_1212	; check room on stack for A bytes
00AB38  2  20 15 AC     	JSR	LAB_GVAL	; get value from line
00AB3B  2  A9 00        	LDA	#$00		; clear A
00AB3D  2  85 9B        	STA	comp_f		; clear compare function flag
00AB3F  2               LAB_1ADB
00AB3F  2  20 C2 00     	JSR	LAB_GBYT	; scan memory
00AB42  2               LAB_1ADE
00AB42  2  38           	SEC			; set carry for subtract
00AB43  2  E9 D7        	SBC	#TK_GT		; subtract token for > (lowest comparison function)
00AB45  2  90 17        	BCC	LAB_1AFA	; branch if < TK_GT
00AB47  2               
00AB47  2  C9 03        	CMP	#$03		; compare with ">" to "<" tokens
00AB49  2  B0 13        	BCS	LAB_1AFA	; branch if >= TK_SGN (highest evaluation function +1)
00AB4B  2               
00AB4B  2               				; was token for > = or < (A = 0, 1 or 2)
00AB4B  2  C9 01        	CMP	#$01		; compare with token for =
00AB4D  2  2A           	ROL			; *2, b0 = carry (=1 if token was = or <)
00AB4E  2               				; (A = 0, 3 or 5)
00AB4E  2  49 01        	EOR	#$01		; toggle b0
00AB50  2               				; (A = 1, 2 or 4. 1 if >, 2 if =, 4 if <)
00AB50  2  45 9B        	EOR	comp_f		; EOR with compare function flag bits
00AB52  2  C5 9B        	CMP	comp_f		; compare with compare function flag
00AB54  2  90 68        	BCC	LAB_1B53	; if <(comp_f) do syntax error then warm start
00AB56  2               				; was more than one <, = or >)
00AB56  2               
00AB56  2  85 9B        	STA	comp_f		; save new compare function flag
00AB58  2  20 BC 00     	JSR	LAB_IGBY	; increment and scan memory
00AB5B  2  4C 42 AB     	JMP	LAB_1ADE	; go do next character
00AB5E  2               
00AB5E  2               				; token is < ">" or > "<" tokens
00AB5E  2               LAB_1AFA
00AB5E  2  A6 9B        	LDX	comp_f		; get compare function flag
00AB60  2  D0 2C        	BNE	LAB_1B2A	; branch if compare function
00AB62  2               
00AB62  2  B0 7A        	BCS	LAB_1B78	; go do functions
00AB64  2               
00AB64  2               				; else was <  TK_GT so is operator or lower
00AB64  2  69 0A        	ADC	#TK_GT-TK_PLUS	; add # of operators (+, -, *, /, ^, AND, OR or EOR)
00AB66  2  90 76        	BCC	LAB_1B78	; branch if < + operator
00AB68  2               
00AB68  2               				; carry was set so token was +, -, *, /, ^, AND, OR or EOR
00AB68  2  D0 07        	BNE	LAB_1B0B	; branch if not + token
00AB6A  2               
00AB6A  2  24 5F        	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
00AB6C  2  10 03        	BPL	LAB_1B0B	; branch if not string
00AB6E  2               
00AB6E  2               				; will only be $00 if type is string and token was +
00AB6E  2  4C 2D B3     	JMP	LAB_224D	; add strings, string 1 is in descriptor des_pl, string 2
00AB71  2               				; is in line, and return
00AB71  2               
00AB71  2               LAB_1B0B
00AB71  2  85 71        	STA	ut1_pl		; save it
00AB73  2  0A           	ASL			; *2
00AB74  2  65 71        	ADC	ut1_pl		; *3
00AB76  2  A8           	TAY			; copy to index
00AB77  2               LAB_1B13
00AB77  2  68           	PLA			; pull previous precedence
00AB78  2  D9 88 C3     	CMP	LAB_OPPT,Y	; compare with precedence byte
00AB7B  2  B0 66        	BCS	LAB_1B7D	; branch if A >=
00AB7D  2               
00AB7D  2  20 17 AB     	JSR	LAB_CTNM	; check if source is numeric, else do type mismatch
00AB80  2               LAB_1B1C
00AB80  2  48           	PHA			; save precedence
00AB81  2               LAB_1B1D
00AB81  2  20 A9 AB     	JSR	LAB_1B43	; get vector, execute function then continue evaluation
00AB84  2  68           	PLA			; restore precedence
00AB85  2  A4 99        	LDY	prstk		; get precedence stacked flag
00AB87  2  10 19        	BPL	LAB_1B3C	; branch if stacked values
00AB89  2               
00AB89  2  AA           	TAX			; copy precedence (set flags)
00AB8A  2  F0 77        	BEQ	LAB_1B9D	; exit if done
00AB8C  2               
00AB8C  2  D0 5E        	BNE	LAB_1B86	; else pop FAC2 and return, branch always
00AB8E  2               
00AB8E  2               LAB_1B2A
00AB8E  2  26 5F        	ROL	Dtypef		; shift data type flag into Cb
00AB90  2  8A           	TXA			; copy compare function flag
00AB91  2  85 5F        	STA	Dtypef		; clear data type flag, X is 0xxx xxxx
00AB93  2  2A           	ROL			; shift data type into compare function byte b0
00AB94  2  A6 C3        	LDX	Bpntrl		; get BASIC execute pointer low byte
00AB96  2  D0 02        	BNE	LAB_1B34	; branch if no underflow
00AB98  2               
00AB98  2  C6 C4        	DEC	Bpntrh		; else decrement BASIC execute pointer high byte
00AB9A  2               LAB_1B34
00AB9A  2  C6 C3        	DEC	Bpntrl		; decrement BASIC execute pointer low byte
00AB9C  2               TK_LT_PLUS	= TK_LT-TK_PLUS
00AB9C  2  A0 24        	LDY	#TK_LT_PLUS*3	; set offset to last operator entry
00AB9E  2  85 9B        	STA	comp_f		; save new compare function flag
00ABA0  2  D0 D5        	BNE	LAB_1B13	; branch always
00ABA2  2               
00ABA2  2               LAB_1B3C
00ABA2  2  D9 88 C3     	CMP	LAB_OPPT,Y	;.compare with stacked function precedence
00ABA5  2  B0 45        	BCS	LAB_1B86	; branch if A >=, pop FAC2 and return
00ABA7  2               
00ABA7  2  90 D7        	BCC	LAB_1B1C	; branch always
00ABA9  2               
00ABA9  2               ;.get vector, execute function then continue evaluation
00ABA9  2               
00ABA9  2               LAB_1B43
00ABA9  2  B9 8A C3     	LDA	LAB_OPPT+2,Y	; get function vector high byte
00ABAC  2  48           	PHA			; onto stack
00ABAD  2  B9 89 C3     	LDA	LAB_OPPT+1,Y	; get function vector low byte
00ABB0  2  48           	PHA			; onto stack
00ABB1  2               				; now push sign, round FAC1 and put on stack
00ABB1  2               ; *** begin patch  2.22p5.3   potential return address -$100 (page not incremented) ***
00ABB1  2               ; *** add
00ABB1  2               ;.if (* & $FF) = $FD
00ABB1  2  EA           	NOP			; return address of JSR +1 (on  next page)
00ABB2  2               ;.endif
00ABB2  2               ; *** end   patch  2.22p5.3   potential return address -$100 (page not incremented) ***
00ABB2  2  20 C1 AB     	JSR	LAB_1B5B	; function will return here, then the next RTS will call
00ABB5  2               				; the function
00ABB5  2  A5 9B        	LDA	comp_f		; get compare function flag
00ABB7  2  48           	PHA			; push compare evaluation byte
00ABB8  2  B9 88 C3     	LDA	LAB_OPPT,Y	; get precedence byte
00ABBB  2  4C 32 AB     	JMP	LAB_1ACC	; continue evaluating expression
00ABBE  2               
00ABBE  2               LAB_1B53
00ABBE  2  4C 4A AC     	JMP	LAB_SNER	; do syntax error then warm start
00ABC1  2               
00ABC1  2               ; push sign, round FAC1 and put on stack
00ABC1  2               
00ABC1  2               LAB_1B5B
00ABC1  2  68           	PLA			; get return addr low byte
00ABC2  2  85 71        	STA	ut1_pl		; save it
00ABC4  2  E6 71        	INC	ut1_pl		; increment it (was ret-1 pushed? yes!)
00ABC6  2               				; note! no check is made on the high byte! if the calling
00ABC6  2               				; routine assembles to a page edge then this all goes
00ABC6  2               				; horribly wrong !!!
00ABC6  2  68           	PLA			; get return addr high byte
00ABC7  2  85 72        	STA	ut1_ph		; save it
00ABC9  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
00ABCB  2  48           	PHA			; push sign
00ABCC  2               
00ABCC  2               ; round FAC1 and put on stack
00ABCC  2               
00ABCC  2               ; *** begin patch  2.22p5.1   TO expression may get sign bit flipped
00ABCC  2               ; *** replace
00ABCC  2               ;LAB_1B66
00ABCC  2               ;	JSR	LAB_27BA	; round FAC1
00ABCC  2               ; *** with
00ABCC  2  20 3B B9     	JSR	LAB_27BA	; round FAC1
00ABCF  2               LAB_1B66
00ABCF  2               ; *** end   patch  2.22p5.1   TO expression may get sign bit flipped
00ABCF  2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
00ABD1  2  48           	PHA			; push on stack
00ABD2  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
00ABD4  2  48           	PHA			; push on stack
00ABD5  2  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
00ABD7  2  48           	PHA			; push on stack
00ABD8  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00ABDA  2  48           	PHA			; push on stack
00ABDB  2  6C 71 00     	JMP	(ut1_pl)	; return, sort of
00ABDE  2               
00ABDE  2               ; do functions
00ABDE  2               
00ABDE  2               LAB_1B78
00ABDE  2  A0 FF        	LDY	#$FF		; flag function
00ABE0  2  68           	PLA			; pull precedence byte
00ABE1  2               LAB_1B7B
00ABE1  2  F0 20        	BEQ	LAB_1B9D	; exit if done
00ABE3  2               
00ABE3  2               LAB_1B7D
00ABE3  2  C9 64        	CMP	#$64		; compare previous precedence with $64
00ABE5  2  F0 03        	BEQ	LAB_1B84	; branch if was $64 (< function)
00ABE7  2               
00ABE7  2  20 17 AB     	JSR	LAB_CTNM	; check if source is numeric, else do type mismatch
00ABEA  2               LAB_1B84
00ABEA  2  84 99        	STY	prstk		; save precedence stacked flag
00ABEC  2               
00ABEC  2               				; pop FAC2 and return
00ABEC  2               LAB_1B86
00ABEC  2  68           	PLA			; pop byte
00ABED  2  4A           	LSR			; shift out comparison evaluation lowest bit
00ABEE  2  85 63        	STA	Cflag		; save comparison evaluation flag
00ABF0  2  68           	PLA			; pop exponent
00ABF1  2  85 B3        	STA	FAC2_e		; save FAC2 exponent
00ABF3  2  68           	PLA			; pop mantissa1
00ABF4  2  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
00ABF6  2  68           	PLA			; pop mantissa2
00ABF7  2  85 B5        	STA	FAC2_2		; save FAC2 mantissa2
00ABF9  2  68           	PLA			; pop mantissa3
00ABFA  2  85 B6        	STA	FAC2_3		; save FAC2 mantissa3
00ABFC  2  68           	PLA			; pop sign
00ABFD  2  85 B7        	STA	FAC2_s		; save FAC2 sign (b7)
00ABFF  2  45 B0        	EOR	FAC1_s		; EOR FAC1 sign (b7)
00AC01  2  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
00AC03  2               LAB_1B9D
00AC03  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00AC05  2  60           	RTS
00AC06  2               
00AC06  2               ; print "..." string to string util area
00AC06  2               
00AC06  2               LAB_1BC1
00AC06  2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
00AC08  2  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte
00AC0A  2  69 00        	ADC	#$00		; add carry to low byte
00AC0C  2  90 01        	BCC	LAB_1BCA	; branch if no overflow
00AC0E  2               
00AC0E  2  C8           	INY			; increment high byte
00AC0F  2               LAB_1BCA
00AC0F  2  20 97 B1     	JSR	LAB_20AE	; print " terminated string to Sutill/Sutilh
00AC12  2  4C 21 B5     	JMP	LAB_23F3	; restore BASIC execute pointer from temp and return
00AC15  2               
00AC15  2               ; get value from line
00AC15  2               
00AC15  2               LAB_GVAL
00AC15  2  20 BC 00     	JSR	LAB_IGBY	; increment and scan memory
00AC18  2  B0 03        	BCS	LAB_1BAC	; branch if not numeric character
00AC1A  2               
00AC1A  2               				; else numeric string found (e.g. 123)
00AC1A  2               LAB_1BA9
00AC1A  2  4C 08 BA     	JMP	LAB_2887	; get FAC1 from string and return
00AC1D  2               
00AC1D  2               ; get value from line .. continued
00AC1D  2               
00AC1D  2               				; wasn't a number so ..
00AC1D  2               LAB_1BAC
00AC1D  2  AA           	TAX			; set the flags
00AC1E  2  30 2F        	BMI	LAB_1BD0	; if -ve go test token values
00AC20  2               
00AC20  2               				; else it is either a string, number, variable or (<expr>)
00AC20  2  C9 24        	CMP	#'$'		; compare with "$"
00AC22  2  F0 F6        	BEQ	LAB_1BA9	; branch if "$", hex number
00AC24  2               
00AC24  2  C9 25        	CMP	#'%'		; else compare with "%"
00AC26  2  F0 F2        	BEQ	LAB_1BA9	; branch if "%", binary number
00AC28  2               
00AC28  2  C9 2E        	CMP	#'.'		; compare with "."
00AC2A  2  F0 EE        	BEQ	LAB_1BA9	; if so get FAC1 from string and return (e.g. was .123)
00AC2C  2               
00AC2C  2               				; it wasn't any sort of number so ..
00AC2C  2  C9 22        	CMP	#$22		; compare with "
00AC2E  2  F0 D6        	BEQ	LAB_1BC1	; branch if open quote
00AC30  2               
00AC30  2               				; wasn't any sort of number so ..
00AC30  2               
00AC30  2               ; evaluate expression within parentheses
00AC30  2               
00AC30  2  C9 28        	CMP	#'('		; compare with "("
00AC32  2  D0 5B        	BNE	LAB_1C18	; if not "(" get (var), return value in FAC1 and $ flag
00AC34  2               
00AC34  2               LAB_1BF7
00AC34  2  20 30 AB     	JSR	LAB_EVEZ	; evaluate expression, no decrement
00AC37  2               
00AC37  2               ; all the 'scan for' routines return the character after the sought character
00AC37  2               
00AC37  2               ; scan for ")" , else do syntax error then warm start
00AC37  2               
00AC37  2               LAB_1BFB
00AC37  2  A9 29        	LDA	#$29		; load A with ")"
00AC39  2               
00AC39  2               ; scan for CHR$(A) , else do syntax error then warm start
00AC39  2               
00AC39  2               LAB_SCCA
00AC39  2  A0 00        	LDY	#$00		; clear index
00AC3B  2  D1 C3        	CMP	(Bpntrl),Y	; check next byte is = A
00AC3D  2  D0 0B        	BNE	LAB_SNER	; if not do syntax error then warm start
00AC3F  2               
00AC3F  2  4C BC 00     	JMP	LAB_IGBY	; increment and scan memory then return
00AC42  2               
00AC42  2               ; scan for "(" , else do syntax error then warm start
00AC42  2               
00AC42  2               LAB_1BFE
00AC42  2  A9 28        	LDA	#$28		; load A with "("
00AC44  2  D0 F3        	BNE	LAB_SCCA	; scan for CHR$(A), else do syntax error then warm start
00AC46  2               				; (branch always)
00AC46  2               
00AC46  2               ; scan for "," , else do syntax error then warm start
00AC46  2               
00AC46  2               LAB_1C01
00AC46  2  A9 2C        	LDA	#$2C		; load A with ","
00AC48  2  D0 EF        	BNE	LAB_SCCA	; scan for CHR$(A), else do syntax error then warm start
00AC4A  2               				; (branch always)
00AC4A  2               
00AC4A  2               ; syntax error then warm start
00AC4A  2               
00AC4A  2               LAB_SNER
00AC4A  2  A2 02        	LDX	#$02		; error code $02 ("Syntax" error)
00AC4C  2  4C 4C A1     	JMP	LAB_XERR	; do error #X, then warm start
00AC4F  2               
00AC4F  2               ; get value from line .. continued
00AC4F  2               ; do tokens
00AC4F  2               
00AC4F  2               LAB_1BD0
00AC4F  2  C9 CE        	CMP	#TK_MINUS	; compare with token for -
00AC51  2  F0 29        	BEQ	LAB_1C11	; branch if - token (do set-up for functions)
00AC53  2               
00AC53  2               				; wasn't -n so ..
00AC53  2  C9 CD        	CMP	#TK_PLUS	; compare with token for +
00AC55  2  F0 BE        	BEQ	LAB_GVAL	; branch if + token (+n = n so ignore leading +)
00AC57  2               
00AC57  2  C9 C8        	CMP	#TK_NOT		; compare with token for NOT
00AC59  2  D0 13        	BNE	LAB_1BE7	; branch if not token for NOT
00AC5B  2               
00AC5B  2               				; was NOT token
00AC5B  2               TK_EQUAL_PLUS	= TK_EQUAL-TK_PLUS
00AC5B  2  A0 21        	LDY	#TK_EQUAL_PLUS*3; offset to NOT function
00AC5D  2  D0 1F        	BNE	LAB_1C13	; do set-up for function then execute (branch always)
00AC5F  2               
00AC5F  2               ; do = compare
00AC5F  2               
00AC5F  2               LAB_EQUAL
00AC5F  2  20 FC AE     	JSR	LAB_EVIR	; evaluate integer expression (no sign check)
00AC62  2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
00AC64  2  49 FF        	EOR	#$FF		; invert it
00AC66  2  A8           	TAY			; copy it
00AC67  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
00AC69  2  49 FF        	EOR	#$FF		; invert it
00AC6B  2  4C AF B0     	JMP	LAB_AYFC	; save and convert integer AY to FAC1 and return
00AC6E  2               
00AC6E  2               ; get value from line .. continued
00AC6E  2               
00AC6E  2               				; wasn't +, -, or NOT so ..
00AC6E  2               LAB_1BE7
00AC6E  2  C9 C5        	CMP	#TK_FN		; compare with token for FN
00AC70  2  D0 03        	BNE	LAB_1BEE	; branch if not token for FN
00AC72  2               
00AC72  2  4C 0B B1     	JMP	LAB_201E	; go evaluate FNx
00AC75  2               
00AC75  2               ; get value from line .. continued
00AC75  2               
00AC75  2               				; wasn't +, -, NOT or FN so ..
00AC75  2               LAB_1BEE
00AC75  2  E9 DA        	SBC	#TK_SGN		; subtract with token for SGN
00AC77  2  B0 27        	BCS	LAB_1C27	; if a function token go do it
00AC79  2               
00AC79  2  4C 4A AC     	JMP	LAB_SNER	; else do syntax error
00AC7C  2               
00AC7C  2               ; set up for functions
00AC7C  2               
00AC7C  2               LAB_1C11
00AC7C  2               TK_GT_PLUS	= TK_GT-TK_PLUS
00AC7C  2  A0 1E        	LDY	#TK_GT_PLUS*3	; set offset from base to > operator
00AC7E  2               LAB_1C13
00AC7E  2  68           	PLA			; dump return address low byte
00AC7F  2               ; *** begin patch  2.22p5.4  concatenate MINUS or NOT() crashes EhBASIC  ***
00AC7F  2               ; *** replace
00AC7F  2               ;	PLA			; dump return address high byte
00AC7F  2               ;	JMP	LAB_1B1D	; execute function then continue evaluation
00AC7F  2               ; *** with
00AC7F  2  AA           	TAX			; save to trap concatenate
00AC80  2  68           	PLA			; dump return address high byte
00AC81  2  E0 35        	CPX	#<(LAB_224Da+2)	; from concatenate low return address?
00AC83  2  D0 04        	BNE	LAB_1C13b	; No - continue!
00AC85  2  C9 B3        	CMP	#>(LAB_224Da+2)	; from concatenate high return address?
00AC87  2  F0 03        	BEQ	LAB_1C13a	; Yes - error!
00AC89  2               LAB_1C13b
00AC89  2  4C 81 AB     	JMP	LAB_1B1D	; execute function then continue evaluation
00AC8C  2               LAB_1C13a
00AC8C  2  4C 23 AB     	JMP	LAB_1ABC	; throw "type mismatch error" then warm start
00AC8F  2               ; *** end   patch  2.22p5.4  concatenate MINUS or NOT() crashes EhBASIC  ***
00AC8F  2               
00AC8F  2               ; variable name setup
00AC8F  2               ; get (var), return value in FAC_1 and $ flag
00AC8F  2               
00AC8F  2               LAB_1C18
00AC8F  2  20 00 AE     	JSR	LAB_GVAR	; get (var) address
00AC92  2  85 AE        	STA	FAC1_2		; save address low byte in FAC1 mantissa2
00AC94  2  84 AF        	STY	FAC1_3		; save address high byte in FAC1 mantissa3
00AC96  2  A6 5F        	LDX	Dtypef		; get data type flag, $FF=string, $00=numeric
00AC98  2  30 03        	BMI	LAB_1C25	; if string then return (does RTS)
00AC9A  2               
00AC9A  2               LAB_1C24
00AC9A  2  4C DF B8     	JMP	LAB_UFAC	; unpack memory (AY) into FAC1
00AC9D  2               
00AC9D  2               LAB_1C25
00AC9D  2               ; *** begin patch  string pointer high byte trashed when moved to stack
00AC9D  2               ; *** add
00AC9D  2  46 B9        	LSR	FAC1_r		; clear bit 7 (<$80) = do not round up
00AC9F  2               ; *** end patch
00AC9F  2  60           	RTS
00ACA0  2               
00ACA0  2               ; get value from line .. continued
00ACA0  2               ; only functions left so ..
00ACA0  2               
00ACA0  2               ; set up function references
00ACA0  2               
00ACA0  2               ; new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
00ACA0  2               ; to process function calls. Now the function vector is computed and pushed on the stack
00ACA0  2               ; and the preprocess offset is read. If the preprocess offset is non-zero then the vector
00ACA0  2               ; is calculated and the routine called, if not this routine just does RTS. Whichever
00ACA0  2               ; happens, the RTS at the end of this routine, or the end of the preprocess routine, calls
00ACA0  2               ; the function code
00ACA0  2               
00ACA0  2               ; This also removes some less than elegant code that was used to bypass type checking
00ACA0  2               ; for functions that returned strings
00ACA0  2               
00ACA0  2               LAB_1C27
00ACA0  2  0A           	ASL			; *2 (2 bytes per function address)
00ACA1  2  A8           	TAY			; copy to index
00ACA2  2               
00ACA2  2  B9 41 C3     	LDA	LAB_FTBM,Y	; get function jump vector high byte
00ACA5  2  48           	PHA			; push functions jump vector high byte
00ACA6  2  B9 40 C3     	LDA	LAB_FTBL,Y	; get function jump vector low byte
00ACA9  2  48           	PHA			; push functions jump vector low byte
00ACAA  2               
00ACAA  2  B9 F9 C2     	LDA	LAB_FTPM,Y	; get function pre process vector high byte
00ACAD  2  F0 05        	BEQ	LAB_1C56	; skip pre process if null vector
00ACAF  2               
00ACAF  2  48           	PHA			; push functions pre process vector high byte
00ACB0  2  B9 F8 C2     	LDA	LAB_FTPL,Y	; get function pre process vector low byte
00ACB3  2  48           	PHA			; push functions pre process vector low byte
00ACB4  2               
00ACB4  2               LAB_1C56
00ACB4  2  60           	RTS			; do function, or pre process, call
00ACB5  2               
00ACB5  2               ; process string expression in parenthesis
00ACB5  2               
00ACB5  2               LAB_PPFS
00ACB5  2  20 34 AC     	JSR	LAB_1BF7	; process expression in parenthesis
00ACB8  2  4C 19 AB     	JMP	LAB_CTST	; check if source is string then do function,
00ACBB  2               				; else do type mismatch
00ACBB  2               
00ACBB  2               ; process numeric expression in parenthesis
00ACBB  2               
00ACBB  2               LAB_PPFN
00ACBB  2  20 34 AC     	JSR	LAB_1BF7	; process expression in parenthesis
00ACBE  2  4C 17 AB     	JMP	LAB_CTNM	; check if source is numeric then do function,
00ACC1  2               				; else do type mismatch
00ACC1  2               
00ACC1  2               ; set numeric data type and increment BASIC execute pointer
00ACC1  2               
00ACC1  2               LAB_PPBI
00ACC1  2  46 5F        	LSR	Dtypef		; clear data type flag, $FF=string, $00=numeric
00ACC3  2  4C BC 00     	JMP	LAB_IGBY	; increment and scan memory then do function
00ACC6  2               
00ACC6  2               ; process string for LEFT$, RIGHT$ or MID$
00ACC6  2               
00ACC6  2               LAB_LRMS
00ACC6  2  20 30 AB     	JSR	LAB_EVEZ	; evaluate (should be string) expression
00ACC9  2  20 46 AC     	JSR	LAB_1C01	; scan for ",", else do syntax error then warm start
00ACCC  2  20 19 AB     	JSR	LAB_CTST	; check if source is string, else do type mismatch
00ACCF  2               
00ACCF  2  68           	PLA			; get function jump vector low byte
00ACD0  2  AA           	TAX			; save functions jump vector low byte
00ACD1  2  68           	PLA			; get function jump vector high byte
00ACD2  2  A8           	TAY			; save functions jump vector high byte
00ACD3  2  A5 AF        	LDA	des_ph		; get descriptor pointer high byte
00ACD5  2  48           	PHA			; push string pointer high byte
00ACD6  2  A5 AE        	LDA	des_pl		; get descriptor pointer low byte
00ACD8  2  48           	PHA			; push string pointer low byte
00ACD9  2  98           	TYA			; get function jump vector high byte back
00ACDA  2  48           	PHA			; save functions jump vector high byte
00ACDB  2  8A           	TXA			; get function jump vector low byte back
00ACDC  2  48           	PHA			; save functions jump vector low byte
00ACDD  2  20 E5 B4     	JSR	LAB_GTBY	; get byte parameter
00ACE0  2  8A           	TXA			; copy byte parameter to A
00ACE1  2  60           	RTS			; go do function
00ACE2  2               
00ACE2  2               ; process numeric expression(s) for BIN$ or HEX$
00ACE2  2               
00ACE2  2               LAB_BHSS
00ACE2  2  20 30 AB     	JSR	LAB_EVEZ	; process expression
00ACE5  2  20 17 AB     	JSR	LAB_CTNM	; check if source is numeric, else do type mismatch
00ACE8  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00ACEA  2  C9 98        	CMP	#$98		; compare with exponent = 2^24
00ACEC  2  B0 20        	BCS	LAB_BHER	; branch if n>=2^24 (is too big)
00ACEE  2               
00ACEE  2  20 B2 B9     	JSR	LAB_2831	; convert FAC1 floating-to-fixed
00ACF1  2  A2 02        	LDX	#$02		; 3 bytes to do
00ACF3  2               LAB_CFAC
00ACF3  2  B5 AD        	LDA	FAC1_1,X	; get byte from FAC1
00ACF5  2  95 11        	STA	nums_1,X	; save byte to temp
00ACF7  2  CA           	DEX			; decrement index
00ACF8  2  10 F9        	BPL	LAB_CFAC	; copy FAC1 mantissa to temp
00ACFA  2               
00ACFA  2  20 C2 00     	JSR	LAB_GBYT	; get next BASIC byte
00ACFD  2  A2 00        	LDX	#$00		; set default to no leading "0"s
00ACFF  2  C9 29        	CMP	#')'		; compare with close bracket
00AD01  2  F0 0A        	BEQ	LAB_1C54	; if ")" go do rest of function
00AD03  2               
00AD03  2  20 30 B5     	JSR	LAB_SCGB	; scan for "," and get byte
00AD06  2  20 C2 00     	JSR	LAB_GBYT	; get last byte back
00AD09  2  C9 29        	CMP	#')'		; is next character )
00AD0B  2  D0 01        	BNE	LAB_BHER	; if not ")" go do error
00AD0D  2               
00AD0D  2               LAB_1C54
00AD0D  2  60           	RTS			; else do function
00AD0E  2               
00AD0E  2               LAB_BHER
00AD0E  2  4C 7F AF     	JMP	LAB_FCER	; do function call error then warm start
00AD11  2               
00AD11  2               ; perform EOR
00AD11  2               
00AD11  2               ; added operator format is the same as AND or OR, precedence is the same as OR
00AD11  2               
00AD11  2               ; this bit worked first time but it took a while to sort out the operator table
00AD11  2               ; pointers and offsets afterwards!
00AD11  2               
00AD11  2               LAB_EOR
00AD11  2  20 38 AD     	JSR	GetFirst	; get first integer expression (no sign check)
00AD14  2  45 5B        	EOR	XOAw_l		; EOR with expression 1 low byte
00AD16  2  A8           	TAY			; save in Y
00AD17  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
00AD19  2  45 5C        	EOR	XOAw_h		; EOR with expression 1 high byte
00AD1B  2  4C AF B0     	JMP	LAB_AYFC	; save and convert integer AY to FAC1 and return
00AD1E  2               
00AD1E  2               ; perform OR
00AD1E  2               
00AD1E  2               LAB_OR
00AD1E  2  20 38 AD     	JSR	GetFirst	; get first integer expression (no sign check)
00AD21  2  05 5B        	ORA	XOAw_l		; OR with expression 1 low byte
00AD23  2  A8           	TAY			; save in Y
00AD24  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
00AD26  2  05 5C        	ORA	XOAw_h		; OR with expression 1 high byte
00AD28  2  4C AF B0     	JMP	LAB_AYFC	; save and convert integer AY to FAC1 and return
00AD2B  2               
00AD2B  2               ; perform AND
00AD2B  2               
00AD2B  2               LAB_AND
00AD2B  2  20 38 AD     	JSR	GetFirst	; get first integer expression (no sign check)
00AD2E  2  25 5B        	AND	XOAw_l		; AND with expression 1 low byte
00AD30  2  A8           	TAY			; save in Y
00AD31  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
00AD33  2  25 5C        	AND	XOAw_h		; AND with expression 1 high byte
00AD35  2  4C AF B0     	JMP	LAB_AYFC	; save and convert integer AY to FAC1 and return
00AD38  2               
00AD38  2               ; get first value for OR, AND or EOR
00AD38  2               
00AD38  2               GetFirst
00AD38  2  20 FC AE     	JSR	LAB_EVIR	; evaluate integer expression (no sign check)
00AD3B  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
00AD3D  2  85 5C        	STA	XOAw_h		; save it
00AD3F  2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
00AD41  2  85 5B        	STA	XOAw_l		; save it
00AD43  2  20 25 B6     	JSR	LAB_279B	; copy FAC2 to FAC1 (get 2nd value in expression)
00AD46  2  20 FC AE     	JSR	LAB_EVIR	; evaluate integer expression (no sign check)
00AD49  2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
00AD4B  2               LAB_1C95
00AD4B  2  60           	RTS
00AD4C  2               
00AD4C  2               ; perform comparisons
00AD4C  2               
00AD4C  2               ; do < compare
00AD4C  2               
00AD4C  2               LAB_LTHAN
00AD4C  2  20 1A AB     	JSR	LAB_CKTM	; type match check, set C for string
00AD4F  2  B0 13        	BCS	LAB_1CAE	; branch if string
00AD51  2               
00AD51  2               				; do numeric < compare
00AD51  2  A5 B7        	LDA	FAC2_s		; get FAC2 sign (b7)
00AD53  2  09 7F        	ORA	#$7F		; set all non sign bits
00AD55  2  25 B4        	AND	FAC2_1		; and FAC2 mantissa1 (AND in sign bit)
00AD57  2  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
00AD59  2  A9 B3        	LDA	#<FAC2_e	; set pointer low byte to FAC2
00AD5B  2  A0 00        	LDY	#>FAC2_e	; set pointer high byte to FAC2
00AD5D  2  20 79 B9     	JSR	LAB_27F8	; compare FAC1 with FAC2 (AY)
00AD60  2  AA           	TAX			; copy result
00AD61  2  4C 95 AD     	JMP	LAB_1CE1	; go evaluate result
00AD64  2               
00AD64  2               				; do string < compare
00AD64  2               LAB_1CAE
00AD64  2  46 5F        	LSR	Dtypef		; clear data type flag, $FF=string, $00=numeric
00AD66  2  C6 9B        	DEC	comp_f		; clear < bit in compare function flag
00AD68  2  20 97 B3     	JSR	LAB_22B6	; pop string off descriptor stack, or from top of string
00AD6B  2               				; space returns with A = length, X=pointer low byte,
00AD6B  2               				; Y=pointer high byte
00AD6B  2  85 AC        	STA	str_ln		; save length
00AD6D  2  86 AD        	STX	str_pl		; save string pointer low byte
00AD6F  2  84 AE        	STY	str_ph		; save string pointer high byte
00AD71  2  A5 B5        	LDA	FAC2_2		; get descriptor pointer low byte
00AD73  2  A4 B6        	LDY	FAC2_3		; get descriptor pointer high byte
00AD75  2  20 9B B3     	JSR	LAB_22BA	; pop (YA) descriptor off stack or from top of string space
00AD78  2               				; returns with A = length, X=pointer low byte,
00AD78  2               				; Y=pointer high byte
00AD78  2  86 B5        	STX	FAC2_2		; save string pointer low byte
00AD7A  2  84 B6        	STY	FAC2_3		; save string pointer high byte
00AD7C  2  AA           	TAX			; copy length
00AD7D  2  38           	SEC			; set carry for subtract
00AD7E  2  E5 AC        	SBC	str_ln		; subtract string 1 length
00AD80  2  F0 08        	BEQ	LAB_1CD6	; branch if str 1 length = string 2 length
00AD82  2               
00AD82  2  A9 01        	LDA	#$01		; set str 1 length > string 2 length
00AD84  2  90 04        	BCC	LAB_1CD6	; branch if so
00AD86  2               
00AD86  2  A6 AC        	LDX	str_ln		; get string 1 length
00AD88  2  A9 FF        	LDA	#$FF		; set str 1 length < string 2 length
00AD8A  2               LAB_1CD6
00AD8A  2  85 B0        	STA	FAC1_s		; save length compare
00AD8C  2  A0 FF        	LDY	#$FF		; set index
00AD8E  2  E8           	INX			; adjust for loop
00AD8F  2               LAB_1CDB
00AD8F  2  C8           	INY			; increment index
00AD90  2  CA           	DEX			; decrement count
00AD91  2  D0 07        	BNE	LAB_1CE6	; branch if still bytes to do
00AD93  2               
00AD93  2  A6 B0        	LDX	FAC1_s		; get length compare back
00AD95  2               LAB_1CE1
00AD95  2  30 0F        	BMI	LAB_1CF2	; branch if str 1 < str 2
00AD97  2               
00AD97  2  18           	CLC			; flag str 1 <= str 2
00AD98  2  90 0C        	BCC	LAB_1CF2	; go evaluate result
00AD9A  2               
00AD9A  2               LAB_1CE6
00AD9A  2  B1 B5        	LDA	(FAC2_2),Y	; get string 2 byte
00AD9C  2  D1 AD        	CMP	(FAC1_1),Y	; compare with string 1 byte
00AD9E  2  F0 EF        	BEQ	LAB_1CDB	; loop if bytes =
00ADA0  2               
00ADA0  2  A2 FF        	LDX	#$FF		; set str 1 < string 2
00ADA2  2  B0 02        	BCS	LAB_1CF2	; branch if so
00ADA4  2               
00ADA4  2  A2 01        	LDX	#$01		;  set str 1 > string 2
00ADA6  2               LAB_1CF2
00ADA6  2  E8           	INX			; x = 0, 1 or 2
00ADA7  2  8A           	TXA			; copy to A
00ADA8  2  2A           	ROL			; *2 (1, 2 or 4)
00ADA9  2  25 63        	AND	Cflag		; AND with comparison evaluation flag
00ADAB  2  F0 02        	BEQ	LAB_1CFB	; branch if 0 (compare is false)
00ADAD  2               
00ADAD  2  A9 FF        	LDA	#$FF		; else set result true
00ADAF  2               LAB_1CFB
00ADAF  2  4C 5C B9     	JMP	LAB_27DB	; save A as integer byte and return
00ADB2  2               
00ADB2  2               LAB_1CFE
00ADB2  2  20 46 AC     	JSR	LAB_1C01	; scan for ",", else do syntax error then warm start
00ADB5  2               
00ADB5  2               ; perform DIM
00ADB5  2               
00ADB5  2               LAB_DIM
00ADB5  2  AA           	TAX			; copy "DIM" flag to X
00ADB6  2  20 05 AE     	JSR	LAB_1D10	; search for variable
00ADB9  2  20 C2 00     	JSR	LAB_GBYT	; scan memory
00ADBC  2  D0 F4        	BNE	LAB_1CFE	; scan for "," and loop if not null
00ADBE  2               
00ADBE  2  60           	RTS
00ADBF  2               
00ADBF  2               ; perform << (left shift)
00ADBF  2               
00ADBF  2               LAB_LSHIFT
00ADBF  2  20 F5 AD     	JSR	GetPair		; get integer expression and byte (no sign check)
00ADC2  2  A5 AE        	LDA	FAC1_2		; get expression high byte
00ADC4  2  A6 78        	LDX	TempB		; get shift count
00ADC6  2  F0 22        	BEQ	NoShift		; branch if zero
00ADC8  2               
00ADC8  2  E0 10        	CPX	#$10		; compare bit count with 16d
00ADCA  2  B0 23        	BCS	TooBig		; branch if >=
00ADCC  2               
00ADCC  2               Ls_loop
00ADCC  2  06 AF        	ASL	FAC1_3		; shift low byte
00ADCE  2  2A           	ROL			; shift high byte
00ADCF  2  CA           	DEX			; decrement bit count
00ADD0  2  D0 FA        	BNE	Ls_loop		; loop if shift not complete
00ADD2  2               
00ADD2  2  A4 AF        	LDY	FAC1_3		; get expression low byte
00ADD4  2  4C AF B0     	JMP	LAB_AYFC	; save and convert integer AY to FAC1 and return
00ADD7  2               
00ADD7  2               ; perform >> (right shift)
00ADD7  2               
00ADD7  2               LAB_RSHIFT
00ADD7  2  20 F5 AD     	JSR	GetPair		; get integer expression and byte (no sign check)
00ADDA  2  A5 AE        	LDA	FAC1_2		; get expression high byte
00ADDC  2  A6 78        	LDX	TempB		; get shift count
00ADDE  2  F0 0A        	BEQ	NoShift		; branch if zero
00ADE0  2               
00ADE0  2  E0 10        	CPX	#$10		; compare bit count with 16d
00ADE2  2  B0 0B        	BCS	TooBig		; branch if >=
00ADE4  2               
00ADE4  2               Rs_loop
00ADE4  2  4A           	LSR			; shift high byte
00ADE5  2  66 AF        	ROR	FAC1_3		; shift low byte
00ADE7  2  CA           	DEX			; decrement bit count
00ADE8  2  D0 FA        	BNE	Rs_loop		; loop if shift not complete
00ADEA  2               
00ADEA  2               NoShift
00ADEA  2  A4 AF        	LDY	FAC1_3		; get expression low byte
00ADEC  2  4C AF B0     	JMP	LAB_AYFC	; save and convert integer AY to FAC1 and return
00ADEF  2               
00ADEF  2               TooBig
00ADEF  2  A9 00        	LDA	#$00		; clear high byte
00ADF1  2  A8           	TAY			; copy to low byte
00ADF2  2  4C AF B0     	JMP	LAB_AYFC	; save and convert integer AY to FAC1 and return
00ADF5  2               
00ADF5  2               GetPair
00ADF5  2  20 E8 B4     	JSR	LAB_EVBY	; evaluate byte expression, result in X
00ADF8  2  86 78        	STX	TempB		; save it
00ADFA  2  20 25 B6     	JSR	LAB_279B	; copy FAC2 to FAC1 (get 2nd value in expression)
00ADFD  2  4C FC AE     	JMP	LAB_EVIR	; evaluate integer expression (no sign check)
00AE00  2               
00AE00  2               ; search for variable
00AE00  2               
00AE00  2               ; return pointer to variable in Cvaral/Cvarah
00AE00  2               
00AE00  2               LAB_GVAR
00AE00  2  A2 00        	LDX	#$00		; set DIM flag = $00
00AE02  2  20 C2 00     	JSR	LAB_GBYT	; scan memory (1st character)
00AE05  2               LAB_1D10
00AE05  2  86 5E        	STX	Defdim		; save DIM flag
00AE07  2               LAB_1D12
00AE07  2  85 93        	STA	Varnm1		; save 1st character
00AE09  2  29 7F        	AND	#$7F		; clear FN flag bit
00AE0B  2  20 74 AE     	JSR	LAB_CASC	; check byte, return C=0 if<"A" or >"Z"
00AE0E  2  B0 03        	BCS	LAB_1D1F	; branch if ok
00AE10  2               
00AE10  2  4C 4A AC     	JMP	LAB_SNER	; else syntax error then warm start
00AE13  2               
00AE13  2               				; was variable name so ..
00AE13  2               LAB_1D1F
00AE13  2  A2 00        	LDX	#$00		; clear 2nd character temp
00AE15  2  86 5F        	STX	Dtypef		; clear data type flag, $FF=string, $00=numeric
00AE17  2  20 BC 00     	JSR	LAB_IGBY	; increment and scan memory (2nd character)
00AE1A  2  90 05        	BCC	LAB_1D2D	; branch if character = "0"-"9" (ok)
00AE1C  2               
00AE1C  2               				; 2nd character wasn't "0" to "9" so ..
00AE1C  2  20 74 AE     	JSR	LAB_CASC	; check byte, return C=0 if<"A" or >"Z"
00AE1F  2  90 0B        	BCC	LAB_1D38	; branch if <"A" or >"Z" (go check if string)
00AE21  2               
00AE21  2               LAB_1D2D
00AE21  2  AA           	TAX			; copy 2nd character
00AE22  2               
00AE22  2               				; ignore further (valid) characters in the variable name
00AE22  2               LAB_1D2E
00AE22  2  20 BC 00     	JSR	LAB_IGBY	; increment and scan memory (3rd character)
00AE25  2  90 FB        	BCC	LAB_1D2E	; loop if character = "0"-"9" (ignore)
00AE27  2               
00AE27  2  20 74 AE     	JSR	LAB_CASC	; check byte, return C=0 if<"A" or >"Z"
00AE2A  2  B0 F6        	BCS	LAB_1D2E	; loop if character = "A"-"Z" (ignore)
00AE2C  2               
00AE2C  2               				; check if string variable
00AE2C  2               LAB_1D38
00AE2C  2  C9 24        	CMP	#'$'		; compare with "$"
00AE2E  2  D0 0B        	BNE	LAB_1D47	; branch if not string
00AE30  2               
00AE30  2               ; to introduce a new variable type (% suffix for integers say) then this branch
00AE30  2               ; will need to go to that check and then that branch, if it fails, go to LAB_1D47
00AE30  2               
00AE30  2               				; type is string
00AE30  2  A9 FF        	LDA	#$FF		; set data type = string
00AE32  2  85 5F        	STA	Dtypef		; set data type flag, $FF=string, $00=numeric
00AE34  2  8A           	TXA			; get 2nd character back
00AE35  2  09 80        	ORA	#$80		; set top bit (indicate string var)
00AE37  2  AA           	TAX			; copy back to 2nd character temp
00AE38  2  20 BC 00     	JSR	LAB_IGBY	; increment and scan memory
00AE3B  2               
00AE3B  2               ; after we have determined the variable type we need to come back here to determine
00AE3B  2               ; if it's an array of type. this would plug in a%(b[,c[,d]])) integer arrays nicely
00AE3B  2               
00AE3B  2               
00AE3B  2               LAB_1D47			; gets here with character after var name in A
00AE3B  2  86 94        	STX	Varnm2		; save 2nd character
00AE3D  2  05 61        	ORA	Sufnxf		; or with subscript/FNX flag (or FN name)
00AE3F  2  C9 28        	CMP	#'('		; compare with "("
00AE41  2  D0 03        	BNE	LAB_1D53	; branch if not "("
00AE43  2               
00AE43  2  4C 0E AF     	JMP	LAB_1E17	; go find, or make, array
00AE46  2               
00AE46  2               ; either find or create var
00AE46  2               ; var name (1st two characters only!) is in Varnm1,Varnm2
00AE46  2               
00AE46  2               				; variable name wasn't var(... so look for plain var
00AE46  2               LAB_1D53
00AE46  2  A9 00        	LDA	#$00		; clear A
00AE48  2  85 61        	STA	Sufnxf		; clear subscript/FNX flag
00AE4A  2  A5 7B        	LDA	Svarl		; get start of vars low byte
00AE4C  2  A6 7C        	LDX	Svarh		; get start of vars high byte
00AE4E  2  A0 00        	LDY	#$00		; clear index
00AE50  2               LAB_1D5D
00AE50  2  86 AB        	STX	Vrschh		; save search address high byte
00AE52  2               LAB_1D5F
00AE52  2  85 AA        	STA	Vrschl		; save search address low byte
00AE54  2  E4 7E        	CPX	Sarryh		; compare high address with var space end
00AE56  2  D0 04        	BNE	LAB_1D69	; skip next compare if <>
00AE58  2               
00AE58  2               				; high addresses were = so compare low addresses
00AE58  2  C5 7D        	CMP	Sarryl		; compare low address with var space end
00AE5A  2  F0 2C        	BEQ	LAB_1D8B	; if not found go make new var
00AE5C  2               
00AE5C  2               LAB_1D69
00AE5C  2  A5 93        	LDA	Varnm1		; get 1st character of var to find
00AE5E  2  D1 AA        	CMP	(Vrschl),Y	; compare with variable name 1st character
00AE60  2  D0 08        	BNE	LAB_1D77	; branch if no match
00AE62  2               
00AE62  2               				; 1st characters match so compare 2nd characters
00AE62  2  A5 94        	LDA	Varnm2		; get 2nd character of var to find
00AE64  2  C8           	INY			; index to point to variable name 2nd character
00AE65  2  D1 AA        	CMP	(Vrschl),Y	; compare with variable name 2nd character
00AE67  2  F0 69        	BEQ	LAB_1DD7	; branch if match (found var)
00AE69  2               
00AE69  2  88           	DEY			; else decrement index (now = $00)
00AE6A  2               LAB_1D77
00AE6A  2  18           	CLC			; clear carry for add
00AE6B  2  A5 AA        	LDA	Vrschl		; get search address low byte
00AE6D  2  69 06        	ADC	#$06		; +6 (offset to next var name)
00AE6F  2  90 E1        	BCC	LAB_1D5F	; loop if no overflow to high byte
00AE71  2               
00AE71  2  E8           	INX			; else increment high byte
00AE72  2  D0 DC        	BNE	LAB_1D5D	; loop always (RAM doesn't extend to $FFFF !)
00AE74  2               
00AE74  2               ; check byte, return C=0 if<"A" or >"Z" or "a" to "z"
00AE74  2               
00AE74  2               LAB_CASC
00AE74  2  C9 61        	CMP	#'a'		; compare with "a"
00AE76  2  B0 0A        	BCS	LAB_1D83	; go check <"z"+1
00AE78  2               
00AE78  2               ; check byte, return C=0 if<"A" or >"Z"
00AE78  2               
00AE78  2               LAB_1D82
00AE78  2  C9 41        	CMP	#'A'		; compare with "A"
00AE7A  2  90 05        	BCC	LAB_1D8A	; exit if less
00AE7C  2               
00AE7C  2               				; carry is set
00AE7C  2  E9 5B        	SBC	#$5B		; subtract "Z"+1
00AE7E  2  38           	SEC			; set carry
00AE7F  2  E9 A5        	SBC	#$A5		; subtract $A5 (restore byte)
00AE81  2               				; carry clear if byte>$5A
00AE81  2               LAB_1D8A
00AE81  2  60           	RTS
00AE82  2               
00AE82  2               LAB_1D83
00AE82  2  E9 7B        	SBC	#$7B		; subtract "z"+1
00AE84  2  38           	SEC			; set carry
00AE85  2  E9 85        	SBC	#$85		; subtract $85 (restore byte)
00AE87  2               				; carry clear if byte>$7A
00AE87  2  60           	RTS
00AE88  2               
00AE88  2               				; reached end of variable mem without match
00AE88  2               				; .. so create new variable
00AE88  2               LAB_1D8B
00AE88  2  68           	PLA			; pop return address low byte
00AE89  2  48           	PHA			; push return address low byte
00AE8A  2               LAB_1C18p2	= LAB_1C18+2
00AE8A  2  C9 91        	CMP	#<LAB_1C18p2	; compare with expected calling routine return low byte
00AE8C  2  D0 05        	BNE	LAB_1D98	; if not get (var) go create new var
00AE8E  2               
00AE8E  2               ; This will only drop through if the call was from LAB_1C18 and is only called
00AE8E  2               ; from there if it is searching for a variable from the RHS of a LET a=b statement
00AE8E  2               ; it prevents the creation of variables not assigned a value.
00AE8E  2               
00AE8E  2               ; value returned by this is either numeric zero (exponent byte is $00) or null string
00AE8E  2               ; (descriptor length byte is $00). in fact a pointer to any $00 byte would have done.
00AE8E  2               
00AE8E  2               ; doing this saves 6 bytes of variable memory and 168 machine cycles of time
00AE8E  2               
00AE8E  2               ; this is where you would put the undefined variable error call e.g.
00AE8E  2               
00AE8E  2               ;				; variable doesn't exist so flag error
00AE8E  2  A2 24        	LDX	#$24		; error code $24 ("undefined variable" error)
00AE90  2  4C 4C A1     	JMP	LAB_XERR	; do error #X then warm start
00AE93  2               
00AE93  2               ; the above code has been tested and works a treat! (it replaces the three code lines
00AE93  2               ; below)
00AE93  2               
00AE93  2               ;				; else return dummy null value
00AE93  2               ;	LDA	#<LAB_1D96	; low byte point to $00,$00
00AE93  2               ;				; (uses part of misc constants table)
00AE93  2               ;	LDY	#>LAB_1D96	; high byte point to $00,$00
00AE93  2               ;	RTS
00AE93  2               
00AE93  2               				; create new numeric variable
00AE93  2               LAB_1D98
00AE93  2  A5 7D        	LDA	Sarryl		; get var mem end low byte
00AE95  2  A4 7E        	LDY	Sarryh		; get var mem end high byte
00AE97  2  85 AA        	STA	Ostrtl		; save old block start low byte
00AE99  2  84 AB        	STY	Ostrth		; save old block start high byte
00AE9B  2  A5 7F        	LDA	Earryl		; get array mem end low byte
00AE9D  2  A4 80        	LDY	Earryh		; get array mem end high byte
00AE9F  2  85 A6        	STA	Obendl		; save old block end low byte
00AEA1  2  84 A7        	STY	Obendh		; save old block end high byte
00AEA3  2  18           	CLC			; clear carry for add
00AEA4  2  69 06        	ADC	#$06		; +6 (space for one var)
00AEA6  2  90 01        	BCC	LAB_1DAE	; branch if no overflow to high byte
00AEA8  2               
00AEA8  2  C8           	INY			; else increment high byte
00AEA9  2               LAB_1DAE
00AEA9  2  85 A4        	STA	Nbendl		; set new block end low byte
00AEAB  2  84 A5        	STY	Nbendh		; set new block end high byte
00AEAD  2  20 CE A0     	JSR	LAB_11CF	; open up space in memory
00AEB0  2  A5 A4        	LDA	Nbendl		; get new start low byte
00AEB2  2  A4 A5        	LDY	Nbendh		; get new start high byte (-$100)
00AEB4  2  C8           	INY			; correct high byte
00AEB5  2  85 7D        	STA	Sarryl		; save new var mem end low byte
00AEB7  2  84 7E        	STY	Sarryh		; save new var mem end high byte
00AEB9  2  A0 00        	LDY	#$00		; clear index
00AEBB  2  A5 93        	LDA	Varnm1		; get var name 1st character
00AEBD  2  91 AA        	STA	(Vrschl),Y	; save var name 1st character
00AEBF  2  C8           	INY			; increment index
00AEC0  2  A5 94        	LDA	Varnm2		; get var name 2nd character
00AEC2  2  91 AA        	STA	(Vrschl),Y	; save var name 2nd character
00AEC4  2  A9 00        	LDA	#$00		; clear A
00AEC6  2  C8           	INY			; increment index
00AEC7  2  91 AA        	STA	(Vrschl),Y	; initialise var byte
00AEC9  2  C8           	INY			; increment index
00AECA  2  91 AA        	STA	(Vrschl),Y	; initialise var byte
00AECC  2  C8           	INY			; increment index
00AECD  2  91 AA        	STA	(Vrschl),Y	; initialise var byte
00AECF  2  C8           	INY			; increment index
00AED0  2  91 AA        	STA	(Vrschl),Y	; initialise var byte
00AED2  2               
00AED2  2               				; found a match for var ((Vrschl) = ptr)
00AED2  2               LAB_1DD7
00AED2  2  A5 AA        	LDA	Vrschl		; get var address low byte
00AED4  2  18           	CLC			; clear carry for add
00AED5  2  69 02        	ADC	#$02		; +2 (offset past var name bytes)
00AED7  2  A4 AB        	LDY	Vrschh		; get var address high byte
00AED9  2  90 01        	BCC	LAB_1DE1	; branch if no overflow from add
00AEDB  2               
00AEDB  2  C8           	INY			; else increment high byte
00AEDC  2               LAB_1DE1
00AEDC  2  85 95        	STA	Cvaral		; save current var address low byte
00AEDE  2  84 96        	STY	Cvarah		; save current var address high byte
00AEE0  2  60           	RTS
00AEE1  2               
00AEE1  2               ; set up array pointer (Adatal/h) to first element in array
00AEE1  2               ; set Adatal,Adatah to Astrtl,Astrth+2*Dimcnt+#$05
00AEE1  2               
00AEE1  2               LAB_1DE6
00AEE1  2  A5 5D        	LDA	Dimcnt		; get # of dimensions (1, 2 or 3)
00AEE3  2  0A           	ASL			; *2 (also clears the carry !)
00AEE4  2  69 05        	ADC	#$05		; +5 (result is 7, 9 or 11 here)
00AEE6  2  65 AA        	ADC	Astrtl		; add array start pointer low byte
00AEE8  2  A4 AB        	LDY	Astrth		; get array pointer high byte
00AEEA  2  90 01        	BCC	LAB_1DF2	; branch if no overflow
00AEEC  2               
00AEEC  2  C8           	INY			; else increment high byte
00AEED  2               LAB_1DF2
00AEED  2  85 A4        	STA	Adatal		; save array data pointer low byte
00AEEF  2  84 A5        	STY	Adatah		; save array data pointer high byte
00AEF1  2  60           	RTS
00AEF2  2               
00AEF2  2               ; evaluate integer expression
00AEF2  2               
00AEF2  2               LAB_EVIN
00AEF2  2  20 BC 00     	JSR	LAB_IGBY	; increment and scan memory
00AEF5  2  20 14 AB     	JSR	LAB_EVNM	; evaluate expression and check is numeric,
00AEF8  2               				; else do type mismatch
00AEF8  2               
00AEF8  2               ; evaluate integer expression (no check)
00AEF8  2               
00AEF8  2               LAB_EVPI
00AEF8  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
00AEFA  2  30 0D        	BMI	LAB_1E12	; do function call error if -ve
00AEFC  2               
00AEFC  2               ; evaluate integer expression (no sign check)
00AEFC  2               
00AEFC  2               LAB_EVIR
00AEFC  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00AEFE  2  C9 90        	CMP	#$90		; compare with exponent = 2^16 (n>2^15)
00AF00  2  90 09        	BCC	LAB_1E14	; branch if n<2^16 (is ok)
00AF02  2               
00AF02  2  A9 55        	LDA	#<LAB_1DF7	; set pointer low byte to -32768
00AF04  2  A0 C2        	LDY	#>LAB_1DF7	; set pointer high byte to -32768
00AF06  2  20 79 B9     	JSR	LAB_27F8	; compare FAC1 with (AY)
00AF09  2               LAB_1E12
00AF09  2  D0 74        	BNE	LAB_FCER	; if <> do function call error then warm start
00AF0B  2               
00AF0B  2               LAB_1E14
00AF0B  2  4C B2 B9     	JMP	LAB_2831	; convert FAC1 floating-to-fixed and return
00AF0E  2               
00AF0E  2               ; find or make array
00AF0E  2               
00AF0E  2               LAB_1E17
00AF0E  2  A5 5E        	LDA	Defdim		; get DIM flag
00AF10  2  48           	PHA			; push it
00AF11  2  A5 5F        	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
00AF13  2  48           	PHA			; push it
00AF14  2  A0 00        	LDY	#$00		; clear dimensions count
00AF16  2               
00AF16  2               ; now get the array dimension(s) and stack it (them) before the data type and DIM flag
00AF16  2               
00AF16  2               LAB_1E1F
00AF16  2  98           	TYA			; copy dimensions count
00AF17  2  48           	PHA			; save it
00AF18  2  A5 94        	LDA	Varnm2		; get array name 2nd byte
00AF1A  2  48           	PHA			; save it
00AF1B  2  A5 93        	LDA	Varnm1		; get array name 1st byte
00AF1D  2  48           	PHA			; save it
00AF1E  2  20 F2 AE     	JSR	LAB_EVIN	; evaluate integer expression
00AF21  2  68           	PLA			; pull array name 1st byte
00AF22  2  85 93        	STA	Varnm1		; restore array name 1st byte
00AF24  2  68           	PLA			; pull array name 2nd byte
00AF25  2  85 94        	STA	Varnm2		; restore array name 2nd byte
00AF27  2  68           	PLA			; pull dimensions count
00AF28  2  A8           	TAY			; restore it
00AF29  2  BA           	TSX			; copy stack pointer
00AF2A  2  BD 02 01     	LDA	LAB_STAK+2,X	; get DIM flag
00AF2D  2  48           	PHA			; push it
00AF2E  2  BD 01 01     	LDA	LAB_STAK+1,X	; get data type flag
00AF31  2  48           	PHA			; push it
00AF32  2  A5 AE        	LDA	FAC1_2		; get this dimension size high byte
00AF34  2  9D 02 01     	STA	LAB_STAK+2,X	; stack before flag bytes
00AF37  2  A5 AF        	LDA	FAC1_3		; get this dimension size low byte
00AF39  2  9D 01 01     	STA	LAB_STAK+1,X	; stack before flag bytes
00AF3C  2  C8           	INY			; increment dimensions count
00AF3D  2  20 C2 00     	JSR	LAB_GBYT	; scan memory
00AF40  2  C9 2C        	CMP	#','		; compare with ","
00AF42  2  F0 D2        	BEQ	LAB_1E1F	; if found go do next dimension
00AF44  2               
00AF44  2  84 5D        	STY	Dimcnt		; store dimensions count
00AF46  2  20 37 AC     	JSR	LAB_1BFB	; scan for ")" , else do syntax error then warm start
00AF49  2  68           	PLA			; pull data type flag
00AF4A  2  85 5F        	STA	Dtypef		; restore data type flag, $FF=string, $00=numeric
00AF4C  2  68           	PLA			; pull DIM flag
00AF4D  2  85 5E        	STA	Defdim		; restore DIM flag
00AF4F  2  A6 7D        	LDX	Sarryl		; get array mem start low byte
00AF51  2  A5 7E        	LDA	Sarryh		; get array mem start high byte
00AF53  2               
00AF53  2               ; now check to see if we are at the end of array memory (we would be if there were
00AF53  2               ; no arrays).
00AF53  2               
00AF53  2               LAB_1E5C
00AF53  2  86 AA        	STX	Astrtl		; save as array start pointer low byte
00AF55  2  85 AB        	STA	Astrth		; save as array start pointer high byte
00AF57  2  C5 80        	CMP	Earryh		; compare with array mem end high byte
00AF59  2  D0 04        	BNE	LAB_1E68	; branch if not reached array mem end
00AF5B  2               
00AF5B  2  E4 7F        	CPX	Earryl		; else compare with array mem end low byte
00AF5D  2  F0 39        	BEQ	LAB_1EA1	; go build array if not found
00AF5F  2               
00AF5F  2               				; search for array
00AF5F  2               LAB_1E68
00AF5F  2  A0 00        	LDY	#$00		; clear index
00AF61  2  B1 AA        	LDA	(Astrtl),Y	; get array name first byte
00AF63  2  C8           	INY			; increment index to second name byte
00AF64  2  C5 93        	CMP	Varnm1		; compare with this array name first byte
00AF66  2  D0 06        	BNE	LAB_1E77	; branch if no match
00AF68  2               
00AF68  2  A5 94        	LDA	Varnm2		; else get this array name second byte
00AF6A  2  D1 AA        	CMP	(Astrtl),Y	; compare with array name second byte
00AF6C  2  F0 16        	BEQ	LAB_1E8D	; array found so branch
00AF6E  2               
00AF6E  2               				; no match
00AF6E  2               LAB_1E77
00AF6E  2  C8           	INY			; increment index
00AF6F  2  B1 AA        	LDA	(Astrtl),Y	; get array size low byte
00AF71  2  18           	CLC			; clear carry for add
00AF72  2  65 AA        	ADC	Astrtl		; add array start pointer low byte
00AF74  2  AA           	TAX			; copy low byte to X
00AF75  2  C8           	INY			; increment index
00AF76  2  B1 AA        	LDA	(Astrtl),Y	; get array size high byte
00AF78  2  65 AB        	ADC	Astrth		; add array mem pointer high byte
00AF7A  2  90 D7        	BCC	LAB_1E5C	; if no overflow go check next array
00AF7C  2               
00AF7C  2               ; do array bounds error
00AF7C  2               
00AF7C  2               LAB_1E85
00AF7C  2  A2 10        	LDX	#$10		; error code $10 ("Array bounds" error)
00AF7E  2  2C           	.byte	$2C		; makes next bit BIT LAB_08A2
00AF7F  2               
00AF7F  2               ; do function call error
00AF7F  2               
00AF7F  2               LAB_FCER
00AF7F  2  A2 08        	LDX	#$08		; error code $08 ("Function call" error)
00AF81  2               LAB_1E8A
00AF81  2  4C 4C A1     	JMP	LAB_XERR	; do error #X, then warm start
00AF84  2               
00AF84  2               				; found array, are we trying to dimension it?
00AF84  2               LAB_1E8D
00AF84  2  A2 12        	LDX	#$12		; set error $12 ("Double dimension" error)
00AF86  2  A5 5E        	LDA	Defdim		; get DIM flag
00AF88  2  D0 F7        	BNE	LAB_1E8A	; if we are trying to dimension it do error #X, then warm
00AF8A  2               				; start
00AF8A  2               
00AF8A  2               ; found the array and we're not dimensioning it so we must find an element in it
00AF8A  2               
00AF8A  2  20 E1 AE     	JSR	LAB_1DE6	; set-up array pointer (Adatal/h) to first element in array
00AF8D  2               				; (Astrtl,Astrth points to start of array)
00AF8D  2  A5 5D        	LDA	Dimcnt		; get dimensions count
00AF8F  2  A0 04        	LDY	#$04		; set index to array's # of dimensions
00AF91  2  D1 AA        	CMP	(Astrtl),Y	; compare with no of dimensions
00AF93  2  D0 E7        	BNE	LAB_1E85	; if wrong do array bounds error, could do "Wrong
00AF95  2               				; dimensions" error here .. if we want a different
00AF95  2               				; error message
00AF95  2               
00AF95  2  4C 1B B0     	JMP	LAB_1F28	; found array so go get element
00AF98  2               				; (could jump to LAB_1F28 as all LAB_1F24 does is take
00AF98  2               				; Dimcnt and save it at (Astrtl),Y which is already the
00AF98  2               				; same or we would have taken the BNE)
00AF98  2               
00AF98  2               				; array not found, so build it
00AF98  2               LAB_1EA1
00AF98  2  20 E1 AE     	JSR	LAB_1DE6	; set up array pointer (Adatal/h) to first element in array
00AF9B  2               				; (Astrtl,Astrth points to start of array)
00AF9B  2  20 1B A1     	JSR	LAB_121F	; check available memory, "Out of memory" error if no room
00AF9E  2               				; addr to check is in AY (low/high)
00AF9E  2  A0 00        	LDY	#$00		; clear Y (don't need to clear A)
00AFA0  2  84 BB        	STY	Aspth		; clear array data size high byte
00AFA2  2  A5 93        	LDA	Varnm1		; get variable name 1st byte
00AFA4  2  91 AA        	STA	(Astrtl),Y	; save array name 1st byte
00AFA6  2  C8           	INY			; increment index
00AFA7  2  A5 94        	LDA	Varnm2		; get variable name 2nd byte
00AFA9  2  91 AA        	STA	(Astrtl),Y	; save array name 2nd byte
00AFAB  2  A5 5D        	LDA	Dimcnt		; get dimensions count
00AFAD  2  A0 04        	LDY	#$04		; index to dimension count
00AFAF  2  84 BA        	STY	Asptl		; set array data size low byte (four bytes per element)
00AFB1  2  91 AA        	STA	(Astrtl),Y	; set array's dimensions count
00AFB3  2               
00AFB3  2               				; now calculate the size of the data space for the array
00AFB3  2  18           	CLC			; clear carry for add (clear on subsequent loops)
00AFB4  2               LAB_1EC0
00AFB4  2  A2 0B        	LDX	#$0B		; set default dimension value low byte
00AFB6  2  A9 00        	LDA	#$00		; set default dimension value high byte
00AFB8  2  24 5E        	BIT	Defdim		; test default DIM flag
00AFBA  2  50 07        	BVC	LAB_1ED0	; branch if b6 of Defdim is clear
00AFBC  2               
00AFBC  2  68           	PLA			; else pull dimension value low byte
00AFBD  2  69 01        	ADC	#$01		; +1 (allow for zeroeth element)
00AFBF  2  AA           	TAX			; copy low byte to X
00AFC0  2  68           	PLA			; pull dimension value high byte
00AFC1  2  69 00        	ADC	#$00		; add carry from low byte
00AFC3  2               
00AFC3  2               LAB_1ED0
00AFC3  2  C8           	INY			; index to dimension value high byte
00AFC4  2  91 AA        	STA	(Astrtl),Y	; save dimension value high byte
00AFC6  2  C8           	INY			; index to dimension value high byte
00AFC7  2  8A           	TXA			; get dimension value low byte
00AFC8  2  91 AA        	STA	(Astrtl),Y	; save dimension value low byte
00AFCA  2  20 6A B0     	JSR	LAB_1F7C	; does XY = (Astrtl),Y * (Asptl)
00AFCD  2  86 BA        	STX	Asptl		; save array data size low byte
00AFCF  2  85 BB        	STA	Aspth		; save array data size high byte
00AFD1  2  A4 71        	LDY	ut1_pl		; restore index (saved by subroutine)
00AFD3  2  C6 5D        	DEC	Dimcnt		; decrement dimensions count
00AFD5  2  D0 DD        	BNE	LAB_1EC0	; loop while not = 0
00AFD7  2               
00AFD7  2  65 A5        	ADC	Adatah		; add size high byte to first element high byte
00AFD9  2               				; (carry is always clear here)
00AFD9  2  B0 5D        	BCS	LAB_1F45	; if overflow go do "Out of memory" error
00AFDB  2               
00AFDB  2  85 A5        	STA	Adatah		; save end of array high byte
00AFDD  2  A8           	TAY			; copy end high byte to Y
00AFDE  2  8A           	TXA			; get array size low byte
00AFDF  2  65 A4        	ADC	Adatal		; add array start low byte
00AFE1  2  90 03        	BCC	LAB_1EF3	; branch if no carry
00AFE3  2               
00AFE3  2  C8           	INY			; else increment end of array high byte
00AFE4  2  F0 52        	BEQ	LAB_1F45	; if overflow go do "Out of memory" error
00AFE6  2               
00AFE6  2               				; set-up mostly complete, now zero the array
00AFE6  2               LAB_1EF3
00AFE6  2  20 1B A1     	JSR	LAB_121F	; check available memory, "Out of memory" error if no room
00AFE9  2               				; addr to check is in AY (low/high)
00AFE9  2  85 7F        	STA	Earryl		; save array mem end low byte
00AFEB  2  84 80        	STY	Earryh		; save array mem end high byte
00AFED  2  A9 00        	LDA	#$00		; clear byte for array clear
00AFEF  2  E6 BB        	INC	Aspth		; increment array size high byte (now block count)
00AFF1  2  A4 BA        	LDY	Asptl		; get array size low byte (now index to block)
00AFF3  2  F0 05        	BEQ	LAB_1F07	; branch if low byte = $00
00AFF5  2               
00AFF5  2               LAB_1F02
00AFF5  2  88           	DEY			; decrement index (do 0 to n-1)
00AFF6  2  91 A4        	STA	(Adatal),Y	; zero byte
00AFF8  2  D0 FB        	BNE	LAB_1F02	; loop until this block done
00AFFA  2               
00AFFA  2               LAB_1F07
00AFFA  2  C6 A5        	DEC	Adatah		; decrement array pointer high byte
00AFFC  2  C6 BB        	DEC	Aspth		; decrement block count high byte
00AFFE  2  D0 F5        	BNE	LAB_1F02	; loop until all blocks done
00B000  2               
00B000  2  E6 A5        	INC	Adatah		; correct for last loop
00B002  2  38           	SEC			; set carry for subtract
00B003  2  A0 02        	LDY	#$02		; index to array size low byte
00B005  2  A5 7F        	LDA	Earryl		; get array mem end low byte
00B007  2  E5 AA        	SBC	Astrtl		; subtract array start low byte
00B009  2  91 AA        	STA	(Astrtl),Y	; save array size low byte
00B00B  2  C8           	INY			; index to array size high byte
00B00C  2  A5 80        	LDA	Earryh		; get array mem end high byte
00B00E  2  E5 AB        	SBC	Astrth		; subtract array start high byte
00B010  2  91 AA        	STA	(Astrtl),Y	; save array size high byte
00B012  2  A5 5E        	LDA	Defdim		; get default DIM flag
00B014  2  D0 53        	BNE	LAB_1F7B	; exit (RET) if this was a DIM command
00B016  2               
00B016  2               				; else, find element
00B016  2  C8           	INY			; index to # of dimensions
00B017  2               
00B017  2               LAB_1F24
00B017  2  B1 AA        	LDA	(Astrtl),Y	; get array's dimension count
00B019  2  85 5D        	STA	Dimcnt		; save it
00B01B  2               
00B01B  2               ; we have found, or built, the array. now we need to find the element
00B01B  2               
00B01B  2               LAB_1F28
00B01B  2  A9 00        	LDA	#$00		; clear byte
00B01D  2  85 BA        	STA	Asptl		; clear array data pointer low byte
00B01F  2               LAB_1F2C
00B01F  2  85 BB        	STA	Aspth		; save array data pointer high byte
00B021  2  C8           	INY			; increment index (point to array bound high byte)
00B022  2  68           	PLA			; pull array index low byte
00B023  2  AA           	TAX			; copy to X
00B024  2  85 AE        	STA	FAC1_2		; save index low byte to FAC1 mantissa2
00B026  2  68           	PLA			; pull array index high byte
00B027  2  85 AF        	STA	FAC1_3		; save index high byte to FAC1 mantissa3
00B029  2  D1 AA        	CMP	(Astrtl),Y	; compare with array bound high byte
00B02B  2  90 0E        	BCC	LAB_1F48	; branch if within bounds
00B02D  2               
00B02D  2  D0 06        	BNE	LAB_1F42	; if outside bounds do array bounds error
00B02F  2               
00B02F  2               				; else high byte was = so test low bytes
00B02F  2  C8           	INY			; index to array bound low byte
00B030  2  8A           	TXA			; get array index low byte
00B031  2  D1 AA        	CMP	(Astrtl),Y	; compare with array bound low byte
00B033  2  90 07        	BCC	LAB_1F49	; branch if within bounds
00B035  2               
00B035  2               LAB_1F42
00B035  2  4C 7C AF     	JMP	LAB_1E85	; else do array bounds error
00B038  2               
00B038  2               LAB_1F45
00B038  2  4C 4A A1     	JMP	LAB_OMER	; do "Out of memory" error then warm start
00B03B  2               
00B03B  2               LAB_1F48
00B03B  2  C8           	INY			; index to array bound low byte
00B03C  2               LAB_1F49
00B03C  2  A5 BB        	LDA	Aspth		; get array data pointer high byte
00B03E  2  05 BA        	ORA	Asptl		; OR with array data pointer low byte
00B040  2  F0 0A        	BEQ	LAB_1F5A	; branch if array data pointer = null (skip multiply)
00B042  2               
00B042  2  20 6A B0     	JSR	LAB_1F7C	; does XY = (Astrtl),Y * (Asptl)
00B045  2  8A           	TXA			; get result low byte
00B046  2  65 AE        	ADC	FAC1_2		; add index low byte from FAC1 mantissa2
00B048  2  AA           	TAX			; save result low byte
00B049  2  98           	TYA			; get result high byte
00B04A  2  A4 71        	LDY	ut1_pl		; restore index
00B04C  2               LAB_1F5A
00B04C  2  65 AF        	ADC	FAC1_3		; add index high byte from FAC1 mantissa3
00B04E  2  86 BA        	STX	Asptl		; save array data pointer low byte
00B050  2  C6 5D        	DEC	Dimcnt		; decrement dimensions count
00B052  2  D0 CB        	BNE	LAB_1F2C	; loop if dimensions still to do
00B054  2               
00B054  2  06 BA        	ASL	Asptl		; array data pointer low byte * 2
00B056  2  2A           	ROL			; array data pointer high byte * 2
00B057  2  06 BA        	ASL	Asptl		; array data pointer low byte * 4
00B059  2  2A           	ROL			; array data pointer high byte * 4
00B05A  2  A8           	TAY			; copy high byte
00B05B  2  A5 BA        	LDA	Asptl		; get low byte
00B05D  2  65 A4        	ADC	Adatal		; add array data start pointer low byte
00B05F  2  85 95        	STA	Cvaral		; save as current var address low byte
00B061  2  98           	TYA			; get high byte back
00B062  2  65 A5        	ADC	Adatah		; add array data start pointer high byte
00B064  2  85 96        	STA	Cvarah		; save as current var address high byte
00B066  2  A8           	TAY			; copy high byte to Y
00B067  2  A5 95        	LDA	Cvaral		; get current var address low byte
00B069  2               LAB_1F7B
00B069  2  60           	RTS
00B06A  2               
00B06A  2               ; does XY = (Astrtl),Y * (Asptl)
00B06A  2               
00B06A  2               LAB_1F7C
00B06A  2  84 71        	STY	ut1_pl		; save index
00B06C  2  B1 AA        	LDA	(Astrtl),Y	; get dimension size low byte
00B06E  2  85 76        	STA	dims_l		; save dimension size low byte
00B070  2  88           	DEY			; decrement index
00B071  2  B1 AA        	LDA	(Astrtl),Y	; get dimension size high byte
00B073  2  85 77        	STA	dims_h		; save dimension size high byte
00B075  2               
00B075  2  A9 10        	LDA	#$10		; count = $10 (16 bit multiply)
00B077  2  85 A8        	STA	numbit		; save bit count
00B079  2  A2 00        	LDX	#$00		; clear result low byte
00B07B  2  A0 00        	LDY	#$00		; clear result high byte
00B07D  2               LAB_1F8F
00B07D  2  8A           	TXA			; get result low byte
00B07E  2  0A           	ASL			; *2
00B07F  2  AA           	TAX			; save result low byte
00B080  2  98           	TYA			; get result high byte
00B081  2  2A           	ROL			; *2
00B082  2  A8           	TAY			; save result high byte
00B083  2  B0 B3        	BCS	LAB_1F45	; if overflow go do "Out of memory" error
00B085  2               
00B085  2  06 BA        	ASL	Asptl		; shift multiplier low byte
00B087  2  26 BB        	ROL	Aspth		; shift multiplier high byte
00B089  2  90 0B        	BCC	LAB_1FA8	; skip add if no carry
00B08B  2               
00B08B  2  18           	CLC			; else clear carry for add
00B08C  2  8A           	TXA			; get result low byte
00B08D  2  65 76        	ADC	dims_l		; add dimension size low byte
00B08F  2  AA           	TAX			; save result low byte
00B090  2  98           	TYA			; get result high byte
00B091  2  65 77        	ADC	dims_h		; add dimension size high byte
00B093  2  A8           	TAY			; save result high byte
00B094  2  B0 A2        	BCS	LAB_1F45	; if overflow go do "Out of memory" error
00B096  2               
00B096  2               LAB_1FA8
00B096  2  C6 A8        	DEC	numbit		; decrement bit count
00B098  2  D0 E3        	BNE	LAB_1F8F	; loop until all done
00B09A  2               
00B09A  2  60           	RTS
00B09B  2               
00B09B  2               ; perform FRE()
00B09B  2               LAB_FRE
00B09B  2  A5 5F        	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
00B09D  2  10 03        	BPL	LAB_1FB4	; branch if numeric
00B09F  2               
00B09F  2  20 97 B3     	JSR	LAB_22B6	; pop string off descriptor stack, or from top of string
00B0A2  2               				; space returns with A = length, X=$71=pointer low byte,
00B0A2  2               				; Y=$72=pointer high byte
00B0A2  2               
00B0A2  2               				; FRE(n) was numeric so do this
00B0A2  2               LAB_1FB4
00B0A2  2  20 34 B2     	JSR	LAB_GARB	; go to garbage collection
00B0A5  2  38           	SEC			; set carry for subtract
00B0A6  2  A5 81        	LDA	Sstorl		; get bottom of string space low byte
00B0A8  2  E5 7F        	SBC	Earryl		; subtract array mem end low byte
00B0AA  2  A8           	TAY			; copy result to Y
00B0AB  2  A5 82        	LDA	Sstorh		; get bottom of string space high byte
00B0AD  2  E5 80        	SBC	Earryh		; subtract array mem end high byte
00B0AF  2               
00B0AF  2               ; save and convert integer AY to FAC1
00B0AF  2               
00B0AF  2               LAB_AYFC
00B0AF  2  46 5F        	LSR	Dtypef		; clear data type flag, $FF=string, $00=numeric
00B0B1  2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
00B0B3  2  84 AE        	STY	FAC1_2		; save FAC1 mantissa2
00B0B5  2  A2 90        	LDX	#$90		; set exponent=2^16 (integer)
00B0B7  2  38           	SEC			; set exp=X, clear FAC1_3, normalise and return
00B0B8  2  4C 69 B9     	JMP	LAB_STFA	; ensure number returned as unsigned
00B0BB  2               
00B0BB  2               ; perform POS()
00B0BB  2               
00B0BB  2               LAB_POS
00B0BB  2  A4 0E        	LDY	TPos		; get terminal position
00B0BD  2               
00B0BD  2               ; convert Y to byte in FAC1
00B0BD  2               
00B0BD  2               LAB_1FD0
00B0BD  2  A9 00        	LDA	#$00		; clear high byte
00B0BF  2  F0 EE        	BEQ	LAB_AYFC	; always save and convert integer AY to FAC1 and return
00B0C1  2               
00B0C1  2               ; check not Direct (used by DEF and INPUT)
00B0C1  2               
00B0C1  2               LAB_CKRN
00B0C1  2  A6 88        	LDX	Clineh		; get current line high byte
00B0C3  2  E8           	INX			; increment it
00B0C4  2  D0 A3        	BNE	LAB_1F7B	; return if can continue not direct mode
00B0C6  2               
00B0C6  2               				; else do illegal direct error
00B0C6  2               LAB_1FD9
00B0C6  2  A2 16        	LDX	#$16		; error code $16 ("Illegal direct" error)
00B0C8  2               LAB_1FDB
00B0C8  2  4C 4C A1     	JMP	LAB_XERR	; go do error #X, then warm start
00B0CB  2               
00B0CB  2               ; perform DEF
00B0CB  2               
00B0CB  2               LAB_DEF
00B0CB  2  20 FC B0     	JSR	LAB_200B	; check FNx syntax
00B0CE  2  85 9C        	STA	func_l		; save function pointer low byte
00B0D0  2  84 9D        	STY	func_h		; save function pointer high byte
00B0D2  2  20 C1 B0     	JSR	LAB_CKRN	; check not Direct (back here if ok)
00B0D5  2  20 42 AC     	JSR	LAB_1BFE	; scan for "(" , else do syntax error then warm start
00B0D8  2  A9 80        	LDA	#$80		; set flag for FNx
00B0DA  2  85 61        	STA	Sufnxf		; save subscript/FNx flag
00B0DC  2  20 00 AE     	JSR	LAB_GVAR	; get (var) address
00B0DF  2  20 17 AB     	JSR	LAB_CTNM	; check if source is numeric, else do type mismatch
00B0E2  2  20 37 AC     	JSR	LAB_1BFB	; scan for ")" , else do syntax error then warm start
00B0E5  2  A9 D8        	LDA	#TK_EQUAL	; get = token
00B0E7  2  20 39 AC     	JSR	LAB_SCCA	; scan for CHR$(A), else do syntax error then warm start
00B0EA  2  A5 96        	LDA	Cvarah		; get current var address high byte
00B0EC  2  48           	PHA			; push it
00B0ED  2  A5 95        	LDA	Cvaral		; get current var address low byte
00B0EF  2  48           	PHA			; push it
00B0F0  2  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
00B0F2  2  48           	PHA			; push it
00B0F3  2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
00B0F5  2  48           	PHA			; push it
00B0F6  2  20 D5 A6     	JSR	LAB_DATA	; go perform DATA
00B0F9  2  4C 6B B1     	JMP	LAB_207A	; put execute pointer and variable pointer into function
00B0FC  2               				; and return
00B0FC  2               
00B0FC  2               ; check FNx syntax
00B0FC  2               
00B0FC  2               LAB_200B
00B0FC  2  A9 C5        	LDA	#TK_FN		; get "FN" token
00B0FE  2  20 39 AC     	JSR	LAB_SCCA	; scan for CHR$(A), else do syntax error then warm start
00B101  2               				; return character after A
00B101  2  09 80        	ORA	#$80		; set FN flag bit
00B103  2  85 61        	STA	Sufnxf		; save FN flag so array variable test fails
00B105  2  20 07 AE     	JSR	LAB_1D12	; search for FN variable
00B108  2  4C 17 AB     	JMP	LAB_CTNM	; check if source is numeric and return, else do type
00B10B  2               				; mismatch
00B10B  2               
00B10B  2               				; Evaluate FNx
00B10B  2               LAB_201E
00B10B  2  20 FC B0     	JSR	LAB_200B	; check FNx syntax
00B10E  2  48           	PHA			; push function pointer low byte
00B10F  2  98           	TYA			; copy function pointer high byte
00B110  2  48           	PHA			; push function pointer high byte
00B111  2  20 42 AC     	JSR	LAB_1BFE	; scan for "(", else do syntax error then warm start
00B114  2  20 28 AB     	JSR	LAB_EVEX	; evaluate expression
00B117  2  20 37 AC     	JSR	LAB_1BFB	; scan for ")", else do syntax error then warm start
00B11A  2  20 17 AB     	JSR	LAB_CTNM	; check if source is numeric, else do type mismatch
00B11D  2  68           	PLA			; pop function pointer high byte
00B11E  2  85 9D        	STA	func_h		; restore it
00B120  2  68           	PLA			; pop function pointer low byte
00B121  2  85 9C        	STA	func_l		; restore it
00B123  2  A2 20        	LDX	#$20		; error code $20 ("Undefined function" error)
00B125  2  A0 03        	LDY	#$03		; index to variable pointer high byte
00B127  2  B1 9C        	LDA	(func_l),Y	; get variable pointer high byte
00B129  2  F0 9D        	BEQ	LAB_1FDB	; if zero go do undefined function error
00B12B  2               
00B12B  2  85 96        	STA	Cvarah		; save variable address high byte
00B12D  2  88           	DEY			; index to variable address low byte
00B12E  2  B1 9C        	LDA	(func_l),Y	; get variable address low byte
00B130  2  85 95        	STA	Cvaral		; save variable address low byte
00B132  2  AA           	TAX			; copy address low byte
00B133  2               
00B133  2               				; now stack the function variable value before use
00B133  2  C8           	INY			; index to mantissa_3
00B134  2               LAB_2043
00B134  2  B1 95        	LDA	(Cvaral),Y	; get byte from variable
00B136  2  48           	PHA			; stack it
00B137  2  88           	DEY			; decrement index
00B138  2  10 FA        	BPL	LAB_2043	; loop until variable stacked
00B13A  2               
00B13A  2  A4 96        	LDY	Cvarah		; get variable address high byte
00B13C  2  20 09 B9     	JSR	LAB_2778	; pack FAC1 (function expression value) into (XY)
00B13F  2               				; (function variable), return Y=0, always
00B13F  2  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
00B141  2  48           	PHA			; push it
00B142  2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
00B144  2  48           	PHA			; push it
00B145  2  B1 9C        	LDA	(func_l),Y	; get function execute pointer low byte
00B147  2  85 C3        	STA	Bpntrl		; save as BASIC execute pointer low byte
00B149  2  C8           	INY			; index to high byte
00B14A  2  B1 9C        	LDA	(func_l),Y	; get function execute pointer high byte
00B14C  2  85 C4        	STA	Bpntrh		; save as BASIC execute pointer high byte
00B14E  2  A5 96        	LDA	Cvarah		; get variable address high byte
00B150  2  48           	PHA			; push it
00B151  2  A5 95        	LDA	Cvaral		; get variable address low byte
00B153  2  48           	PHA			; push it
00B154  2  20 14 AB     	JSR	LAB_EVNM	; evaluate expression and check is numeric,
00B157  2               				; else do type mismatch
00B157  2  68           	PLA			; pull variable address low byte
00B158  2  85 9C        	STA	func_l		; save variable address low byte
00B15A  2  68           	PLA			; pull variable address high byte
00B15B  2  85 9D        	STA	func_h		; save variable address high byte
00B15D  2  20 C2 00     	JSR	LAB_GBYT	; scan memory
00B160  2  F0 03        	BEQ	LAB_2074	; branch if null (should be [EOL] marker)
00B162  2               
00B162  2  4C 4A AC     	JMP	LAB_SNER	; else syntax error then warm start
00B165  2               
00B165  2               ; restore Bpntrl,Bpntrh and function variable from stack
00B165  2               
00B165  2               LAB_2074
00B165  2  68           	PLA			; pull BASIC execute pointer low byte
00B166  2  85 C3        	STA	Bpntrl		; restore BASIC execute pointer low byte
00B168  2  68           	PLA			; pull BASIC execute pointer high byte
00B169  2  85 C4        	STA	Bpntrh		; restore BASIC execute pointer high byte
00B16B  2               
00B16B  2               ; put execute pointer and variable pointer into function
00B16B  2               
00B16B  2               LAB_207A
00B16B  2  A0 00        	LDY	#$00		; clear index
00B16D  2  68           	PLA			; pull BASIC execute pointer low byte
00B16E  2  91 9C        	STA	(func_l),Y	; save to function
00B170  2  C8           	INY			; increment index
00B171  2  68           	PLA			; pull BASIC execute pointer high byte
00B172  2  91 9C        	STA	(func_l),Y	; save to function
00B174  2  C8           	INY			; increment index
00B175  2  68           	PLA			; pull current var address low byte
00B176  2  91 9C        	STA	(func_l),Y	; save to function
00B178  2  C8           	INY			; increment index
00B179  2  68           	PLA			; pull current var address high byte
00B17A  2  91 9C        	STA	(func_l),Y	; save to function
00B17C  2  60           	RTS
00B17D  2               
00B17D  2               ; perform STR$()
00B17D  2               
00B17D  2               LAB_STRS
00B17D  2  20 17 AB     	JSR	LAB_CTNM	; check if source is numeric, else do type mismatch
00B180  2  20 F7 BA     	JSR	LAB_296E	; convert FAC1 to string, returns YA=>string
00B183  2               ;	LDA	#<Decssp1	; set result string low pointer
00B183  2               ;	LDY	#>Decssp1	; set result string high pointer
00B183  2  F0 12        	BEQ	LAB_20AE	; print null terminated string to Sutill/Sutilh
00B185  2               
00B185  2               ; Do string vector
00B185  2               ; copy des_pl/h to des_2l/h and make string space A bytes long
00B185  2               
00B185  2               LAB_209C
00B185  2  A6 AE        	LDX	des_pl		; get descriptor pointer low byte
00B187  2  A4 AF        	LDY	des_ph		; get descriptor pointer high byte
00B189  2  86 9E        	STX	des_2l		; save descriptor pointer low byte
00B18B  2  84 9F        	STY	des_2h		; save descriptor pointer high byte
00B18D  2               
00B18D  2               ; make string space A bytes long
00B18D  2               ; A=length, X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
00B18D  2               
00B18D  2               LAB_MSSP
00B18D  2  20 02 B2     	JSR	LAB_2115	; make space in string memory for string A long
00B190  2               				; return X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
00B190  2  86 AD        	STX	str_pl		; save string pointer low byte
00B192  2  84 AE        	STY	str_ph		; save string pointer high byte
00B194  2  85 AC        	STA	str_ln		; save length
00B196  2  60           	RTS
00B197  2               
00B197  2               ; Scan, set up string
00B197  2               ; print " terminated string to Sutill/Sutilh
00B197  2               
00B197  2               LAB_20AE
00B197  2  A2 22        	LDX	#$22		; set terminator to "
00B199  2  86 5B        	STX	Srchc		; set search character (terminator 1)
00B19B  2  86 5C        	STX	Asrch		; set terminator 2
00B19D  2               
00B19D  2               ; print [Srchc] or [Asrch] terminated string to Sutill/Sutilh
00B19D  2               ; source is AY
00B19D  2               
00B19D  2               LAB_20B4
00B19D  2  85 B8        	STA	ssptr_l		; store string start low byte
00B19F  2  84 B9        	STY	ssptr_h		; store string start high byte
00B1A1  2  85 AD        	STA	str_pl		; save string pointer low byte
00B1A3  2  84 AE        	STY	str_ph		; save string pointer high byte
00B1A5  2  A0 FF        	LDY	#$FF		; set length to -1
00B1A7  2               LAB_20BE
00B1A7  2  C8           	INY			; increment length
00B1A8  2  B1 B8        	LDA	(ssptr_l),Y	; get byte from string
00B1AA  2  F0 0C        	BEQ	LAB_20CF	; exit loop if null byte [EOS]
00B1AC  2               
00B1AC  2  C5 5B        	CMP	Srchc		; compare with search character (terminator 1)
00B1AE  2  F0 04        	BEQ	LAB_20CB	; branch if terminator
00B1B0  2               
00B1B0  2  C5 5C        	CMP	Asrch		; compare with terminator 2
00B1B2  2  D0 F3        	BNE	LAB_20BE	; loop if not terminator 2
00B1B4  2               
00B1B4  2               LAB_20CB
00B1B4  2  C9 22        	CMP	#$22		; compare with "
00B1B6  2  F0 01        	BEQ	LAB_20D0	; branch if " (carry set if = !)
00B1B8  2               
00B1B8  2               LAB_20CF
00B1B8  2  18           	CLC			; clear carry for add (only if [EOL] terminated string)
00B1B9  2               LAB_20D0
00B1B9  2  84 AC        	STY	str_ln		; save length in FAC1 exponent
00B1BB  2  98           	TYA			; copy length to A
00B1BC  2  65 B8        	ADC	ssptr_l		; add string start low byte
00B1BE  2  85 BA        	STA	Sendl		; save string end low byte
00B1C0  2  A6 B9        	LDX	ssptr_h		; get string start high byte
00B1C2  2  90 01        	BCC	LAB_20DC	; branch if no low byte overflow
00B1C4  2               
00B1C4  2  E8           	INX			; else increment high byte
00B1C5  2               LAB_20DC
00B1C5  2  86 BB        	STX	Sendh		; save string end high byte
00B1C7  2  A5 B9        	LDA	ssptr_h		; get string start high byte
00B1C9  2               ; *** begin RAM above code / Ibuff above EhBASIC patch V2 ***
00B1C9  2               ; *** replace
00B1C9  2               ;	CMP	#>Ram_base	; compare with start of program memory
00B1C9  2               ;	BCS	LAB_RTST	; branch if not in utility area
00B1C9  2               ; *** with
00B1C9  2  F0 04        	BEQ	LAB_MVST	; fix STR$() using page zero via LAB_296E
00B1CB  2  C9 00        	CMP	#>Ibuffs	; compare with location of input buffer page
00B1CD  2  D0 0B        	BNE	LAB_RTST	; branch if not in utility area
00B1CF  2               LAB_MVST
00B1CF  2               ; *** end   RAM above code / Ibuff above EhBASIC patch V2 ***
00B1CF  2               
00B1CF  2               				; string in utility area, move to string memory
00B1CF  2  98           	TYA			; copy length to A
00B1D0  2  20 85 B1     	JSR	LAB_209C	; copy des_pl/h to des_2l/h and make string space A bytes
00B1D3  2               				; long
00B1D3  2  A6 B8        	LDX	ssptr_l		; get string start low byte
00B1D5  2  A4 B9        	LDY	ssptr_h		; get string start high byte
00B1D7  2  20 78 B3     	JSR	LAB_2298	; store string A bytes long from XY to (Sutill)
00B1DA  2               
00B1DA  2               ; check for space on descriptor stack then ..
00B1DA  2               ; put string address and length on descriptor stack and update stack pointers
00B1DA  2               
00B1DA  2               LAB_RTST
00B1DA  2  A6 65        	LDX	next_s		; get string stack pointer
00B1DC  2  E0 71        	CPX	#des_sk+$09	; compare with max+1
00B1DE  2  D0 05        	BNE	LAB_20F8	; branch if space on string stack
00B1E0  2               
00B1E0  2               				; else do string too complex error
00B1E0  2  A2 1C        	LDX	#$1C		; error code $1C ("String too complex" error)
00B1E2  2               LAB_20F5
00B1E2  2  4C 4C A1     	JMP	LAB_XERR	; do error #X, then warm start
00B1E5  2               
00B1E5  2               ; put string address and length on descriptor stack and update stack pointers
00B1E5  2               
00B1E5  2               LAB_20F8
00B1E5  2  A5 AC        	LDA	str_ln		; get string length
00B1E7  2  95 00        	STA	PLUS_0,X	; put on string stack
00B1E9  2  A5 AD        	LDA	str_pl		; get string pointer low byte
00B1EB  2  95 01        	STA	PLUS_1,X	; put on string stack
00B1ED  2  A5 AE        	LDA	str_ph		; get string pointer high byte
00B1EF  2  95 02        	STA	PLUS_2,X	; put on string stack
00B1F1  2  A0 00        	LDY	#$00		; clear Y
00B1F3  2  86 AE        	STX	des_pl		; save string descriptor pointer low byte
00B1F5  2  84 AF        	STY	des_ph		; save string descriptor pointer high byte (always $00)
00B1F7  2  88           	DEY			; Y = $FF
00B1F8  2  84 5F        	STY	Dtypef		; save data type flag, $FF=string
00B1FA  2  86 66        	STX	last_sl		; save old stack pointer (current top item)
00B1FC  2  E8           	INX			; update stack pointer
00B1FD  2  E8           	INX			; update stack pointer
00B1FE  2  E8           	INX			; update stack pointer
00B1FF  2  86 65        	STX	next_s		; save new top item value
00B201  2  60           	RTS
00B202  2               
00B202  2               ; Build descriptor
00B202  2               ; make space in string memory for string A long
00B202  2               ; return X=Sutill=ptr low byte, Y=Sutill=ptr high byte
00B202  2               
00B202  2               LAB_2115
00B202  2  46 60        	LSR	Gclctd		; clear garbage collected flag (b7)
00B204  2               
00B204  2               				; make space for string A long
00B204  2               LAB_2117
00B204  2  48           	PHA			; save string length
00B205  2  49 FF        	EOR	#$FF		; complement it
00B207  2  38           	SEC			; set carry for subtract (twos comp add)
00B208  2  65 81        	ADC	Sstorl		; add bottom of string space low byte (subtract length)
00B20A  2  A4 82        	LDY	Sstorh		; get bottom of string space high byte
00B20C  2  B0 01        	BCS	LAB_2122	; skip decrement if no underflow
00B20E  2               
00B20E  2  88           	DEY			; decrement bottom of string space high byte
00B20F  2               LAB_2122
00B20F  2  C4 80        	CPY	Earryh		; compare with array mem end high byte
00B211  2  90 11        	BCC	LAB_2137	; do out of memory error if less
00B213  2               
00B213  2  D0 04        	BNE	LAB_212C	; if not = skip next test
00B215  2               
00B215  2  C5 7F        	CMP	Earryl		; compare with array mem end low byte
00B217  2  90 0B        	BCC	LAB_2137	; do out of memory error if less
00B219  2               
00B219  2               LAB_212C
00B219  2  85 81        	STA	Sstorl		; save bottom of string space low byte
00B21B  2  84 82        	STY	Sstorh		; save bottom of string space high byte
00B21D  2  85 83        	STA	Sutill		; save string utility ptr low byte
00B21F  2  84 84        	STY	Sutilh		; save string utility ptr high byte
00B221  2  AA           	TAX			; copy low byte to X
00B222  2  68           	PLA			; get string length back
00B223  2  60           	RTS
00B224  2               
00B224  2               LAB_2137
00B224  2  A2 0C        	LDX	#$0C		; error code $0C ("Out of memory" error)
00B226  2  A5 60        	LDA	Gclctd		; get garbage collected flag
00B228  2  30 B8        	BMI	LAB_20F5	; if set then do error code X
00B22A  2               
00B22A  2  20 34 B2     	JSR	LAB_GARB	; else go do garbage collection
00B22D  2  A9 80        	LDA	#$80		; flag for garbage collected
00B22F  2  85 60        	STA	Gclctd		; set garbage collected flag
00B231  2  68           	PLA			; pull length
00B232  2  D0 D0        	BNE	LAB_2117	; go try again (loop always, length should never be = $00)
00B234  2               
00B234  2               ; garbage collection routine
00B234  2               
00B234  2               LAB_GARB
00B234  2  A6 85        	LDX	Ememl		; get end of mem low byte
00B236  2  A5 86        	LDA	Ememh		; get end of mem high byte
00B238  2               
00B238  2               ; re-run routine from last ending
00B238  2               
00B238  2               LAB_214B
00B238  2  86 81        	STX	Sstorl		; set string storage low byte
00B23A  2  85 82        	STA	Sstorh		; set string storage high byte
00B23C  2  A0 00        	LDY	#$00		; clear index
00B23E  2  84 9D        	STY	garb_h		; clear working pointer high byte (flag no strings to move)
00B240  2               ; *** begin patch  2.22p5.5  garbage collection may overlap temporary strings
00B240  2               ; *** add
00B240  2  84 9C        	STY	garb_l		; clear working pointer low byte (flag no strings to move)
00B242  2               ; *** begin patch  2.22p5.5  garbage collection may overlap temporary strings
00B242  2  A5 7F        	LDA	Earryl		; get array mem end low byte
00B244  2  A6 80        	LDX	Earryh		; get array mem end high byte
00B246  2  85 AA        	STA	Histrl		; save as highest string low byte
00B248  2  86 AB        	STX	Histrh		; save as highest string high byte
00B24A  2  A9 68        	LDA	#des_sk		; set descriptor stack pointer
00B24C  2  85 71        	STA	ut1_pl		; save descriptor stack pointer low byte
00B24E  2  84 72        	STY	ut1_ph		; save descriptor stack pointer high byte ($00)
00B250  2               LAB_2161
00B250  2  C5 65        	CMP	next_s		; compare with descriptor stack pointer
00B252  2  F0 05        	BEQ	LAB_216A	; branch if =
00B254  2               
00B254  2  20 BA B2     	JSR	LAB_21D7	; go garbage collect descriptor stack
00B257  2  F0 F7        	BEQ	LAB_2161	; loop always
00B259  2               
00B259  2               				; done stacked strings, now do string vars
00B259  2               LAB_216A
00B259  2  06 A0        	ASL	g_step		; set step size = $06
00B25B  2  A5 7B        	LDA	Svarl		; get start of vars low byte
00B25D  2  A6 7C        	LDX	Svarh		; get start of vars high byte
00B25F  2  85 71        	STA	ut1_pl		; save as pointer low byte
00B261  2  86 72        	STX	ut1_ph		; save as pointer high byte
00B263  2               LAB_2176
00B263  2  E4 7E        	CPX	Sarryh		; compare start of arrays high byte
00B265  2  D0 04        	BNE	LAB_217E	; branch if no high byte match
00B267  2               
00B267  2  C5 7D        	CMP	Sarryl		; else compare start of arrays low byte
00B269  2  F0 05        	BEQ	LAB_2183	; branch if = var mem end
00B26B  2               
00B26B  2               LAB_217E
00B26B  2  20 B4 B2     	JSR	LAB_21D1	; go garbage collect strings
00B26E  2  F0 F3        	BEQ	LAB_2176	; loop always
00B270  2               
00B270  2               				; done string vars, now do string arrays
00B270  2               LAB_2183
00B270  2  85 A4        	STA	Nbendl		; save start of arrays low byte as working pointer
00B272  2  86 A5        	STX	Nbendh		; save start of arrays high byte as working pointer
00B274  2  A9 04        	LDA	#$04		; set step size
00B276  2  85 A0        	STA	g_step		; save step size
00B278  2               LAB_218B
00B278  2  A5 A4        	LDA	Nbendl		; get pointer low byte
00B27A  2  A6 A5        	LDX	Nbendh		; get pointer high byte
00B27C  2               LAB_218F
00B27C  2  E4 80        	CPX	Earryh		; compare with array mem end high byte
00B27E  2  D0 04        	BNE	LAB_219A	; branch if not at end
00B280  2               
00B280  2  C5 7F        	CMP	Earryl		; else compare with array mem end low byte
00B282  2  F0 75        	BEQ	LAB_2216	; tidy up and exit if at end
00B284  2               
00B284  2               LAB_219A
00B284  2  85 71        	STA	ut1_pl		; save pointer low byte
00B286  2  86 72        	STX	ut1_ph		; save pointer high byte
00B288  2  A0 02        	LDY	#$02		; set index
00B28A  2  B1 71        	LDA	(ut1_pl),Y	; get array size low byte
00B28C  2  65 A4        	ADC	Nbendl		; add start of this array low byte
00B28E  2  85 A4        	STA	Nbendl		; save start of next array low byte
00B290  2  C8           	INY			; increment index
00B291  2  B1 71        	LDA	(ut1_pl),Y	; get array size high byte
00B293  2  65 A5        	ADC	Nbendh		; add start of this array high byte
00B295  2  85 A5        	STA	Nbendh		; save start of next array high byte
00B297  2  A0 01        	LDY	#$01		; set index
00B299  2  B1 71        	LDA	(ut1_pl),Y	; get name second byte
00B29B  2  10 DB        	BPL	LAB_218B	; skip if not string array
00B29D  2               
00B29D  2               ; was string array so ..
00B29D  2               
00B29D  2  A0 04        	LDY	#$04		; set index
00B29F  2  B1 71        	LDA	(ut1_pl),Y	; get # of dimensions
00B2A1  2  0A           	ASL			; *2
00B2A2  2  69 05        	ADC	#$05		; +5 (array header size)
00B2A4  2  20 EC B2     	JSR	LAB_2208	; go set up for first element
00B2A7  2               LAB_21C4
00B2A7  2  E4 A5        	CPX	Nbendh		; compare with start of next array high byte
00B2A9  2  D0 04        	BNE	LAB_21CC	; branch if <> (go do this array)
00B2AB  2               
00B2AB  2  C5 A4        	CMP	Nbendl		; else compare element pointer low byte with next array
00B2AD  2               				; low byte
00B2AD  2  F0 CD        	BEQ	LAB_218F	; if equal then go do next array
00B2AF  2               
00B2AF  2               LAB_21CC
00B2AF  2  20 BA B2     	JSR	LAB_21D7	; go defrag array strings
00B2B2  2  F0 F3        	BEQ	LAB_21C4	; go do next array string (loop always)
00B2B4  2               
00B2B4  2               ; defrag string variables
00B2B4  2               ; enter with XA = variable pointer
00B2B4  2               ; return with XA = next variable pointer
00B2B4  2               
00B2B4  2               LAB_21D1
00B2B4  2  C8           	INY			; increment index (Y was $00)
00B2B5  2  B1 71        	LDA	(ut1_pl),Y	; get var name byte 2
00B2B7  2  10 30        	BPL	LAB_2206	; if not string, step pointer to next var and return
00B2B9  2               
00B2B9  2  C8           	INY			; else increment index
00B2BA  2               LAB_21D7
00B2BA  2  B1 71        	LDA	(ut1_pl),Y	; get string length
00B2BC  2  F0 2B        	BEQ	LAB_2206	; if null, step pointer to next string and return
00B2BE  2               
00B2BE  2  C8           	INY			; else increment index
00B2BF  2  B1 71        	LDA	(ut1_pl),Y	; get string pointer low byte
00B2C1  2  AA           	TAX			; copy to X
00B2C2  2  C8           	INY			; increment index
00B2C3  2  B1 71        	LDA	(ut1_pl),Y	; get string pointer high byte
00B2C5  2  C5 82        	CMP	Sstorh		; compare bottom of string space high byte
00B2C7  2  90 06        	BCC	LAB_21EC	; branch if less
00B2C9  2               
00B2C9  2  D0 1E        	BNE	LAB_2206	; if greater, step pointer to next string and return
00B2CB  2               
00B2CB  2               				; high bytes were = so compare low bytes
00B2CB  2  E4 81        	CPX	Sstorl		; compare bottom of string space low byte
00B2CD  2  B0 1A        	BCS	LAB_2206	; if >=, step pointer to next string and return
00B2CF  2               
00B2CF  2               				; string pointer is < string storage pointer (pos in mem)
00B2CF  2               LAB_21EC
00B2CF  2  C5 AB        	CMP	Histrh		; compare to highest string high byte
00B2D1  2  90 17        	BCC	LAB_2207	; if <, step pointer to next string and return
00B2D3  2               
00B2D3  2  D0 04        	BNE	LAB_21F6	; if > update pointers, step to next and return
00B2D5  2               
00B2D5  2               				; high bytes were = so compare low bytes
00B2D5  2  E4 AA        	CPX	Histrl		; compare to highest string low byte
00B2D7  2  90 11        	BCC	LAB_2207	; if <, step pointer to next string and return
00B2D9  2               
00B2D9  2               				; string is in string memory space
00B2D9  2               LAB_21F6
00B2D9  2  86 AA        	STX	Histrl		; save as new highest string low byte
00B2DB  2  85 AB        	STA	Histrh		; save as new highest string high byte
00B2DD  2  A5 71        	LDA	ut1_pl		; get start of vars(descriptors) low byte
00B2DF  2  A6 72        	LDX	ut1_ph		; get start of vars(descriptors) high byte
00B2E1  2  85 9C        	STA	garb_l		; save as working pointer low byte
00B2E3  2  86 9D        	STX	garb_h		; save as working pointer high byte
00B2E5  2  88           	DEY			; decrement index DIFFERS
00B2E6  2  88           	DEY			; decrement index (should point to descriptor start)
00B2E7  2  84 A2        	STY	g_indx		; save index pointer
00B2E9  2               
00B2E9  2               				; step pointer to next string
00B2E9  2               LAB_2206
00B2E9  2  18           	CLC			; clear carry for add
00B2EA  2               LAB_2207
00B2EA  2  A5 A0        	LDA	g_step		; get step size
00B2EC  2               LAB_2208
00B2EC  2  65 71        	ADC	ut1_pl		; add pointer low byte
00B2EE  2  85 71        	STA	ut1_pl		; save pointer low byte
00B2F0  2  90 02        	BCC	LAB_2211	; branch if no overflow
00B2F2  2               
00B2F2  2  E6 72        	INC	ut1_ph		; else increment high byte
00B2F4  2               LAB_2211
00B2F4  2  A6 72        	LDX	ut1_ph		; get pointer high byte
00B2F6  2  A0 00        	LDY	#$00		; clear Y
00B2F8  2  60           	RTS
00B2F9  2               
00B2F9  2               ; search complete, now either exit or set-up and move string
00B2F9  2               
00B2F9  2               LAB_2216
00B2F9  2  C6 A0        	DEC	g_step		; decrement step size (now $03 for descriptor stack)
00B2FB  2               ; *** begin patch  2.22p5.5  garbage collection may overlap temporary strings
00B2FB  2               ; *** replace
00B2FB  2               ;	LDX	garb_h		; get string to move high byte
00B2FB  2               ; *** with
00B2FB  2  A5 9D        	LDA	garb_h		; any string to move?
00B2FD  2  05 9C        	ORA	garb_l
00B2FF  2               ; *** end   patch  2.22p5.5  garbage collection may overlap temporary strings
00B2FF  2  F0 F3        	BEQ	LAB_2211	; exit if nothing to move
00B301  2               
00B301  2  A4 A2        	LDY	g_indx		; get index byte back (points to descriptor)
00B303  2  18           	CLC			; clear carry for add
00B304  2  B1 9C        	LDA	(garb_l),Y	; get string length
00B306  2  65 AA        	ADC	Histrl		; add highest string low byte
00B308  2  85 A6        	STA	Obendl		; save old block end low pointer
00B30A  2  A5 AB        	LDA	Histrh		; get highest string high byte
00B30C  2  69 00        	ADC	#$00		; add any carry
00B30E  2  85 A7        	STA	Obendh		; save old block end high byte
00B310  2  A5 81        	LDA	Sstorl		; get bottom of string space low byte
00B312  2  A6 82        	LDX	Sstorh		; get bottom of string space high byte
00B314  2  85 A4        	STA	Nbendl		; save new block end low byte
00B316  2  86 A5        	STX	Nbendh		; save new block end high byte
00B318  2  20 D5 A0     	JSR	LAB_11D6	; open up space in memory, don't set array end
00B31B  2  A4 A2        	LDY	g_indx		; get index byte
00B31D  2  C8           	INY			; point to descriptor low byte
00B31E  2  A5 A4        	LDA	Nbendl		; get string pointer low byte
00B320  2  91 9C        	STA	(garb_l),Y	; save new string pointer low byte
00B322  2  AA           	TAX			; copy string pointer low byte
00B323  2  E6 A5        	INC	Nbendh		; correct high byte (move sets high byte -1)
00B325  2  A5 A5        	LDA	Nbendh		; get new string pointer high byte
00B327  2  C8           	INY			; point to descriptor high byte
00B328  2  91 9C        	STA	(garb_l),Y	; save new string pointer high byte
00B32A  2  4C 38 B2     	JMP	LAB_214B	; re-run routine from last ending
00B32D  2               				; (but don't collect this string)
00B32D  2               
00B32D  2               ; concatenate
00B32D  2               ; add strings, string 1 is in descriptor des_pl, string 2 is in line
00B32D  2               
00B32D  2               LAB_224D
00B32D  2  A5 AF        	LDA	des_ph		; get descriptor pointer high byte
00B32F  2  48           	PHA			; put on stack
00B330  2  A5 AE        	LDA	des_pl		; get descriptor pointer low byte
00B332  2  48           	PHA			; put on stack
00B333  2               ; *** begin patch  2.22p5.4  concatenate MINUS or NOT() crashes EhBASIC  ***
00B333  2               ; *** add extra label to verify originating function
00B333  2               LAB_224Da
00B333  2               ; *** end patch    2.22p5.4  concatenate MINUS or NOT() crashes EhBASIC  ***
00B333  2  20 15 AC     	JSR	LAB_GVAL	; get value from line
00B336  2  20 19 AB     	JSR	LAB_CTST	; check if source is string, else do type mismatch
00B339  2  68           	PLA			; get descriptor pointer low byte back
00B33A  2  85 B8        	STA	ssptr_l		; set pointer low byte
00B33C  2  68           	PLA			; get descriptor pointer high byte back
00B33D  2  85 B9        	STA	ssptr_h		; set pointer high byte
00B33F  2  A0 00        	LDY	#$00		; clear index
00B341  2  B1 B8        	LDA	(ssptr_l),Y	; get length_1 from descriptor
00B343  2  18           	CLC			; clear carry for add
00B344  2  71 AE        	ADC	(des_pl),Y	; add length_2
00B346  2  90 05        	BCC	LAB_226D	; branch if no overflow
00B348  2               
00B348  2  A2 1A        	LDX	#$1A		; else set error code $1A ("String too long" error)
00B34A  2  4C 4C A1     	JMP	LAB_XERR	; do error #X, then warm start
00B34D  2               
00B34D  2               LAB_226D
00B34D  2  20 85 B1     	JSR	LAB_209C	; copy des_pl/h to des_2l/h and make string space A bytes
00B350  2               				; long
00B350  2  20 6A B3     	JSR	LAB_228A	; copy string from descriptor (sdescr) to (Sutill)
00B353  2  A5 9E        	LDA	des_2l		; get descriptor pointer low byte
00B355  2  A4 9F        	LDY	des_2h		; get descriptor pointer high byte
00B357  2  20 9B B3     	JSR	LAB_22BA	; pop (YA) descriptor off stack or from top of string space
00B35A  2               				; returns with A = length, ut1_pl = pointer low byte,
00B35A  2               				; ut1_ph = pointer high byte
00B35A  2  20 7C B3     	JSR	LAB_229C	; store string A bytes long from (ut1_pl) to (Sutill)
00B35D  2  A5 B8        	LDA	ssptr_l		;.set descriptor pointer low byte
00B35F  2  A4 B9        	LDY	ssptr_h		;.set descriptor pointer high byte
00B361  2  20 9B B3     	JSR	LAB_22BA	; pop (YA) descriptor off stack or from top of string space
00B364  2               				; returns with A = length, X=ut1_pl=pointer low byte,
00B364  2               				; Y=ut1_ph=pointer high byte
00B364  2  20 DA B1     	JSR	LAB_RTST	; check for space on descriptor stack then put string
00B367  2               				; address and length on descriptor stack and update stack
00B367  2               				; pointers
00B367  2  4C 3F AB     	JMP	LAB_1ADB	; continue evaluation
00B36A  2               
00B36A  2               ; copy string from descriptor (sdescr) to (Sutill)
00B36A  2               
00B36A  2               LAB_228A
00B36A  2  A0 00        	LDY	#$00		; clear index
00B36C  2  B1 B8        	LDA	(sdescr),Y	; get string length
00B36E  2  48           	PHA			; save on stack
00B36F  2  C8           	INY			; increment index
00B370  2  B1 B8        	LDA	(sdescr),Y	; get source string pointer low byte
00B372  2  AA           	TAX			; copy to X
00B373  2  C8           	INY			; increment index
00B374  2  B1 B8        	LDA	(sdescr),Y	; get source string pointer high byte
00B376  2  A8           	TAY			; copy to Y
00B377  2  68           	PLA			; get length back
00B378  2               
00B378  2               ; store string A bytes long from YX to (Sutill)
00B378  2               
00B378  2               LAB_2298
00B378  2  86 71        	STX	ut1_pl		; save source string pointer low byte
00B37A  2  84 72        	STY	ut1_ph		; save source string pointer high byte
00B37C  2               
00B37C  2               ; store string A bytes long from (ut1_pl) to (Sutill)
00B37C  2               
00B37C  2               LAB_229C
00B37C  2  AA           	TAX			; copy length to index (don't count with Y)
00B37D  2  F0 14        	BEQ	LAB_22B2	; branch if = $0 (null string) no need to add zero length
00B37F  2               
00B37F  2  A0 00        	LDY	#$00		; zero pointer (copy forward)
00B381  2               LAB_22A0
00B381  2  B1 71        	LDA	(ut1_pl),Y	; get source byte
00B383  2  91 83        	STA	(Sutill),Y	; save destination byte
00B385  2               
00B385  2  C8           	INY			; increment index
00B386  2  CA           	DEX			; decrement counter
00B387  2  D0 F8        	BNE	LAB_22A0	; loop while <> 0
00B389  2               
00B389  2  98           	TYA			; restore length from Y
00B38A  2               LAB_22A9
00B38A  2  18           	CLC			; clear carry for add
00B38B  2  65 83        	ADC	Sutill		; add string utility ptr low byte
00B38D  2  85 83        	STA	Sutill		; save string utility ptr low byte
00B38F  2  90 02        	BCC	LAB_22B2	; branch if no carry
00B391  2               
00B391  2  E6 84        	INC	Sutilh		; else increment string utility ptr high byte
00B393  2               LAB_22B2
00B393  2  60           	RTS
00B394  2               
00B394  2               ; evaluate string
00B394  2               
00B394  2               LAB_EVST
00B394  2  20 19 AB     	JSR	LAB_CTST	; check if source is string, else do type mismatch
00B397  2               
00B397  2               ; pop string off descriptor stack, or from top of string space
00B397  2               ; returns with A = length, X=pointer low byte, Y=pointer high byte
00B397  2               
00B397  2               LAB_22B6
00B397  2  A5 AE        	LDA	des_pl		; get descriptor pointer low byte
00B399  2  A4 AF        	LDY	des_ph		; get descriptor pointer high byte
00B39B  2               
00B39B  2               ; pop (YA) descriptor off stack or from top of string space
00B39B  2               ; returns with A = length, X=ut1_pl=pointer low byte, Y=ut1_ph=pointer high byte
00B39B  2               
00B39B  2               LAB_22BA
00B39B  2  85 71        	STA	ut1_pl		; save descriptor pointer low byte
00B39D  2  84 72        	STY	ut1_ph		; save descriptor pointer high byte
00B39F  2  20 CC B3     	JSR	LAB_22EB	; clean descriptor stack, YA = pointer
00B3A2  2  08           	PHP			; save status flags
00B3A3  2  A0 00        	LDY	#$00		; clear index
00B3A5  2  B1 71        	LDA	(ut1_pl),Y	; get length from string descriptor
00B3A7  2  48           	PHA			; put on stack
00B3A8  2  C8           	INY			; increment index
00B3A9  2  B1 71        	LDA	(ut1_pl),Y	; get string pointer low byte from descriptor
00B3AB  2  AA           	TAX			; copy to X
00B3AC  2  C8           	INY			; increment index
00B3AD  2  B1 71        	LDA	(ut1_pl),Y	; get string pointer high byte from descriptor
00B3AF  2  A8           	TAY			; copy to Y
00B3B0  2  68           	PLA			; get string length back
00B3B1  2  28           	PLP			; restore status
00B3B2  2  D0 13        	BNE	LAB_22E6	; branch if pointer <> last_sl,last_sh
00B3B4  2               
00B3B4  2  C4 82        	CPY	Sstorh		; compare bottom of string space high byte
00B3B6  2  D0 0F        	BNE	LAB_22E6	; branch if <>
00B3B8  2               
00B3B8  2  E4 81        	CPX	Sstorl		; else compare bottom of string space low byte
00B3BA  2  D0 0B        	BNE	LAB_22E6	; branch if <>
00B3BC  2               
00B3BC  2  48           	PHA			; save string length
00B3BD  2  18           	CLC			; clear carry for add
00B3BE  2  65 81        	ADC	Sstorl		; add bottom of string space low byte
00B3C0  2  85 81        	STA	Sstorl		; save bottom of string space low byte
00B3C2  2  90 02        	BCC	LAB_22E5	; skip increment if no overflow
00B3C4  2               
00B3C4  2  E6 82        	INC	Sstorh		; increment bottom of string space high byte
00B3C6  2               LAB_22E5
00B3C6  2  68           	PLA			; restore string length
00B3C7  2               LAB_22E6
00B3C7  2  86 71        	STX	ut1_pl		; save string pointer low byte
00B3C9  2  84 72        	STY	ut1_ph		; save string pointer high byte
00B3CB  2  60           	RTS
00B3CC  2               
00B3CC  2               ; clean descriptor stack, YA = pointer
00B3CC  2               ; checks if AY is on the descriptor stack, if so does a stack discard
00B3CC  2               
00B3CC  2               LAB_22EB
00B3CC  2  C4 67        	CPY	last_sh		; compare pointer high byte
00B3CE  2  D0 0C        	BNE	LAB_22FB	; exit if <>
00B3D0  2               
00B3D0  2  C5 66        	CMP	last_sl		; compare pointer low byte
00B3D2  2  D0 08        	BNE	LAB_22FB	; exit if <>
00B3D4  2               
00B3D4  2  85 65        	STA	next_s		; save descriptor stack pointer
00B3D6  2  E9 03        	SBC	#$03		; -3
00B3D8  2  85 66        	STA	last_sl		; save low byte -3
00B3DA  2  A0 00        	LDY	#$00		; clear high byte
00B3DC  2               LAB_22FB
00B3DC  2  60           	RTS
00B3DD  2               
00B3DD  2               ; perform CHR$()
00B3DD  2               
00B3DD  2               LAB_CHRS
00B3DD  2  20 E8 B4     	JSR	LAB_EVBY	; evaluate byte expression, result in X
00B3E0  2  8A           	TXA			; copy to A
00B3E1  2  48           	PHA			; save character
00B3E2  2  A9 01        	LDA	#$01		; string is single byte
00B3E4  2  20 8D B1     	JSR	LAB_MSSP	; make string space A bytes long A=$AC=length,
00B3E7  2               				; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
00B3E7  2  68           	PLA			; get character back
00B3E8  2  A0 00        	LDY	#$00		; clear index
00B3EA  2  91 AD        	STA	(str_pl),Y	; save byte in string (byte IS string!)
00B3EC  2  4C DA B1     	JMP	LAB_RTST	; check for space on descriptor stack then put string
00B3EF  2               				; address and length on descriptor stack and update stack
00B3EF  2               				; pointers
00B3EF  2               
00B3EF  2               ; perform LEFT$()
00B3EF  2               
00B3EF  2               LAB_LEFT
00B3EF  2  48           	PHA			; push byte parameter
00B3F0  2  20 50 B4     	JSR	LAB_236F	; pull string data and byte parameter from stack
00B3F3  2               				; return pointer in des_2l/h, byte in A (and X), Y=0
00B3F3  2  D1 9E        	CMP	(des_2l),Y	; compare byte parameter with string length
00B3F5  2  98           	TYA			; clear A
00B3F6  2  F0 09        	BEQ	LAB_2316	; go do string copy (branch always)
00B3F8  2               
00B3F8  2               ; perform RIGHT$()
00B3F8  2               
00B3F8  2               LAB_RIGHT
00B3F8  2  48           	PHA			; push byte parameter
00B3F9  2  20 50 B4     	JSR	LAB_236F	; pull string data and byte parameter from stack
00B3FC  2               				; return pointer in des_2l/h, byte in A (and X), Y=0
00B3FC  2  18           	CLC			; clear carry for add-1
00B3FD  2  F1 9E        	SBC	(des_2l),Y	; subtract string length
00B3FF  2  49 FF        	EOR	#$FF		; invert it (A=LEN(expression$)-l)
00B401  2               
00B401  2               LAB_2316
00B401  2  90 04        	BCC	LAB_231C	; branch if string length > byte parameter
00B403  2               
00B403  2  B1 9E        	LDA	(des_2l),Y	; else make parameter = length
00B405  2  AA           	TAX			; copy to byte parameter copy
00B406  2  98           	TYA			; clear string start offset
00B407  2               LAB_231C
00B407  2  48           	PHA			; save string start offset
00B408  2               LAB_231D
00B408  2  8A           	TXA			; copy byte parameter (or string length if <)
00B409  2               LAB_231E
00B409  2  48           	PHA			; save string length
00B40A  2  20 8D B1     	JSR	LAB_MSSP	; make string space A bytes long A=$AC=length,
00B40D  2               				; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
00B40D  2  A5 9E        	LDA	des_2l		; get descriptor pointer low byte
00B40F  2  A4 9F        	LDY	des_2h		; get descriptor pointer high byte
00B411  2  20 9B B3     	JSR	LAB_22BA	; pop (YA) descriptor off stack or from top of string space
00B414  2               				; returns with A = length, X=ut1_pl=pointer low byte,
00B414  2               				; Y=ut1_ph=pointer high byte
00B414  2  68           	PLA			; get string length back
00B415  2  A8           	TAY			; copy length to Y
00B416  2  68           	PLA			; get string start offset back
00B417  2  18           	CLC			; clear carry for add
00B418  2  65 71        	ADC	ut1_pl		; add start offset to string start pointer low byte
00B41A  2  85 71        	STA	ut1_pl		; save string start pointer low byte
00B41C  2  90 02        	BCC	LAB_2335	; branch if no overflow
00B41E  2               
00B41E  2  E6 72        	INC	ut1_ph		; else increment string start pointer high byte
00B420  2               LAB_2335
00B420  2  98           	TYA			; copy length to A
00B421  2  20 7C B3     	JSR	LAB_229C	; store string A bytes long from (ut1_pl) to (Sutill)
00B424  2  4C DA B1     	JMP	LAB_RTST	; check for space on descriptor stack then put string
00B427  2               				; address and length on descriptor stack and update stack
00B427  2               				; pointers
00B427  2               
00B427  2               ; perform MID$()
00B427  2               
00B427  2               LAB_MIDS
00B427  2  48           	PHA			; push byte parameter
00B428  2  A9 FF        	LDA	#$FF		; set default length = 255
00B42A  2  85 AF        	STA	mids_l		; save default length
00B42C  2  20 C2 00     	JSR	LAB_GBYT	; scan memory
00B42F  2  C9 29        	CMP	#')'		; compare with ")"
00B431  2  F0 06        	BEQ	LAB_2358	; branch if = ")" (skip second byte get)
00B433  2               
00B433  2  20 46 AC     	JSR	LAB_1C01	; scan for "," , else do syntax error then warm start
00B436  2  20 E5 B4     	JSR	LAB_GTBY	; get byte parameter (use copy in mids_l)
00B439  2               LAB_2358
00B439  2  20 50 B4     	JSR	LAB_236F	; pull string data and byte parameter from stack
00B43C  2               				; return pointer in des_2l/h, byte in A (and X), Y=0
00B43C  2  CA           	DEX			; decrement start index
00B43D  2  8A           	TXA			; copy to A
00B43E  2  48           	PHA			; save string start offset
00B43F  2  18           	CLC			; clear carry for sub-1
00B440  2  A2 00        	LDX	#$00		; clear output string length
00B442  2  F1 9E        	SBC	(des_2l),Y	; subtract string length
00B444  2  B0 C2        	BCS	LAB_231D	; if start>string length go do null string
00B446  2               
00B446  2  49 FF        	EOR	#$FF		; complement -length
00B448  2  C5 AF        	CMP	mids_l		; compare byte parameter
00B44A  2  90 BD        	BCC	LAB_231E	; if length>remaining string go do RIGHT$
00B44C  2               
00B44C  2  A5 AF        	LDA	mids_l		; get length byte
00B44E  2  B0 B9        	BCS	LAB_231E	; go do string copy (branch always)
00B450  2               
00B450  2               ; pull string data and byte parameter from stack
00B450  2               ; return pointer in des_2l/h, byte in A (and X), Y=0
00B450  2               
00B450  2               LAB_236F
00B450  2  20 37 AC     	JSR	LAB_1BFB	; scan for ")" , else do syntax error then warm start
00B453  2  68           	PLA			; pull return address low byte (return address)
00B454  2  85 A2        	STA	Fnxjpl		; save functions jump vector low byte
00B456  2  68           	PLA			; pull return address high byte (return address)
00B457  2  85 A3        	STA	Fnxjph		; save functions jump vector high byte
00B459  2  68           	PLA			; pull byte parameter
00B45A  2  AA           	TAX			; copy byte parameter to X
00B45B  2  68           	PLA			; pull string pointer low byte
00B45C  2  85 9E        	STA	des_2l		; save it
00B45E  2  68           	PLA			; pull string pointer high byte
00B45F  2  85 9F        	STA	des_2h		; save it
00B461  2  A0 00        	LDY	#$00		; clear index
00B463  2  8A           	TXA			; copy byte parameter
00B464  2  F0 79        	BEQ	LAB_23A8	; if null do function call error then warm start
00B466  2               
00B466  2  E6 A2        	INC	Fnxjpl		; increment function jump vector low byte
00B468  2               				; (JSR pushes return addr-1. this is all very nice
00B468  2               				; but will go tits up if either call is on a page
00B468  2               				; boundary!)
00B468  2  6C A2 00     	JMP	(Fnxjpl)	; in effect, RTS
00B46B  2               
00B46B  2               ; perform LCASE$()
00B46B  2               
00B46B  2               LAB_LCASE
00B46B  2  20 94 B3     	JSR	LAB_EVST	; evaluate string
00B46E  2  85 AC        	STA	str_ln		; set string length
00B470  2  A8           	TAY			; copy length to Y
00B471  2  F0 38        	BEQ	NoString	; branch if null string
00B473  2               
00B473  2  20 8D B1     	JSR	LAB_MSSP	; make string space A bytes long A=length,
00B476  2               				; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
00B476  2  86 AD        	STX	str_pl		; save string pointer low byte
00B478  2  84 AE        	STY	str_ph		; save string pointer high byte
00B47A  2  A8           	TAY			; get string length back
00B47B  2               
00B47B  2               LC_loop
00B47B  2  88           	DEY			; decrement index
00B47C  2  B1 71        	LDA	(ut1_pl),Y	; get byte from string
00B47E  2  20 78 AE     	JSR	LAB_1D82	; is character "A" to "Z"
00B481  2  90 02        	BCC	NoUcase		; branch if not upper case alpha
00B483  2               
00B483  2  09 20        	ORA	#$20		; convert upper to lower case
00B485  2               NoUcase
00B485  2  91 83        	STA	(Sutill),Y	; save byte back to string
00B487  2  98           	TYA			; test index
00B488  2  D0 F1        	BNE	LC_loop		; loop if not all done
00B48A  2               
00B48A  2  F0 1F        	BEQ	NoString	; tidy up and exit, branch always
00B48C  2               
00B48C  2               ; perform UCASE$()
00B48C  2               
00B48C  2               LAB_UCASE
00B48C  2  20 94 B3     	JSR	LAB_EVST	; evaluate string
00B48F  2  85 AC        	STA	str_ln		; set string length
00B491  2  A8           	TAY			; copy length to Y
00B492  2  F0 17        	BEQ	NoString	; branch if null string
00B494  2               
00B494  2  20 8D B1     	JSR	LAB_MSSP	; make string space A bytes long A=length,
00B497  2               				; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
00B497  2  86 AD        	STX	str_pl		; save string pointer low byte
00B499  2  84 AE        	STY	str_ph		; save string pointer high byte
00B49B  2  A8           	TAY			; get string length back
00B49C  2               
00B49C  2               UC_loop
00B49C  2  88           	DEY			; decrement index
00B49D  2  B1 71        	LDA	(ut1_pl),Y	; get byte from string
00B49F  2  20 74 AE     	JSR	LAB_CASC	; is character "a" to "z" (or "A" to "Z")
00B4A2  2  90 02        	BCC	NoLcase		; branch if not alpha
00B4A4  2               
00B4A4  2  29 DF        	AND	#$DF		; convert lower to upper case
00B4A6  2               NoLcase
00B4A6  2  91 83        	STA	(Sutill),Y	; save byte back to string
00B4A8  2  98           	TYA			; test index
00B4A9  2  D0 F1        	BNE	UC_loop		; loop if not all done
00B4AB  2               
00B4AB  2               NoString
00B4AB  2  4C DA B1     	JMP	LAB_RTST	; check for space on descriptor stack then put string
00B4AE  2               				; address and length on descriptor stack and update stack
00B4AE  2               				; pointers
00B4AE  2               
00B4AE  2               ; perform SADD()
00B4AE  2               
00B4AE  2               LAB_SADD
00B4AE  2  20 BC 00     	JSR	LAB_IGBY	; increment and scan memory
00B4B1  2  20 00 AE     	JSR	LAB_GVAR	; get var address
00B4B4  2               
00B4B4  2  20 37 AC     	JSR	LAB_1BFB	; scan for ")", else do syntax error then warm start
00B4B7  2  20 19 AB     	JSR	LAB_CTST	; check if source is string, else do type mismatch
00B4BA  2               
00B4BA  2  A0 02        	LDY	#$02		; index to string pointer high byte
00B4BC  2  B1 95        	LDA	(Cvaral),Y	; get string pointer high byte
00B4BE  2  AA           	TAX			; copy string pointer high byte to X
00B4BF  2  88           	DEY			; index to string pointer low byte
00B4C0  2  B1 95        	LDA	(Cvaral),Y	; get string pointer low byte
00B4C2  2  A8           	TAY			; copy string pointer low byte to Y
00B4C3  2  8A           	TXA			; copy string pointer high byte to A
00B4C4  2  4C AF B0     	JMP	LAB_AYFC	; save and convert integer AY to FAC1 and return
00B4C7  2               
00B4C7  2               ; perform LEN()
00B4C7  2               
00B4C7  2               LAB_LENS
00B4C7  2  20 CD B4     	JSR	LAB_ESGL	; evaluate string, get length in A (and Y)
00B4CA  2  4C BD B0     	JMP	LAB_1FD0	; convert Y to byte in FAC1 and return
00B4CD  2               
00B4CD  2               ; evaluate string, get length in Y
00B4CD  2               
00B4CD  2               LAB_ESGL
00B4CD  2  20 94 B3     	JSR	LAB_EVST	; evaluate string
00B4D0  2  A8           	TAY			; copy length to Y
00B4D1  2  60           	RTS
00B4D2  2               
00B4D2  2               ; perform ASC()
00B4D2  2               
00B4D2  2               LAB_ASC
00B4D2  2  20 CD B4     	JSR	LAB_ESGL	; evaluate string, get length in A (and Y)
00B4D5  2  F0 08        	BEQ	LAB_23A8	; if null do function call error then warm start
00B4D7  2               
00B4D7  2  A0 00        	LDY	#$00		; set index to first character
00B4D9  2  B1 71        	LDA	(ut1_pl),Y	; get byte
00B4DB  2  A8           	TAY			; copy to Y
00B4DC  2  4C BD B0     	JMP	LAB_1FD0	; convert Y to byte in FAC1 and return
00B4DF  2               
00B4DF  2               ; do function call error then warm start
00B4DF  2               
00B4DF  2               LAB_23A8
00B4DF  2  4C 7F AF     	JMP	LAB_FCER	; do function call error then warm start
00B4E2  2               
00B4E2  2               ; scan and get byte parameter
00B4E2  2               
00B4E2  2               LAB_SGBY
00B4E2  2  20 BC 00     	JSR	LAB_IGBY	; increment and scan memory
00B4E5  2               
00B4E5  2               ; get byte parameter
00B4E5  2               
00B4E5  2               LAB_GTBY
00B4E5  2  20 14 AB     	JSR	LAB_EVNM	; evaluate expression and check is numeric,
00B4E8  2               				; else do type mismatch
00B4E8  2               
00B4E8  2               ; evaluate byte expression, result in X
00B4E8  2               
00B4E8  2               LAB_EVBY
00B4E8  2  20 F8 AE     	JSR	LAB_EVPI	; evaluate integer expression (no check)
00B4EB  2               
00B4EB  2  A4 AE        	LDY	FAC1_2		; get FAC1 mantissa2
00B4ED  2  D0 F0        	BNE	LAB_23A8	; if top byte <> 0 do function call error then warm start
00B4EF  2               
00B4EF  2  A6 AF        	LDX	FAC1_3		; get FAC1 mantissa3
00B4F1  2  4C C2 00     	JMP	LAB_GBYT	; scan memory and return
00B4F4  2               
00B4F4  2               ; perform VAL()
00B4F4  2               
00B4F4  2               LAB_VAL
00B4F4  2  20 CD B4     	JSR	LAB_ESGL	; evaluate string, get length in A (and Y)
00B4F7  2  D0 03        	BNE	LAB_23C5	; branch if not null string
00B4F9  2               
00B4F9  2               				; string was null so set result = $00
00B4F9  2  4C B2 B6     	JMP	LAB_24F1	; clear FAC1 exponent and sign and return
00B4FC  2               
00B4FC  2               LAB_23C5
00B4FC  2               ; *** begin patch  2.22p5.7  VAL() may cause string variables to be trashed
00B4FC  2               ; *** replace
00B4FC  2               ;	LDX	Bpntrl		; get BASIC execute pointer low byte
00B4FC  2               ;	LDY	Bpntrh		; get BASIC execute pointer high byte
00B4FC  2               ;	STX	Btmpl		; save BASIC execute pointer low byte
00B4FC  2               ;	STY	Btmph		; save BASIC execute pointer high byte
00B4FC  2               ;	LDX	ut1_pl		; get string pointer low byte
00B4FC  2               ;	STX	Bpntrl		; save as BASIC execute pointer low byte
00B4FC  2               ;	CLC			; clear carry
00B4FC  2               ;	ADC	ut1_pl		; add string length
00B4FC  2               ;	STA	ut2_pl		; save string end low byte
00B4FC  2               ;	LDA	ut1_ph		; get string pointer high byte
00B4FC  2               ;	STA	Bpntrh		; save as BASIC execute pointer high byte
00B4FC  2               ;	ADC	#$00		; add carry to high byte
00B4FC  2               ;	STA	ut2_ph		; save string end high byte
00B4FC  2               ;	LDY	#$00		; set index to $00
00B4FC  2               ;	LDA	(ut2_pl),Y	; get string end +1 byte
00B4FC  2               ;	PHA			; push it
00B4FC  2               ;	TYA			; clear A
00B4FC  2               ;	STA	(ut2_pl),Y	; terminate string with $00
00B4FC  2               ;	JSR	LAB_GBYT	; scan memory
00B4FC  2               ;	JSR	LAB_2887	; get FAC1 from string
00B4FC  2               ;	PLA			; restore string end +1 byte
00B4FC  2               ;	LDY	#$00		; set index to zero
00B4FC  2               ;	STA	(ut2_pl),Y	; put string end byte back
00B4FC  2               ; *** with
00B4FC  2  48           	PHA			; save length
00B4FD  2  C8           	INY			; string length +1
00B4FE  2  98           	TYA
00B4FF  2  20 8D B1     	JSR	LAB_MSSP	; allocate temp string +1 bytes long
00B502  2  68           	PLA			; get length back
00B503  2  20 7C B3     	JSR	LAB_229C	; copy string (ut1_pl) -> (Sutill) for A bytes
00B506  2  A9 00        	LDA	#0		; add delimiter to end of string
00B508  2  A8           	TAY
00B509  2  91 83        	STA	(Sutill),Y
00B50B  2  A6 C3        	LDX	Bpntrl		; save BASIC execute pointer low byte
00B50D  2  A4 C4        	LDY	Bpntrh
00B50F  2  86 BA        	STX	Btmpl
00B511  2  84 BB        	STY	Btmph
00B513  2  A6 AD        	LDX	str_pl		; point to temporary string
00B515  2  A4 AE        	LDY	str_ph
00B517  2  86 C3        	STX	Bpntrl
00B519  2  84 C4        	STY	Bpntrh
00B51B  2  20 C2 00     	JSR	LAB_GBYT	; scan memory
00B51E  2  20 08 BA     	JSR	LAB_2887	; get FAC1 from string
00B521  2               ; *** end patch    2.22p5.7  VAL() may cause string variables to be trashed
00B521  2               
00B521  2               ; restore BASIC execute pointer from temp (Btmpl/Btmph)
00B521  2               
00B521  2               LAB_23F3
00B521  2  A6 BA        	LDX	Btmpl		; get BASIC execute pointer low byte back
00B523  2  A4 BB        	LDY	Btmph		; get BASIC execute pointer high byte back
00B525  2  86 C3        	STX	Bpntrl		; save BASIC execute pointer low byte
00B527  2  84 C4        	STY	Bpntrh		; save BASIC execute pointer high byte
00B529  2  60           	RTS
00B52A  2               
00B52A  2               ; get two parameters for POKE or WAIT
00B52A  2               
00B52A  2               LAB_GADB
00B52A  2  20 14 AB     	JSR	LAB_EVNM	; evaluate expression and check is numeric,
00B52D  2               				; else do type mismatch
00B52D  2  20 43 B5     	JSR	LAB_F2FX	; save integer part of FAC1 in temporary integer
00B530  2               
00B530  2               ; scan for "," and get byte, else do Syntax error then warm start
00B530  2               
00B530  2               LAB_SCGB
00B530  2  20 46 AC     	JSR	LAB_1C01	; scan for "," , else do syntax error then warm start
00B533  2  A5 12        	LDA	Itemph		; save temporary integer high byte
00B535  2  48           	PHA			; on stack
00B536  2  A5 11        	LDA	Itempl		; save temporary integer low byte
00B538  2  48           	PHA			; on stack
00B539  2  20 E5 B4     	JSR	LAB_GTBY	; get byte parameter
00B53C  2  68           	PLA			; pull low byte
00B53D  2  85 11        	STA	Itempl		; restore temporary integer low byte
00B53F  2  68           	PLA			; pull high byte
00B540  2  85 12        	STA	Itemph		; restore temporary integer high byte
00B542  2  60           	RTS
00B543  2               
00B543  2               ; convert float to fixed routine. accepts any value that fits in 24 bits, +ve or
00B543  2               ; -ve and converts it into a right truncated integer in Itempl and Itemph
00B543  2               
00B543  2               ; save unsigned 16 bit integer part of FAC1 in temporary integer
00B543  2               
00B543  2               LAB_F2FX
00B543  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00B545  2  C9 98        	CMP	#$98		; compare with exponent = 2^24
00B547  2  B0 96        	BCS	LAB_23A8	; if >= do function call error then warm start
00B549  2               
00B549  2               LAB_F2FU
00B549  2  20 B2 B9     	JSR	LAB_2831	; convert FAC1 floating-to-fixed
00B54C  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
00B54E  2  A4 AF        	LDY	FAC1_3		; get FAC1 mantissa3
00B550  2  84 11        	STY	Itempl		; save temporary integer low byte
00B552  2  85 12        	STA	Itemph		; save temporary integer high byte
00B554  2  60           	RTS
00B555  2               
00B555  2               ; perform PEEK()
00B555  2               
00B555  2               LAB_PEEK
00B555  2  20 43 B5     	JSR	LAB_F2FX	; save integer part of FAC1 in temporary integer
00B558  2  A2 00        	LDX	#$00		; clear index
00B55A  2  A1 11        	LDA	(Itempl,X)	; get byte via temporary integer (addr)
00B55C  2               LAB_PEEKY
00B55C  2  A8           	TAY			; copy byte to Y
00B55D  2  4C BD B0     	JMP	LAB_1FD0	; convert Y to byte in FAC1 and return
00B560  2               
00B560  2               ; perform POKE
00B560  2               
00B560  2               LAB_POKE
00B560  2  20 2A B5     	JSR	LAB_GADB	; get two parameters for POKE or WAIT
00B563  2  8A           	TXA			; copy byte argument to A
00B564  2  A2 00        	LDX	#$00		; clear index
00B566  2  81 11        	STA	(Itempl,X)	; save byte via temporary integer (addr)
00B568  2  60           	RTS
00B569  2               
00B569  2               ; perform DEEK()
00B569  2               
00B569  2               LAB_DEEK
00B569  2  20 43 B5     	JSR	LAB_F2FX	; save integer part of FAC1 in temporary integer
00B56C  2  A2 00        	LDX	#$00		; clear index
00B56E  2  A1 11        	LDA	(Itempl,X)	; PEEK low byte
00B570  2  A8           	TAY			; copy to Y
00B571  2  E6 11        	INC	Itempl		; increment pointer low byte
00B573  2  D0 02        	BNE	Deekh		; skip high increment if no rollover
00B575  2               
00B575  2  E6 12        	INC	Itemph		; increment pointer high byte
00B577  2               Deekh
00B577  2  A1 11        	LDA	(Itempl,X)	; PEEK high byte
00B579  2  4C AF B0     	JMP	LAB_AYFC	; save and convert integer AY to FAC1 and return
00B57C  2               
00B57C  2               ; perform DOKE
00B57C  2               
00B57C  2               LAB_DOKE
00B57C  2  20 14 AB     	JSR	LAB_EVNM	; evaluate expression and check is numeric,
00B57F  2               				; else do type mismatch
00B57F  2  20 43 B5     	JSR	LAB_F2FX	; convert floating-to-fixed
00B582  2               
00B582  2  84 97        	STY	Frnxtl		; save pointer low byte (float to fixed returns word in AY)
00B584  2  85 98        	STA	Frnxth		; save pointer high byte
00B586  2               
00B586  2  20 46 AC     	JSR	LAB_1C01	; scan for "," , else do syntax error then warm start
00B589  2  20 14 AB     	JSR	LAB_EVNM	; evaluate expression and check is numeric,
00B58C  2               				; else do type mismatch
00B58C  2  20 43 B5     	JSR	LAB_F2FX	; convert floating-to-fixed
00B58F  2               
00B58F  2  98           	TYA			; copy value low byte (float to fixed returns word in AY)
00B590  2  A2 00        	LDX	#$00		; clear index
00B592  2  81 97        	STA	(Frnxtl,X)	; POKE low byte
00B594  2  E6 97        	INC	Frnxtl		; increment pointer low byte
00B596  2  D0 02        	BNE	Dokeh		; skip high increment if no rollover
00B598  2               
00B598  2  E6 98        	INC	Frnxth		; increment pointer high byte
00B59A  2               Dokeh
00B59A  2  A5 12        	LDA	Itemph		; get value high byte
00B59C  2  81 97        	STA	(Frnxtl,X)	; POKE high byte
00B59E  2  4C C2 00     	JMP	LAB_GBYT	; scan memory and return
00B5A1  2               
00B5A1  2               ; perform SWAP
00B5A1  2               
00B5A1  2               LAB_SWAP
00B5A1  2  20 00 AE     	JSR	LAB_GVAR	; get var1 address
00B5A4  2  85 97        	STA	Lvarpl		; save var1 address low byte
00B5A6  2  84 98        	STY	Lvarph		; save var1 address high byte
00B5A8  2  A5 5F        	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
00B5AA  2  48           	PHA			; save data type flag
00B5AB  2               
00B5AB  2  20 46 AC     	JSR	LAB_1C01	; scan for "," , else do syntax error then warm start
00B5AE  2  20 00 AE     	JSR	LAB_GVAR	; get var2 address (pointer in Cvaral/h)
00B5B1  2  68           	PLA			; pull var1 data type flag
00B5B2  2  45 5F        	EOR	Dtypef		; compare with var2 data type
00B5B4  2  10 10        	BPL	SwapErr		; exit if not both the same type
00B5B6  2               
00B5B6  2  A0 03        	LDY	#$03		; four bytes to swap (either value or descriptor+1)
00B5B8  2               SwapLp
00B5B8  2  B1 97        	LDA	(Lvarpl),Y	; get byte from var1
00B5BA  2  AA           	TAX			; save var1 byte
00B5BB  2  B1 95        	LDA	(Cvaral),Y	; get byte from var2
00B5BD  2  91 97        	STA	(Lvarpl),Y	; save byte to var1
00B5BF  2  8A           	TXA			; restore var1 byte
00B5C0  2  91 95        	STA	(Cvaral),Y	; save byte to var2
00B5C2  2  88           	DEY			; decrement index
00B5C3  2  10 F3        	BPL	SwapLp		; loop until done
00B5C5  2               
00B5C5  2  60           	RTS
00B5C6  2               
00B5C6  2               SwapErr
00B5C6  2  4C 23 AB     	JMP	LAB_1ABC	; do "Type mismatch" error then warm start
00B5C9  2               
00B5C9  2               ; perform CALL
00B5C9  2               
00B5C9  2               LAB_CALL
00B5C9  2  20 14 AB     	JSR	LAB_EVNM	; evaluate expression and check is numeric,
00B5CC  2               				; else do type mismatch
00B5CC  2  20 D2 B5     	JSR	LAB_USRVC
00B5CF  2  4C C2 00     	JMP	LAB_GBYT	; get the next byte for the interpreter and return
00B5D2  2               
00B5D2  2               ; Default USR destination
00B5D2  2               LAB_USRVC
00B5D2  2  A9 B5        	LDA	#>(CallExit-1)	; set return address high byte
00B5D4  2  48           	PHA			; put on stack
00B5D5  2  A9 E3        	LDA	#<(CallExit-1)	; set return address low byte
00B5D7  2  48           	PHA			; put on stack
00B5D8  2  20 43 B5     	JSR	LAB_F2FX	; convert floating-to-fixed
00B5DB  2  A5 07        	LDA	UsrrgA		; fetch A from $0007
00B5DD  2  A6 08        	LDX	UsrrgX		; fetch X from $0008
00B5DF  2  A4 09        	LDY	UsrrgY		; fetch Y from $0009
00B5E1  2  6C 11 00     	JMP	(Itempl)	; do indirect jump to user routine
00B5E4  2               
00B5E4  2               ; if the called routine exits correctly then it will return to here.
00B5E4  2               
00B5E4  2               CallExit
00B5E4  2  85 07        	STA	UsrrgA		; fetch A from $0007
00B5E6  2  86 08        	STX	UsrrgX		; fetch X from $0008
00B5E8  2  84 09        	STY	UsrrgY		; fetch Y from $0009
00B5EA  2  60           	RTS
00B5EB  2               
00B5EB  2               ; perform WAIT
00B5EB  2               
00B5EB  2               LAB_WAIT
00B5EB  2  20 2A B5     	JSR	LAB_GADB	; get two parameters for POKE or WAIT
00B5EE  2  86 97        	STX	Frnxtl		; save byte
00B5F0  2  A2 00        	LDX	#$00		; clear mask
00B5F2  2  20 C2 00     	JSR	LAB_GBYT	; scan memory
00B5F5  2  F0 03        	BEQ	LAB_2441	; skip if no third argument
00B5F7  2               
00B5F7  2  20 30 B5     	JSR	LAB_SCGB	; scan for "," and get byte, else SN error then warm start
00B5FA  2               LAB_2441
00B5FA  2  86 98        	STX	Frnxth		; save EOR argument
00B5FC  2               LAB_2445
00B5FC  2  B1 11        	LDA	(Itempl),Y	; get byte via temporary integer (addr)
00B5FE  2  45 98        	EOR	Frnxth		; EOR with second argument (mask)
00B600  2  25 97        	AND	Frnxtl		; AND with first argument (byte)
00B602  2  F0 F8        	BEQ	LAB_2445	; loop if result is zero
00B604  2               
00B604  2               LAB_244D
00B604  2  60           	RTS
00B605  2               
00B605  2               ; perform subtraction, FAC1 from (AY)
00B605  2               
00B605  2               LAB_2455
00B605  2  20 ED B7     	JSR	LAB_264D	; unpack memory (AY) into FAC2
00B608  2               
00B608  2               ; perform subtraction, FAC1 from FAC2
00B608  2               
00B608  2               LAB_SUBTRACT
00B608  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
00B60A  2  49 FF        	EOR	#$FF		; complement it
00B60C  2  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
00B60E  2  45 B7        	EOR	FAC2_s		; EOR with FAC2 sign (b7)
00B610  2  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
00B612  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00B614  2  4C 23 B6     	JMP	LAB_ADD		; go add FAC2 to FAC1
00B617  2               
00B617  2               ; perform addition
00B617  2               
00B617  2               LAB_2467
00B617  2  20 3C B7     	JSR	LAB_257B	; shift FACX A times right (>8 shifts)
00B61A  2  90 4D        	BCC	LAB_24A8	;.go subtract mantissas
00B61C  2               
00B61C  2               ; add 0.5 to FAC1
00B61C  2               
00B61C  2               LAB_244E
00B61C  2  A9 56        	LDA	#<LAB_2A96	; set 0.5 pointer low byte
00B61E  2  A0 C2        	LDY	#>LAB_2A96	; set 0.5 pointer high byte
00B620  2               
00B620  2               ; add (AY) to FAC1
00B620  2               
00B620  2               LAB_246C
00B620  2  20 ED B7     	JSR	LAB_264D	; unpack memory (AY) into FAC2
00B623  2               
00B623  2               ; add FAC2 to FAC1
00B623  2               
00B623  2               LAB_ADD
00B623  2  D0 10        	BNE	LAB_2474	; branch if FAC1 was not zero
00B625  2               
00B625  2               ; copy FAC2 to FAC1
00B625  2               
00B625  2               LAB_279B
00B625  2  A5 B7        	LDA	FAC2_s		; get FAC2 sign (b7)
00B627  2               
00B627  2               ; save FAC1 sign and copy ABS(FAC2) to FAC1
00B627  2               
00B627  2               LAB_279D
00B627  2  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
00B629  2  A2 04        	LDX	#$04		; 4 bytes to copy
00B62B  2               LAB_27A1
00B62B  2  B5 B2        	LDA	FAC1_o,X	; get byte from FAC2,X
00B62D  2  95 AB        	STA	FAC1_e-1,X	; save byte at FAC1,X
00B62F  2  CA           	DEX			; decrement count
00B630  2  D0 F9        	BNE	LAB_27A1	; loop if not all done
00B632  2               
00B632  2  86 B9        	STX	FAC1_r		; clear FAC1 rounding byte
00B634  2  60           	RTS
00B635  2               
00B635  2               				; FAC1 is non zero
00B635  2               LAB_2474
00B635  2  A6 B9        	LDX	FAC1_r		; get FAC1 rounding byte
00B637  2  86 A3        	STX	FAC2_r		; save as FAC2 rounding byte
00B639  2  A2 B3        	LDX	#FAC2_e		; set index to FAC2 exponent addr
00B63B  2  A5 B3        	LDA	FAC2_e		; get FAC2 exponent
00B63D  2               LAB_247C
00B63D  2  A8           	TAY			; copy exponent
00B63E  2  F0 C4        	BEQ	LAB_244D	; exit if zero
00B640  2               
00B640  2  38           	SEC			; set carry for subtract
00B641  2  E5 AC        	SBC	FAC1_e		; subtract FAC1 exponent
00B643  2  F0 24        	BEQ	LAB_24A8	; branch if = (go add mantissa)
00B645  2               
00B645  2  90 12        	BCC	LAB_2498	; branch if <
00B647  2               
00B647  2               				; FAC2>FAC1
00B647  2  84 AC        	STY	FAC1_e		; save FAC1 exponent
00B649  2  A4 B7        	LDY	FAC2_s		; get FAC2 sign (b7)
00B64B  2  84 B0        	STY	FAC1_s		; save FAC1 sign (b7)
00B64D  2  49 FF        	EOR	#$FF		; complement A
00B64F  2  69 00        	ADC	#$00		; +1 (twos complement, carry is set)
00B651  2  A0 00        	LDY	#$00		; clear Y
00B653  2  84 A3        	STY	FAC2_r		; clear FAC2 rounding byte
00B655  2  A2 AC        	LDX	#FAC1_e		; set index to FAC1 exponent addr
00B657  2  D0 04        	BNE	LAB_249C	; branch always
00B659  2               
00B659  2               LAB_2498
00B659  2  A0 00        	LDY	#$00			; clear Y
00B65B  2  84 B9        	STY	FAC1_r		; clear FAC1 rounding byte
00B65D  2               LAB_249C
00B65D  2  C9 F9        	CMP	#$F9		; compare exponent diff with $F9
00B65F  2  30 B6        	BMI	LAB_2467	; branch if range $79-$F8
00B661  2               
00B661  2  A8           	TAY			; copy exponent difference to Y
00B662  2  A5 B9        	LDA	FAC1_r		; get FAC1 rounding byte
00B664  2  56 01        	LSR	PLUS_1,X	; shift FAC? mantissa1
00B666  2  20 53 B7     	JSR	LAB_2592	; shift FACX Y times right
00B669  2               
00B669  2               				; exponents are equal now do mantissa subtract
00B669  2               LAB_24A8
00B669  2  24 B8        	BIT	FAC_sc		; test sign compare (FAC1 EOR FAC2)
00B66B  2  10 4C        	BPL	LAB_24F8	; if = add FAC2 mantissa to FAC1 mantissa and return
00B66D  2               
00B66D  2  A0 AC        	LDY	#FAC1_e		; set index to FAC1 exponent addr
00B66F  2  E0 B3        	CPX	#FAC2_e		; compare X to FAC2 exponent addr
00B671  2  F0 02        	BEQ	LAB_24B4	; branch if =
00B673  2               
00B673  2  A0 B3        	LDY	#FAC2_e		; else set index to FAC2 exponent addr
00B675  2               
00B675  2               				; subtract smaller from bigger (take sign of bigger)
00B675  2               LAB_24B4
00B675  2  38           	SEC			; set carry for subtract
00B676  2  49 FF        	EOR	#$FF		; ones complement A
00B678  2  65 A3        	ADC	FAC2_r		; add FAC2 rounding byte
00B67A  2  85 B9        	STA	FAC1_r		; save FAC1 rounding byte
00B67C  2  B9 03 00     	LDA	PLUS_3,Y	; get FACY mantissa3
00B67F  2  F5 03        	SBC	PLUS_3,X	; subtract FACX mantissa3
00B681  2  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
00B683  2  B9 02 00     	LDA	PLUS_2,Y	; get FACY mantissa2
00B686  2  F5 02        	SBC	PLUS_2,X	; subtract FACX mantissa2
00B688  2  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
00B68A  2  B9 01 00     	LDA	PLUS_1,Y	; get FACY mantissa1
00B68D  2  F5 01        	SBC	PLUS_1,X	; subtract FACX mantissa1
00B68F  2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
00B691  2               
00B691  2               ; do ABS and normalise FAC1
00B691  2               
00B691  2               LAB_24D0
00B691  2  B0 03        	BCS	LAB_24D5	; branch if number is +ve
00B693  2               
00B693  2  20 F8 B6     	JSR	LAB_2537	; negate FAC1
00B696  2               
00B696  2               ; normalise FAC1
00B696  2               
00B696  2               LAB_24D5
00B696  2  A0 00        	LDY	#$00		; clear Y
00B698  2  98           	TYA			; clear A
00B699  2  18           	CLC			; clear carry for add
00B69A  2               LAB_24D9
00B69A  2  A6 AD        	LDX	FAC1_1		; get FAC1 mantissa1
00B69C  2  D0 3E        	BNE	LAB_251B	; if not zero normalise FAC1
00B69E  2               
00B69E  2  A6 AE        	LDX	FAC1_2		; get FAC1 mantissa2
00B6A0  2  86 AD        	STX	FAC1_1		; save FAC1 mantissa1
00B6A2  2  A6 AF        	LDX	FAC1_3		; get FAC1 mantissa3
00B6A4  2  86 AE        	STX	FAC1_2		; save FAC1 mantissa2
00B6A6  2  A6 B9        	LDX	FAC1_r		; get FAC1 rounding byte
00B6A8  2  86 AF        	STX	FAC1_3		; save FAC1 mantissa3
00B6AA  2  84 B9        	STY	FAC1_r		; clear FAC1 rounding byte
00B6AC  2  69 08        	ADC	#$08		; add x to exponent offset
00B6AE  2  C9 18        	CMP	#$18		; compare with $18 (max offset, all bits would be =0)
00B6B0  2  D0 E8        	BNE	LAB_24D9	; loop if not max
00B6B2  2               
00B6B2  2               ; clear FAC1 exponent and sign
00B6B2  2               
00B6B2  2               LAB_24F1
00B6B2  2  A9 00        	LDA	#$00		; clear A
00B6B4  2               LAB_24F3
00B6B4  2  85 AC        	STA	FAC1_e		; set FAC1 exponent
00B6B6  2               
00B6B6  2               ; save FAC1 sign
00B6B6  2               
00B6B6  2               LAB_24F5
00B6B6  2  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
00B6B8  2  60           	RTS
00B6B9  2               
00B6B9  2               ; add FAC2 mantissa to FAC1 mantissa
00B6B9  2               
00B6B9  2               LAB_24F8
00B6B9  2  65 A3        	ADC	FAC2_r		; add FAC2 rounding byte
00B6BB  2  85 B9        	STA	FAC1_r		; save FAC1 rounding byte
00B6BD  2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
00B6BF  2  65 B6        	ADC	FAC2_3		; add FAC2 mantissa3
00B6C1  2  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
00B6C3  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
00B6C5  2  65 B5        	ADC	FAC2_2		; add FAC2 mantissa2
00B6C7  2  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
00B6C9  2  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
00B6CB  2  65 B4        	ADC	FAC2_1		; add FAC2 mantissa1
00B6CD  2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
00B6CF  2  B0 1A        	BCS	LAB_252A	; if carry then normalise FAC1 for C=1
00B6D1  2               
00B6D1  2  60           	RTS			; else just exit
00B6D2  2               
00B6D2  2               LAB_2511
00B6D2  2  69 01        	ADC	#$01		; add 1 to exponent offset
00B6D4  2  06 B9        	ASL	FAC1_r		; shift FAC1 rounding byte
00B6D6  2  26 AF        	ROL	FAC1_3		; shift FAC1 mantissa3
00B6D8  2  26 AE        	ROL	FAC1_2		; shift FAC1 mantissa2
00B6DA  2  26 AD        	ROL	FAC1_1		; shift FAC1 mantissa1
00B6DC  2               
00B6DC  2               ; normalise FAC1
00B6DC  2               
00B6DC  2               LAB_251B
00B6DC  2  10 F4        	BPL	LAB_2511	; loop if not normalised
00B6DE  2               
00B6DE  2  38           	SEC			; set carry for subtract
00B6DF  2  E5 AC        	SBC	FAC1_e		; subtract FAC1 exponent
00B6E1  2  B0 CF        	BCS	LAB_24F1	; branch if underflow (set result = $0)
00B6E3  2               
00B6E3  2  49 FF        	EOR	#$FF		; complement exponent
00B6E5  2  69 01        	ADC	#$01		; +1 (twos complement)
00B6E7  2  85 AC        	STA	FAC1_e		; save FAC1 exponent
00B6E9  2               
00B6E9  2               ; test and normalise FAC1 for C=0/1
00B6E9  2               
00B6E9  2               LAB_2528
00B6E9  2  90 0C        	BCC	LAB_2536	; exit if no overflow
00B6EB  2               
00B6EB  2               ; normalise FAC1 for C=1
00B6EB  2               
00B6EB  2               LAB_252A
00B6EB  2  E6 AC        	INC	FAC1_e		; increment FAC1 exponent
00B6ED  2  F0 36        	BEQ	LAB_2564	; if zero do overflow error and warm start
00B6EF  2               
00B6EF  2  66 AD        	ROR	FAC1_1		; shift FAC1 mantissa1
00B6F1  2  66 AE        	ROR	FAC1_2		; shift FAC1 mantissa2
00B6F3  2  66 AF        	ROR	FAC1_3		; shift FAC1 mantissa3
00B6F5  2  66 B9        	ROR	FAC1_r		; shift FAC1 rounding byte
00B6F7  2               LAB_2536
00B6F7  2  60           	RTS
00B6F8  2               
00B6F8  2               ; negate FAC1
00B6F8  2               
00B6F8  2               LAB_2537
00B6F8  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
00B6FA  2  49 FF        	EOR	#$FF		; complement it
00B6FC  2  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
00B6FE  2               
00B6FE  2               ; twos complement FAC1 mantissa
00B6FE  2               
00B6FE  2               LAB_253D
00B6FE  2  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
00B700  2  49 FF        	EOR	#$FF		; complement it
00B702  2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
00B704  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
00B706  2  49 FF        	EOR	#$FF		; complement it
00B708  2  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
00B70A  2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
00B70C  2  49 FF        	EOR	#$FF		; complement it
00B70E  2  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
00B710  2  A5 B9        	LDA	FAC1_r		; get FAC1 rounding byte
00B712  2  49 FF        	EOR	#$FF		; complement it
00B714  2  85 B9        	STA	FAC1_r		; save FAC1 rounding byte
00B716  2  E6 B9        	INC	FAC1_r		; increment FAC1 rounding byte
00B718  2  D0 0A        	BNE	LAB_2563	; exit if no overflow
00B71A  2               
00B71A  2               ; increment FAC1 mantissa
00B71A  2               
00B71A  2               LAB_2559
00B71A  2  E6 AF        	INC	FAC1_3		; increment FAC1 mantissa3
00B71C  2  D0 06        	BNE	LAB_2563	; finished if no rollover
00B71E  2               
00B71E  2  E6 AE        	INC	FAC1_2		; increment FAC1 mantissa2
00B720  2  D0 02        	BNE	LAB_2563	; finished if no rollover
00B722  2               
00B722  2  E6 AD        	INC	FAC1_1		; increment FAC1 mantissa1
00B724  2               LAB_2563
00B724  2  60           	RTS
00B725  2               
00B725  2               ; do overflow error (overflow exit)
00B725  2               
00B725  2               LAB_2564
00B725  2  A2 0A        	LDX	#$0A		; error code $0A ("Overflow" error)
00B727  2  4C 4C A1     	JMP	LAB_XERR	; do error #X, then warm start
00B72A  2               
00B72A  2               ; shift FCAtemp << A+8 times
00B72A  2               
00B72A  2               LAB_2569
00B72A  2  A2 74        	LDX	#FACt_1-1	; set offset to FACtemp
00B72C  2               LAB_256B
00B72C  2  B4 03        	LDY	PLUS_3,X	; get FACX mantissa3
00B72E  2  84 B9        	STY	FAC1_r		; save as FAC1 rounding byte
00B730  2  B4 02        	LDY	PLUS_2,X	; get FACX mantissa2
00B732  2  94 03        	STY	PLUS_3,X	; save FACX mantissa3
00B734  2  B4 01        	LDY	PLUS_1,X	; get FACX mantissa1
00B736  2  94 02        	STY	PLUS_2,X	; save FACX mantissa2
00B738  2  A4 B2        	LDY	FAC1_o		; get FAC1 overflow byte
00B73A  2  94 01        	STY	PLUS_1,X	; save FACX mantissa1
00B73C  2               
00B73C  2               ; shift FACX -A times right (> 8 shifts)
00B73C  2               
00B73C  2               LAB_257B
00B73C  2  69 08        	ADC	#$08		; add 8 to shift count
00B73E  2  30 EC        	BMI	LAB_256B	; go do 8 shift if still -ve
00B740  2               
00B740  2  F0 EA        	BEQ	LAB_256B	; go do 8 shift if zero
00B742  2               
00B742  2  E9 08        	SBC	#$08		; else subtract 8 again
00B744  2  A8           	TAY			; save count to Y
00B745  2  A5 B9        	LDA	FAC1_r		; get FAC1 rounding byte
00B747  2  B0 12        	BCS	LAB_259A	;.
00B749  2               
00B749  2               LAB_2588
00B749  2  16 01        	ASL	PLUS_1,X	; shift FACX mantissa1
00B74B  2  90 02        	BCC	LAB_258E	; branch if +ve
00B74D  2               
00B74D  2  F6 01        	INC	PLUS_1,X	; this sets b7 eventually
00B74F  2               LAB_258E
00B74F  2  76 01        	ROR	PLUS_1,X	; shift FACX mantissa1 (correct for ASL)
00B751  2  76 01        	ROR	PLUS_1,X	; shift FACX mantissa1 (put carry in b7)
00B753  2               
00B753  2               ; shift FACX Y times right
00B753  2               
00B753  2               LAB_2592
00B753  2  76 02        	ROR	PLUS_2,X	; shift FACX mantissa2
00B755  2  76 03        	ROR	PLUS_3,X	; shift FACX mantissa3
00B757  2  6A           	ROR			; shift FACX rounding byte
00B758  2  C8           	INY			; increment exponent diff
00B759  2  D0 EE        	BNE	LAB_2588	; branch if range adjust not complete
00B75B  2               
00B75B  2               LAB_259A
00B75B  2  18           	CLC			; just clear it
00B75C  2  60           	RTS
00B75D  2               
00B75D  2               ; perform LOG()
00B75D  2               
00B75D  2               LAB_LOG
00B75D  2  20 4B B9     	JSR	LAB_27CA	; test sign and zero
00B760  2  F0 02        	BEQ	LAB_25C4	; if zero do function call error then warm start
00B762  2               
00B762  2  10 03        	BPL	LAB_25C7	; skip error if +ve
00B764  2               
00B764  2               LAB_25C4
00B764  2  4C 7F AF     	JMP	LAB_FCER	; do function call error then warm start (-ve)
00B767  2               
00B767  2               LAB_25C7
00B767  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00B769  2  E9 7F        	SBC	#$7F		; normalise it
00B76B  2  48           	PHA			; save it
00B76C  2  A9 80        	LDA	#$80		; set exponent to zero
00B76E  2  85 AC        	STA	FAC1_e		; save FAC1 exponent
00B770  2  A9 D6        	LDA	#<LAB_25AD	; set 1/root2 pointer low byte
00B772  2  A0 C1        	LDY	#>LAB_25AD	; set 1/root2 pointer high byte
00B774  2  20 20 B6     	JSR	LAB_246C	; add (AY) to FAC1 (1/root2)
00B777  2  A9 DA        	LDA	#<LAB_25B1	; set root2 pointer low byte
00B779  2  A0 C1        	LDY	#>LAB_25B1	; set root2 pointer high byte
00B77B  2  20 63 B8     	JSR	LAB_26CA	; convert AY and do (AY)/FAC1 (root2/(x+(1/root2)))
00B77E  2  A9 4D        	LDA	#<LAB_259C	; set 1 pointer low byte
00B780  2  A0 C2        	LDY	#>LAB_259C	; set 1 pointer high byte
00B782  2  20 05 B6     	JSR	LAB_2455	; subtract (AY) from FAC1 ((root2/(x+(1/root2)))-1)
00B785  2  A9 C9        	LDA	#<LAB_25A0	; set pointer low byte to counter
00B787  2  A0 C1        	LDY	#>LAB_25A0	; set pointer high byte to counter
00B789  2  20 B4 BC     	JSR	LAB_2B6E	; ^2 then series evaluation
00B78C  2  A9 DE        	LDA	#<LAB_25B5	; set -0.5 pointer low byte
00B78E  2  A0 C1        	LDY	#>LAB_25B5	; set -0.5 pointer high byte
00B790  2  20 20 B6     	JSR	LAB_246C	; add (AY) to FAC1
00B793  2  68           	PLA			; restore FAC1 exponent
00B794  2  20 A7 BA     	JSR	LAB_2912	; evaluate new ASCII digit
00B797  2  A9 E2        	LDA	#<LAB_25B9	; set LOG(2) pointer low byte
00B799  2  A0 C1        	LDY	#>LAB_25B9	; set LOG(2) pointer high byte
00B79B  2               
00B79B  2               ; do convert AY, FCA1*(AY)
00B79B  2               
00B79B  2               LAB_25FB
00B79B  2  20 ED B7     	JSR	LAB_264D	; unpack memory (AY) into FAC2
00B79E  2               LAB_MULTIPLY
00B79E  2  F0 4C        	BEQ	LAB_264C	; exit if zero
00B7A0  2               
00B7A0  2  20 13 B8     	JSR	LAB_2673	; test and adjust accumulators
00B7A3  2  A9 00        	LDA	#$00		; clear A
00B7A5  2  85 75        	STA	FACt_1		; clear temp mantissa1
00B7A7  2  85 76        	STA	FACt_2		; clear temp mantissa2
00B7A9  2  85 77        	STA	FACt_3		; clear temp mantissa3
00B7AB  2  A5 B9        	LDA	FAC1_r		; get FAC1 rounding byte
00B7AD  2  20 C2 B7     	JSR	LAB_2622	; go do shift/add FAC2
00B7B0  2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
00B7B2  2  20 C2 B7     	JSR	LAB_2622	; go do shift/add FAC2
00B7B5  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
00B7B7  2  20 C2 B7     	JSR	LAB_2622	; go do shift/add FAC2
00B7BA  2  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
00B7BC  2  20 C8 B7     	JSR	LAB_2627	; go do shift/add FAC2
00B7BF  2  4C D0 B8     	JMP	LAB_273C	; copy temp to FAC1, normalise and return
00B7C2  2               
00B7C2  2               LAB_2622
00B7C2  2  D0 04        	BNE	LAB_2627	; branch if byte <> zero
00B7C4  2               ; *** begin patch  2.22p5.6  floating point multiply rounding bug
00B7C4  2               ; *** replace
00B7C4  2               ;	JMP	LAB_2569	; shift FCAtemp << A+8 times
00B7C4  2               ;
00B7C4  2               ;				; else do shift and add
00B7C4  2               ;LAB_2627
00B7C4  2               ;	LSR			; shift byte
00B7C4  2               ;	ORA	#$80		; set top bit (mark for 8 times)
00B7C4  2               ; *** with
00B7C4  2  38           	SEC
00B7C5  2  4C 2A B7     	JMP	LAB_2569	; shift FACtemp << A+8 times
00B7C8  2               
00B7C8  2               				; else do shift and add
00B7C8  2               LAB_2627
00B7C8  2  38           	SEC			; set top bit (mark for 8 times)
00B7C9  2  6A           	ROR
00B7CA  2               ; *** end patch    2.22p5.6  floating point multiply rounding bug
00B7CA  2               LAB_262A
00B7CA  2  A8           	TAY			; copy result
00B7CB  2  90 13        	BCC	LAB_2640	; skip next if bit was zero
00B7CD  2               
00B7CD  2  18           	CLC			; clear carry for add
00B7CE  2  A5 77        	LDA	FACt_3		; get temp mantissa3
00B7D0  2  65 B6        	ADC	FAC2_3		; add FAC2 mantissa3
00B7D2  2  85 77        	STA	FACt_3		; save temp mantissa3
00B7D4  2  A5 76        	LDA	FACt_2		; get temp mantissa2
00B7D6  2  65 B5        	ADC	FAC2_2		; add FAC2 mantissa2
00B7D8  2  85 76        	STA	FACt_2		; save temp mantissa2
00B7DA  2  A5 75        	LDA	FACt_1		; get temp mantissa1
00B7DC  2  65 B4        	ADC	FAC2_1		; add FAC2 mantissa1
00B7DE  2  85 75        	STA	FACt_1		; save temp mantissa1
00B7E0  2               LAB_2640
00B7E0  2  66 75        	ROR	FACt_1		; shift temp mantissa1
00B7E2  2  66 76        	ROR	FACt_2		; shift temp mantissa2
00B7E4  2  66 77        	ROR	FACt_3		; shift temp mantissa3
00B7E6  2  66 B9        	ROR	FAC1_r		; shift temp rounding byte
00B7E8  2  98           	TYA			; get byte back
00B7E9  2  4A           	LSR			; shift byte
00B7EA  2  D0 DE        	BNE	LAB_262A	; loop if all bits not done
00B7EC  2               
00B7EC  2               LAB_264C
00B7EC  2  60           	RTS
00B7ED  2               
00B7ED  2               ; unpack memory (AY) into FAC2
00B7ED  2               
00B7ED  2               LAB_264D
00B7ED  2  85 71        	STA	ut1_pl		; save pointer low byte
00B7EF  2  84 72        	STY	ut1_ph		; save pointer high byte
00B7F1  2  A0 03        	LDY	#$03		; 4 bytes to get (0-3)
00B7F3  2  B1 71        	LDA	(ut1_pl),Y	; get mantissa3
00B7F5  2  85 B6        	STA	FAC2_3		; save FAC2 mantissa3
00B7F7  2  88           	DEY			; decrement index
00B7F8  2  B1 71        	LDA	(ut1_pl),Y	; get mantissa2
00B7FA  2  85 B5        	STA	FAC2_2		; save FAC2 mantissa2
00B7FC  2  88           	DEY			; decrement index
00B7FD  2  B1 71        	LDA	(ut1_pl),Y	; get mantissa1+sign
00B7FF  2  85 B7        	STA	FAC2_s		; save FAC2 sign (b7)
00B801  2  45 B0        	EOR	FAC1_s		; EOR with FAC1 sign (b7)
00B803  2  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
00B805  2  A5 B7        	LDA	FAC2_s		; recover FAC2 sign (b7)
00B807  2  09 80        	ORA	#$80		; set 1xxx xxx (set normal bit)
00B809  2  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
00B80B  2  88           	DEY			; decrement index
00B80C  2  B1 71        	LDA	(ut1_pl),Y	; get exponent byte
00B80E  2  85 B3        	STA	FAC2_e		; save FAC2 exponent
00B810  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00B812  2  60           	RTS
00B813  2               
00B813  2               ; test and adjust accumulators
00B813  2               
00B813  2               LAB_2673
00B813  2  A5 B3        	LDA	FAC2_e		; get FAC2 exponent
00B815  2               LAB_2675
00B815  2  F0 1D        	BEQ	LAB_2696	; branch if FAC2 = $00 (handle underflow)
00B817  2               
00B817  2  18           	CLC			; clear carry for add
00B818  2  65 AC        	ADC	FAC1_e		; add FAC1 exponent
00B81A  2  90 04        	BCC	LAB_2680	; branch if sum of exponents <$0100
00B81C  2               
00B81C  2  30 31        	BMI	LAB_269B	; do overflow error
00B81E  2               
00B81E  2  18           	CLC			; clear carry for the add
00B81F  2  2C           	.byte	$2C		; makes next line BIT $1410
00B820  2               LAB_2680
00B820  2  10 12        	BPL	LAB_2696	; if +ve go handle underflow
00B822  2               
00B822  2  69 80        	ADC	#$80		; adjust exponent
00B824  2  85 AC        	STA	FAC1_e		; save FAC1 exponent
00B826  2  D0 03        	BNE	LAB_268B	; branch if not zero
00B828  2               
00B828  2  4C B6 B6     	JMP	LAB_24F5	; save FAC1 sign and return
00B82B  2               
00B82B  2               LAB_268B
00B82B  2  A5 B8        	LDA	FAC_sc		; get sign compare (FAC1 EOR FAC2)
00B82D  2  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
00B82F  2               LAB_268F
00B82F  2  60           	RTS
00B830  2               
00B830  2               ; handle overflow and underflow
00B830  2               
00B830  2               LAB_2690
00B830  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
00B832  2  10 1B        	BPL	LAB_269B	; do overflow error
00B834  2               
00B834  2               				; handle underflow
00B834  2               LAB_2696
00B834  2  68           	PLA			; pop return address low byte
00B835  2  68           	PLA			; pop return address high byte
00B836  2  4C B2 B6     	JMP	LAB_24F1	; clear FAC1 exponent and sign and return
00B839  2               
00B839  2               ; multiply by 10
00B839  2               
00B839  2               LAB_269E
00B839  2  20 2C B9     	JSR	LAB_27AB	; round and copy FAC1 to FAC2
00B83C  2  AA           	TAX			; copy exponent (set the flags)
00B83D  2  F0 F0        	BEQ	LAB_268F	; exit if zero
00B83F  2               
00B83F  2  18           	CLC			; clear carry for add
00B840  2  69 02        	ADC	#$02		; add two to exponent (*4)
00B842  2  B0 0B        	BCS	LAB_269B	; do overflow error if > $FF
00B844  2               
00B844  2  A2 00        	LDX	#$00		; clear byte
00B846  2  86 B8        	STX	FAC_sc		; clear sign compare (FAC1 EOR FAC2)
00B848  2  20 3D B6     	JSR	LAB_247C	; add FAC2 to FAC1 (*5)
00B84B  2  E6 AC        	INC	FAC1_e		; increment FAC1 exponent (*10)
00B84D  2  D0 E0        	BNE	LAB_268F	; if non zero just do RTS
00B84F  2               
00B84F  2               LAB_269B
00B84F  2  4C 25 B7     	JMP	LAB_2564	; do overflow error and warm start
00B852  2               
00B852  2               ; divide by 10
00B852  2               
00B852  2               LAB_26B9
00B852  2  20 2C B9     	JSR	LAB_27AB	; round and copy FAC1 to FAC2
00B855  2  A9 5E        	LDA	#<LAB_26B5	; set pointer to 10d low addr
00B857  2  A0 C2        	LDY	#>LAB_26B5	; set pointer to 10d high addr
00B859  2  A2 00        	LDX	#$00		; clear sign
00B85B  2               
00B85B  2               ; divide by (AY) (X=sign)
00B85B  2               
00B85B  2               LAB_26C2
00B85B  2  86 B8        	STX	FAC_sc		; save sign compare (FAC1 EOR FAC2)
00B85D  2  20 DF B8     	JSR	LAB_UFAC	; unpack memory (AY) into FAC1
00B860  2  4C 66 B8     	JMP	LAB_DIVIDE	; do FAC2/FAC1
00B863  2               
00B863  2               				; Perform divide-by
00B863  2               ; convert AY and do (AY)/FAC1
00B863  2               
00B863  2               LAB_26CA
00B863  2  20 ED B7     	JSR	LAB_264D	; unpack memory (AY) into FAC2
00B866  2               
00B866  2               				; Perform divide-into
00B866  2               LAB_DIVIDE
00B866  2  F0 63        	BEQ	LAB_2737	; if zero go do /0 error
00B868  2               
00B868  2  20 3B B9     	JSR	LAB_27BA	; round FAC1
00B86B  2  A9 00        	LDA	#$00		; clear A
00B86D  2  38           	SEC			; set carry for subtract
00B86E  2  E5 AC        	SBC	FAC1_e		; subtract FAC1 exponent (2s complement)
00B870  2  85 AC        	STA	FAC1_e		; save FAC1 exponent
00B872  2  20 13 B8     	JSR	LAB_2673	; test and adjust accumulators
00B875  2  E6 AC        	INC	FAC1_e		; increment FAC1 exponent
00B877  2  F0 D6        	BEQ	LAB_269B	; if zero do overflow error
00B879  2               
00B879  2  A2 FF        	LDX	#$FF		; set index for pre increment
00B87B  2  A9 01        	LDA	#$01		; set bit to flag byte save
00B87D  2               LAB_26E4
00B87D  2  A4 B4        	LDY	FAC2_1		; get FAC2 mantissa1
00B87F  2  C4 AD        	CPY	FAC1_1		; compare FAC1 mantissa1
00B881  2  D0 0A        	BNE	LAB_26F4	; branch if <>
00B883  2               
00B883  2  A4 B5        	LDY	FAC2_2		; get FAC2 mantissa2
00B885  2  C4 AE        	CPY	FAC1_2		; compare FAC1 mantissa2
00B887  2  D0 04        	BNE	LAB_26F4	; branch if <>
00B889  2               
00B889  2  A4 B6        	LDY	FAC2_3		; get FAC2 mantissa3
00B88B  2  C4 AF        	CPY	FAC1_3		; compare FAC1 mantissa3
00B88D  2               LAB_26F4
00B88D  2  08           	PHP			; save FAC2-FAC1 compare status
00B88E  2  2A           	ROL			; shift the result byte
00B88F  2  90 0E        	BCC	LAB_2702	; if no carry skip the byte save
00B891  2               
00B891  2  A0 01        	LDY	#$01		; set bit to flag byte save
00B893  2  E8           	INX			; else increment the index to FACt
00B894  2  E0 02        	CPX	#$02		; compare with the index to FACt_3
00B896  2  30 04        	BMI	LAB_2701	; if not last byte just go save it
00B898  2               
00B898  2  D0 28        	BNE	LAB_272B	; if all done go save FAC1 rounding byte, normalise and
00B89A  2               				; return
00B89A  2               
00B89A  2  A0 40        	LDY	#$40		; set bit to flag byte save for the rounding byte
00B89C  2               LAB_2701
00B89C  2  95 75        	STA	FACt_1,X	; write result byte to FACt_1 + index
00B89E  2  98           	TYA			; copy the next save byte flag
00B89F  2               LAB_2702
00B89F  2  28           	PLP			; restore FAC2-FAC1 compare status
00B8A0  2  90 14        	BCC	LAB_2704	; if FAC2 < FAC1 then skip the subtract
00B8A2  2               
00B8A2  2  A8           	TAY			; save FAC2-FAC1 compare status
00B8A3  2  A5 B6        	LDA	FAC2_3		; get FAC2 mantissa3
00B8A5  2  E5 AF        	SBC	FAC1_3		; subtract FAC1 mantissa3
00B8A7  2  85 B6        	STA	FAC2_3		; save FAC2 mantissa3
00B8A9  2  A5 B5        	LDA	FAC2_2		; get FAC2 mantissa2
00B8AB  2  E5 AE        	SBC	FAC1_2		; subtract FAC1 mantissa2
00B8AD  2  85 B5        	STA	FAC2_2		; save FAC2 mantissa2
00B8AF  2  A5 B4        	LDA	FAC2_1		; get FAC2 mantissa1
00B8B1  2  E5 AD        	SBC	FAC1_1		; subtract FAC1 mantissa1
00B8B3  2  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
00B8B5  2  98           	TYA			; restore FAC2-FAC1 compare status
00B8B6  2               
00B8B6  2               				; FAC2 = FAC2*2
00B8B6  2               LAB_2704
00B8B6  2  06 B6        	ASL	FAC2_3		; shift FAC2 mantissa3
00B8B8  2  26 B5        	ROL	FAC2_2		; shift FAC2 mantissa2
00B8BA  2  26 B4        	ROL	FAC2_1		; shift FAC2 mantissa1
00B8BC  2  B0 CF        	BCS	LAB_26F4	; loop with no compare
00B8BE  2               
00B8BE  2  30 BD        	BMI	LAB_26E4	; loop with compare
00B8C0  2               
00B8C0  2  10 CB        	BPL	LAB_26F4	; loop always with no compare
00B8C2  2               
00B8C2  2               ; do A<<6, save as FAC1 rounding byte, normalise and return
00B8C2  2               
00B8C2  2               LAB_272B
00B8C2  2  4A           	LSR			; shift b1 - b0 ..
00B8C3  2  6A           	ROR			; ..
00B8C4  2  6A           	ROR			; .. to b7 - b6
00B8C5  2  85 B9        	STA	FAC1_r		; save FAC1 rounding byte
00B8C7  2  28           	PLP			; dump FAC2-FAC1 compare status
00B8C8  2  4C D0 B8     	JMP	LAB_273C	; copy temp to FAC1, normalise and return
00B8CB  2               
00B8CB  2               ; do "Divide by zero" error
00B8CB  2               
00B8CB  2               LAB_2737
00B8CB  2  A2 14        	LDX	#$14		; error code $14 ("Divide by zero" error)
00B8CD  2  4C 4C A1     	JMP	LAB_XERR	; do error #X, then warm start
00B8D0  2               
00B8D0  2               ; copy temp to FAC1 and normalise
00B8D0  2               
00B8D0  2               LAB_273C
00B8D0  2  A5 75        	LDA	FACt_1		; get temp mantissa1
00B8D2  2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
00B8D4  2  A5 76        	LDA	FACt_2		; get temp mantissa2
00B8D6  2  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
00B8D8  2  A5 77        	LDA	FACt_3		; get temp mantissa3
00B8DA  2  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
00B8DC  2  4C 96 B6     	JMP	LAB_24D5	; normalise FAC1 and return
00B8DF  2               
00B8DF  2               ; unpack memory (AY) into FAC1
00B8DF  2               
00B8DF  2               LAB_UFAC
00B8DF  2  85 71        	STA	ut1_pl		; save pointer low byte
00B8E1  2  84 72        	STY	ut1_ph		; save pointer high byte
00B8E3  2  A0 03        	LDY	#$03		; 4 bytes to do
00B8E5  2  B1 71        	LDA	(ut1_pl),Y	; get last byte
00B8E7  2  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
00B8E9  2  88           	DEY			; decrement index
00B8EA  2  B1 71        	LDA	(ut1_pl),Y	; get last-1 byte
00B8EC  2  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
00B8EE  2  88           	DEY			; decrement index
00B8EF  2  B1 71        	LDA	(ut1_pl),Y	; get second byte
00B8F1  2  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
00B8F3  2  09 80        	ORA	#$80		; set 1xxx xxxx (add normal bit)
00B8F5  2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
00B8F7  2  88           	DEY			; decrement index
00B8F8  2  B1 71        	LDA	(ut1_pl),Y	; get first byte (exponent)
00B8FA  2  85 AC        	STA	FAC1_e		; save FAC1 exponent
00B8FC  2  84 B9        	STY	FAC1_r		; clear FAC1 rounding byte
00B8FE  2  60           	RTS
00B8FF  2               
00B8FF  2               ; pack FAC1 into Adatal
00B8FF  2               
00B8FF  2               LAB_276E
00B8FF  2  A2 A4        	LDX	#<Adatal	; set pointer low byte
00B901  2               LAB_2770
00B901  2  A0 00        	LDY	#>Adatal	; set pointer high byte
00B903  2  F0 04        	BEQ	LAB_2778	; pack FAC1 into (XY) and return
00B905  2               
00B905  2               ; pack FAC1 into (Lvarpl)
00B905  2               
00B905  2               LAB_PFAC
00B905  2  A6 97        	LDX	Lvarpl		; get destination pointer low byte
00B907  2  A4 98        	LDY	Lvarph		; get destination pointer high byte
00B909  2               
00B909  2               ; pack FAC1 into (XY)
00B909  2               
00B909  2               LAB_2778
00B909  2  20 3B B9     	JSR	LAB_27BA	; round FAC1
00B90C  2  86 71        	STX	ut1_pl		; save pointer low byte
00B90E  2  84 72        	STY	ut1_ph		; save pointer high byte
00B910  2  A0 03        	LDY	#$03		; set index
00B912  2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
00B914  2  91 71        	STA	(ut1_pl),Y	; store in destination
00B916  2  88           	DEY			; decrement index
00B917  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
00B919  2  91 71        	STA	(ut1_pl),Y	; store in destination
00B91B  2  88           	DEY			; decrement index
00B91C  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
00B91E  2  09 7F        	ORA	#$7F		; set bits x111 1111
00B920  2  25 AD        	AND	FAC1_1		; AND in FAC1 mantissa1
00B922  2  91 71        	STA	(ut1_pl),Y	; store in destination
00B924  2  88           	DEY			; decrement index
00B925  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00B927  2  91 71        	STA	(ut1_pl),Y	; store in destination
00B929  2  84 B9        	STY	FAC1_r		; clear FAC1 rounding byte
00B92B  2  60           	RTS
00B92C  2               
00B92C  2               ; round and copy FAC1 to FAC2
00B92C  2               
00B92C  2               LAB_27AB
00B92C  2  20 3B B9     	JSR	LAB_27BA	; round FAC1
00B92F  2               
00B92F  2               ; copy FAC1 to FAC2
00B92F  2               
00B92F  2               LAB_27AE
00B92F  2  A2 05        	LDX	#$05		; 5 bytes to copy
00B931  2               LAB_27B0
00B931  2  B5 AB        	LDA	FAC1_e-1,X	; get byte from FAC1,X
00B933  2  95 B2        	STA	FAC1_o,X	; save byte at FAC2,X
00B935  2  CA           	DEX			; decrement count
00B936  2  D0 F9        	BNE	LAB_27B0	; loop if not all done
00B938  2               
00B938  2  86 B9        	STX	FAC1_r		; clear FAC1 rounding byte
00B93A  2               LAB_27B9
00B93A  2  60           	RTS
00B93B  2               
00B93B  2               ; round FAC1
00B93B  2               
00B93B  2               LAB_27BA
00B93B  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00B93D  2  F0 FB        	BEQ	LAB_27B9		; exit if zero
00B93F  2               
00B93F  2  06 B9        	ASL	FAC1_r		; shift FAC1 rounding byte
00B941  2  90 F7        	BCC	LAB_27B9	; exit if no overflow
00B943  2               
00B943  2               ; round FAC1 (no check)
00B943  2               
00B943  2               LAB_27C2
00B943  2  20 1A B7     	JSR	LAB_2559	; increment FAC1 mantissa
00B946  2  D0 F2        	BNE	LAB_27B9	; branch if no overflow
00B948  2               
00B948  2  4C EB B6     	JMP	LAB_252A	; normalise FAC1 for C=1 and return
00B94B  2               
00B94B  2               ; get FAC1 sign
00B94B  2               ; return A=FF,C=1/-ve A=01,C=0/+ve
00B94B  2               
00B94B  2               LAB_27CA
00B94B  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00B94D  2  F0 09        	BEQ	LAB_27D7	; exit if zero (already correct SGN(0)=0)
00B94F  2               
00B94F  2               ; return A=FF,C=1/-ve A=01,C=0/+ve
00B94F  2               ; no = 0 check
00B94F  2               
00B94F  2               LAB_27CE
00B94F  2  A5 B0        	LDA	FAC1_s		; else get FAC1 sign (b7)
00B951  2               
00B951  2               ; return A=FF,C=1/-ve A=01,C=0/+ve
00B951  2               ; no = 0 check, sign in A
00B951  2               
00B951  2               LAB_27D0
00B951  2  2A           	ROL			; move sign bit to carry
00B952  2  A9 FF        	LDA	#$FF		; set byte for -ve result
00B954  2  B0 02        	BCS	LAB_27D7	; return if sign was set (-ve)
00B956  2               
00B956  2  A9 01        	LDA	#$01		; else set byte for +ve result
00B958  2               LAB_27D7
00B958  2  60           	RTS
00B959  2               
00B959  2               ; perform SGN()
00B959  2               
00B959  2               LAB_SGN
00B959  2  20 4B B9     	JSR	LAB_27CA	; get FAC1 sign
00B95C  2               				; return A=$FF/-ve A=$01/+ve
00B95C  2               ; save A as integer byte
00B95C  2               
00B95C  2               LAB_27DB
00B95C  2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
00B95E  2  A9 00        	LDA	#$00		; clear A
00B960  2  85 AE        	STA	FAC1_2		; clear FAC1 mantissa2
00B962  2  A2 88        	LDX	#$88		; set exponent
00B964  2               
00B964  2               ; set exp=X, clearFAC1 mantissa3 and normalise
00B964  2               
00B964  2               LAB_27E3
00B964  2  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
00B966  2  49 FF        	EOR	#$FF		; complement it
00B968  2  2A           	ROL			; sign bit into carry
00B969  2               
00B969  2               ; set exp=X, clearFAC1 mantissa3 and normalise
00B969  2               
00B969  2               LAB_STFA
00B969  2  A9 00        	LDA	#$00		; clear A
00B96B  2  85 AF        	STA	FAC1_3		; clear FAC1 mantissa3
00B96D  2  86 AC        	STX	FAC1_e		; set FAC1 exponent
00B96F  2  85 B9        	STA	FAC1_r		; clear FAC1 rounding byte
00B971  2  85 B0        	STA	FAC1_s		; clear FAC1 sign (b7)
00B973  2  4C 91 B6     	JMP	LAB_24D0	; do ABS and normalise FAC1
00B976  2               
00B976  2               ; perform ABS()
00B976  2               
00B976  2               LAB_ABS
00B976  2  46 B0        	LSR	FAC1_s		; clear FAC1 sign (put zero in b7)
00B978  2  60           	RTS
00B979  2               
00B979  2               ; compare FAC1 with (AY)
00B979  2               ; returns A=$00 if FAC1 = (AY)
00B979  2               ; returns A=$01 if FAC1 > (AY)
00B979  2               ; returns A=$FF if FAC1 < (AY)
00B979  2               
00B979  2               LAB_27F8
00B979  2  85 73        	STA	ut2_pl		; save pointer low byte
00B97B  2               LAB_27FA
00B97B  2  84 74        	STY	ut2_ph		; save pointer high byte
00B97D  2  A0 00        	LDY	#$00		; clear index
00B97F  2  B1 73        	LDA	(ut2_pl),Y	; get exponent
00B981  2  C8           	INY			; increment index
00B982  2  AA           	TAX			; copy (AY) exponent to X
00B983  2  F0 C6        	BEQ	LAB_27CA	; branch if (AY) exponent=0 and get FAC1 sign
00B985  2               				; A=FF,C=1/-ve A=01,C=0/+ve
00B985  2               
00B985  2  B1 73        	LDA	(ut2_pl),Y	; get (AY) mantissa1 (with sign)
00B987  2  45 B0        	EOR	FAC1_s		; EOR FAC1 sign (b7)
00B989  2  30 C4        	BMI	LAB_27CE	; if signs <> do return A=FF,C=1/-ve
00B98B  2               				; A=01,C=0/+ve and return
00B98B  2               
00B98B  2  E4 AC        	CPX	FAC1_e		; compare (AY) exponent with FAC1 exponent
00B98D  2  D0 1A        	BNE	LAB_2828	; branch if different
00B98F  2               
00B98F  2  B1 73        	LDA	(ut2_pl),Y	; get (AY) mantissa1 (with sign)
00B991  2  09 80        	ORA	#$80		; normalise top bit
00B993  2  C5 AD        	CMP	FAC1_1		; compare with FAC1 mantissa1
00B995  2  D0 12        	BNE	LAB_2828	; branch if different
00B997  2               
00B997  2  C8           	INY			; increment index
00B998  2  B1 73        	LDA	(ut2_pl),Y	; get mantissa2
00B99A  2  C5 AE        	CMP	FAC1_2		; compare with FAC1 mantissa2
00B99C  2  D0 0B        	BNE	LAB_2828	; branch if different
00B99E  2               
00B99E  2  C8           	INY			; increment index
00B99F  2  A9 7F        	LDA	#$7F		; set for 1/2 value rounding byte
00B9A1  2  C5 B9        	CMP	FAC1_r		; compare with FAC1 rounding byte (set carry)
00B9A3  2  B1 73        	LDA	(ut2_pl),Y	; get mantissa3
00B9A5  2  E5 AF        	SBC	FAC1_3		; subtract FAC1 mantissa3
00B9A7  2  F0 28        	BEQ	LAB_2850	; exit if mantissa3 equal
00B9A9  2               
00B9A9  2               ; gets here if number <> FAC1
00B9A9  2               
00B9A9  2               LAB_2828
00B9A9  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
00B9AB  2  90 02        	BCC	LAB_282E	; branch if FAC1 > (AY)
00B9AD  2               
00B9AD  2  49 FF        	EOR	#$FF		; else toggle FAC1 sign
00B9AF  2               LAB_282E
00B9AF  2  4C 51 B9     	JMP	LAB_27D0	; return A=FF,C=1/-ve A=01,C=0/+ve
00B9B2  2               
00B9B2  2               ; convert FAC1 floating-to-fixed
00B9B2  2               
00B9B2  2               LAB_2831
00B9B2  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00B9B4  2  F0 4A        	BEQ	LAB_287F	; if zero go clear FAC1 and return
00B9B6  2               
00B9B6  2  38           	SEC			; set carry for subtract
00B9B7  2  E9 98        	SBC	#$98		; subtract maximum integer range exponent
00B9B9  2  24 B0        	BIT	FAC1_s		; test FAC1 sign (b7)
00B9BB  2  10 09        	BPL	LAB_2845	; branch if FAC1 +ve
00B9BD  2               
00B9BD  2               				; FAC1 was -ve
00B9BD  2  AA           	TAX			; copy subtracted exponent
00B9BE  2  A9 FF        	LDA	#$FF		; overflow for -ve number
00B9C0  2  85 B2        	STA	FAC1_o		; set FAC1 overflow byte
00B9C2  2  20 FE B6     	JSR	LAB_253D	; twos complement FAC1 mantissa
00B9C5  2  8A           	TXA			; restore subtracted exponent
00B9C6  2               LAB_2845
00B9C6  2  A2 AC        	LDX	#FAC1_e		; set index to FAC1
00B9C8  2  C9 F9        	CMP	#$F9		; compare exponent result
00B9CA  2  10 06        	BPL	LAB_2851	; if < 8 shifts shift FAC1 A times right and return
00B9CC  2               
00B9CC  2  20 3C B7     	JSR	LAB_257B	; shift FAC1 A times right (> 8 shifts)
00B9CF  2  84 B2        	STY	FAC1_o		; clear FAC1 overflow byte
00B9D1  2               LAB_2850
00B9D1  2  60           	RTS
00B9D2  2               
00B9D2  2               ; shift FAC1 A times right
00B9D2  2               
00B9D2  2               LAB_2851
00B9D2  2  A8           	TAY			; copy shift count
00B9D3  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
00B9D5  2  29 80        	AND	#$80		; mask sign bit only (x000 0000)
00B9D7  2  46 AD        	LSR	FAC1_1		; shift FAC1 mantissa1
00B9D9  2  05 AD        	ORA	FAC1_1		; OR sign in b7 FAC1 mantissa1
00B9DB  2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
00B9DD  2  20 53 B7     	JSR	LAB_2592	; shift FAC1 Y times right
00B9E0  2  84 B2        	STY	FAC1_o		; clear FAC1 overflow byte
00B9E2  2  60           	RTS
00B9E3  2               
00B9E3  2               ; perform INT()
00B9E3  2               
00B9E3  2               LAB_INT
00B9E3  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00B9E5  2  C9 98        	CMP	#$98		; compare with max int
00B9E7  2  B0 1E        	BCS	LAB_2886	; exit if >= (already int, too big for fractional part!)
00B9E9  2               
00B9E9  2  20 B2 B9     	JSR	LAB_2831	; convert FAC1 floating-to-fixed
00B9EC  2  84 B9        	STY	FAC1_r		; save FAC1 rounding byte
00B9EE  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
00B9F0  2  84 B0        	STY	FAC1_s		; save FAC1 sign (b7)
00B9F2  2  49 80        	EOR	#$80		; toggle FAC1 sign
00B9F4  2  2A           	ROL			; shift into carry
00B9F5  2  A9 98        	LDA	#$98		; set new exponent
00B9F7  2  85 AC        	STA	FAC1_e		; save FAC1 exponent
00B9F9  2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
00B9FB  2  85 5B        	STA	Temp3		; save for EXP() function
00B9FD  2  4C 91 B6     	JMP	LAB_24D0	; do ABS and normalise FAC1
00BA00  2               
00BA00  2               ; clear FAC1 and return
00BA00  2               
00BA00  2               LAB_287F
00BA00  2  85 AD        	STA	FAC1_1		; clear FAC1 mantissa1
00BA02  2  85 AE        	STA	FAC1_2		; clear FAC1 mantissa2
00BA04  2  85 AF        	STA	FAC1_3		; clear FAC1 mantissa3
00BA06  2  A8           	TAY			; clear Y
00BA07  2               LAB_2886
00BA07  2  60           	RTS
00BA08  2               
00BA08  2               ; get FAC1 from string
00BA08  2               ; this routine now handles hex and binary values from strings
00BA08  2               ; starting with "$" and "%" respectively
00BA08  2               
00BA08  2               LAB_2887
00BA08  2  A0 00        	LDY	#$00		; clear Y
00BA0A  2  84 5F        	STY	Dtypef		; clear data type flag, $FF=string, $00=numeric
00BA0C  2  A2 09        	LDX	#$09		; set index
00BA0E  2               LAB_288B
00BA0E  2  94 A8        	STY	numexp,X	; clear byte
00BA10  2  CA           	DEX			; decrement index
00BA11  2  10 FB        	BPL	LAB_288B	; loop until numexp to negnum (and FAC1) = $00
00BA13  2               
00BA13  2  90 7F        	BCC	LAB_28FE	; branch if 1st character numeric
00BA15  2               
00BA15  2               ; get FAC1 from string .. first character wasn't numeric
00BA15  2               
00BA15  2  C9 2D        	CMP	#'-'		; else compare with "-"
00BA17  2  D0 04        	BNE	LAB_289A	; branch if not "-"
00BA19  2               
00BA19  2  86 B1        	STX	negnum		; set flag for -ve number (X = $FF)
00BA1B  2  F0 04        	BEQ	LAB_289C	; branch always (go scan and check for hex/bin)
00BA1D  2               
00BA1D  2               ; get FAC1 from string .. first character wasn't numeric or -
00BA1D  2               
00BA1D  2               LAB_289A
00BA1D  2  C9 2B        	CMP	#'+'		; else compare with "+"
00BA1F  2  D0 05        	BNE	LAB_289D	; branch if not "+" (go check for hex/bin)
00BA21  2               
00BA21  2               ; was "+" or "-" to start, so get next character
00BA21  2               
00BA21  2               LAB_289C
00BA21  2  20 BC 00     	JSR	LAB_IGBY	; increment and scan memory
00BA24  2  90 6E        	BCC	LAB_28FE	; branch if numeric character
00BA26  2               
00BA26  2               ; code here for hex and binary numbers
00BA26  2               
00BA26  2               LAB_289D
00BA26  2  C9 24        	CMP	#'$'		; else compare with "$"
00BA28  2  D0 03        	BNE	LAB_NHEX	; branch if not "$"
00BA2A  2               
00BA2A  2  4C D6 BE     	JMP	LAB_CHEX	; branch if "$"
00BA2D  2               
00BA2D  2               LAB_NHEX
00BA2D  2  C9 25        	CMP	#'%'		; else compare with "%"
00BA2F  2  D0 08        	BNE	LAB_28A3	; branch if not "%" (continue original code)
00BA31  2               
00BA31  2  4C 04 BF     	JMP	LAB_CBIN	; branch if "%"
00BA34  2               
00BA34  2               LAB_289E
00BA34  2  20 BC 00     	JSR	LAB_IGBY	; increment and scan memory (ignore + or get next number)
00BA37  2               LAB_28A1
00BA37  2  90 5B        	BCC	LAB_28FE	; branch if numeric character
00BA39  2               
00BA39  2               ; get FAC1 from string .. character wasn't numeric, -, +, hex or binary
00BA39  2               
00BA39  2               LAB_28A3
00BA39  2  C9 2E        	CMP	#'.'		; else compare with "."
00BA3B  2  F0 2E        	BEQ	LAB_28D5	; branch if "."
00BA3D  2               
00BA3D  2               ; get FAC1 from string .. character wasn't numeric, -, + or .
00BA3D  2               
00BA3D  2  C9 45        	CMP	#'E'		; else compare with "E"
00BA3F  2  D0 30        	BNE	LAB_28DB	; branch if not "E"
00BA41  2               
00BA41  2               				; was "E" so evaluate exponential part
00BA41  2  20 BC 00     	JSR	LAB_IGBY	; increment and scan memory
00BA44  2  90 17        	BCC	LAB_28C7	; branch if numeric character
00BA46  2               
00BA46  2  C9 CE        	CMP	#TK_MINUS	; else compare with token for -
00BA48  2  F0 0E        	BEQ	LAB_28C2	; branch if token for -
00BA4A  2               
00BA4A  2  C9 2D        	CMP	#'-'		; else compare with "-"
00BA4C  2  F0 0A        	BEQ	LAB_28C2	; branch if "-"
00BA4E  2               
00BA4E  2  C9 CD        	CMP	#TK_PLUS	; else compare with token for +
00BA50  2  F0 08        	BEQ	LAB_28C4	; branch if token for +
00BA52  2               
00BA52  2  C9 2B        	CMP	#'+'		; else compare with "+"
00BA54  2  F0 04        	BEQ	LAB_28C4	; branch if "+"
00BA56  2               
00BA56  2  D0 07        	BNE	LAB_28C9	; branch always
00BA58  2               
00BA58  2               LAB_28C2
00BA58  2  66 AB        	ROR	expneg		; set exponent -ve flag (C, which=1, into b7)
00BA5A  2               LAB_28C4
00BA5A  2  20 BC 00     	JSR	LAB_IGBY	; increment and scan memory
00BA5D  2               LAB_28C7
00BA5D  2  90 5B        	BCC	LAB_2925	; branch if numeric character
00BA5F  2               
00BA5F  2               LAB_28C9
00BA5F  2  24 AB        	BIT	expneg		; test exponent -ve flag
00BA61  2  10 0E        	BPL	LAB_28DB	; if +ve go evaluate exponent
00BA63  2               
00BA63  2               				; else do exponent = -exponent
00BA63  2  A9 00        	LDA	#$00		; clear result
00BA65  2  38           	SEC			; set carry for subtract
00BA66  2  E5 A9        	SBC	expcnt		; subtract exponent byte
00BA68  2  4C 73 BA     	JMP	LAB_28DD	; go evaluate exponent
00BA6B  2               
00BA6B  2               LAB_28D5
00BA6B  2  66 AA        	ROR	numdpf		; set decimal point flag
00BA6D  2  24 AA        	BIT	numdpf		; test decimal point flag
00BA6F  2  50 C3        	BVC	LAB_289E	; branch if only one decimal point so far
00BA71  2               
00BA71  2               				; evaluate exponent
00BA71  2               LAB_28DB
00BA71  2  A5 A9        	LDA	expcnt		; get exponent count byte
00BA73  2               LAB_28DD
00BA73  2  38           	SEC			; set carry for subtract
00BA74  2  E5 A8        	SBC	numexp		; subtract numerator exponent
00BA76  2  85 A9        	STA	expcnt		; save exponent count byte
00BA78  2  F0 12        	BEQ	LAB_28F6	; branch if no adjustment
00BA7A  2               
00BA7A  2  10 09        	BPL	LAB_28EF	; else if +ve go do FAC1*10^expcnt
00BA7C  2               
00BA7C  2               				; else go do FAC1/10^(0-expcnt)
00BA7C  2               LAB_28E6
00BA7C  2  20 52 B8     	JSR	LAB_26B9	; divide by 10
00BA7F  2  E6 A9        	INC	expcnt		; increment exponent count byte
00BA81  2  D0 F9        	BNE	LAB_28E6	; loop until all done
00BA83  2               
00BA83  2  F0 07        	BEQ	LAB_28F6	; branch always
00BA85  2               
00BA85  2               LAB_28EF
00BA85  2  20 39 B8     	JSR	LAB_269E	; multiply by 10
00BA88  2  C6 A9        	DEC	expcnt		; decrement exponent count byte
00BA8A  2  D0 F9        	BNE	LAB_28EF	; loop until all done
00BA8C  2               
00BA8C  2               LAB_28F6
00BA8C  2  A5 B1        	LDA	negnum		; get -ve flag
00BA8E  2  30 01        	BMI	LAB_28FB	; if -ve do - FAC1 and return
00BA90  2               
00BA90  2  60           	RTS
00BA91  2               
00BA91  2               ; do - FAC1 and return
00BA91  2               
00BA91  2               LAB_28FB
00BA91  2  4C 57 BC     	JMP	LAB_GTHAN	; do - FAC1 and return
00BA94  2               
00BA94  2               ; do unsigned FAC1*10+number
00BA94  2               
00BA94  2               LAB_28FE
00BA94  2  48           	PHA			; save character
00BA95  2  24 AA        	BIT	numdpf		; test decimal point flag
00BA97  2  10 02        	BPL	LAB_2905	; skip exponent increment if not set
00BA99  2               
00BA99  2  E6 A8        	INC	numexp		; else increment number exponent
00BA9B  2               LAB_2905
00BA9B  2  20 39 B8     	JSR	LAB_269E	; multiply FAC1 by 10
00BA9E  2  68           	PLA			; restore character
00BA9F  2  29 0F        	AND	#$0F		; convert to binary
00BAA1  2  20 A7 BA     	JSR	LAB_2912	; evaluate new ASCII digit
00BAA4  2  4C 34 BA     	JMP	LAB_289E	; go do next character
00BAA7  2               
00BAA7  2               ; evaluate new ASCII digit
00BAA7  2               
00BAA7  2               LAB_2912
00BAA7  2  48           	PHA			; save digit
00BAA8  2  20 2C B9     	JSR	LAB_27AB	; round and copy FAC1 to FAC2
00BAAB  2  68           	PLA			; restore digit
00BAAC  2  20 5C B9     	JSR	LAB_27DB	; save A as integer byte
00BAAF  2  A5 B7        	LDA	FAC2_s		; get FAC2 sign (b7)
00BAB1  2  45 B0        	EOR	FAC1_s		; toggle with FAC1 sign (b7)
00BAB3  2  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
00BAB5  2  A6 AC        	LDX	FAC1_e		; get FAC1 exponent
00BAB7  2  4C 23 B6     	JMP	LAB_ADD		; add FAC2 to FAC1 and return
00BABA  2               
00BABA  2               ; evaluate next character of exponential part of number
00BABA  2               
00BABA  2               LAB_2925
00BABA  2  A5 A9        	LDA	expcnt		; get exponent count byte
00BABC  2  C9 0A        	CMP	#$0A		; compare with 10 decimal
00BABE  2  90 09        	BCC	LAB_2934	; branch if less
00BAC0  2               
00BAC0  2  A9 64        	LDA	#$64		; make all -ve exponents = -100 decimal (causes underflow)
00BAC2  2  24 AB        	BIT	expneg		; test exponent -ve flag
00BAC4  2  30 0E        	BMI	LAB_2942	; branch if -ve
00BAC6  2               
00BAC6  2  4C 25 B7     	JMP	LAB_2564	; else do overflow error
00BAC9  2               
00BAC9  2               LAB_2934
00BAC9  2  0A           	ASL			; * 2
00BACA  2  0A           	ASL			; * 4
00BACB  2  65 A9        	ADC	expcnt		; * 5
00BACD  2  0A           	ASL			; * 10
00BACE  2  A0 00        	LDY	#$00		; set index
00BAD0  2  71 C3        	ADC	(Bpntrl),Y	; add character (will be $30 too much!)
00BAD2  2  E9 2F        	SBC	#'0'-1		; convert character to binary
00BAD4  2               LAB_2942
00BAD4  2  85 A9        	STA	expcnt		; save exponent count byte
00BAD6  2  4C 5A BA     	JMP	LAB_28C4	; go get next character
00BAD9  2               
00BAD9  2               ; print " in line [LINE #]"
00BAD9  2               
00BAD9  2               LAB_2953
00BAD9  2  A9 93        	LDA	#<LAB_LMSG	; point to " in line " message low byte
00BADB  2  A0 C9        	LDY	#>LAB_LMSG	; point to " in line " message high byte
00BADD  2  20 22 A9     	JSR	LAB_18C3	; print null terminated string from memory
00BAE0  2               
00BAE0  2               				; print Basic line #
00BAE0  2  A5 88        	LDA	Clineh		; get current line high byte
00BAE2  2  A6 87        	LDX	Clinel		; get current line low byte
00BAE4  2               
00BAE4  2               ; print XA as unsigned integer
00BAE4  2               
00BAE4  2               LAB_295E
00BAE4  2  85 AD        	STA	FAC1_1		; save low byte as FAC1 mantissa1
00BAE6  2  86 AE        	STX	FAC1_2		; save high byte as FAC1 mantissa2
00BAE8  2  A2 90        	LDX	#$90		; set exponent to 16d bits
00BAEA  2  38           	SEC			; set integer is +ve flag
00BAEB  2  20 69 B9     	JSR	LAB_STFA	; set exp=X, clearFAC1 mantissa3 and normalise
00BAEE  2  A0 00        	LDY	#$00		; clear index
00BAF0  2  98           	TYA			; clear A
00BAF1  2  20 05 BB     	JSR	LAB_297B	; convert FAC1 to string, skip sign character save
00BAF4  2  4C 22 A9     	JMP	LAB_18C3	; print null terminated string from memory and return
00BAF7  2               
00BAF7  2               ; convert FAC1 to ASCII string result in (AY)
00BAF7  2               ; not any more, moved scratchpad to page 0
00BAF7  2               
00BAF7  2               LAB_296E
00BAF7  2  A0 00        	LDY	#$00		; set index = 1
00BAF9  2  A9 20        	LDA	#$20		; prepare A=$20 for positive
00BAFB  2  24 B0        	BIT	FAC1_s		; test FAC1 sign (b7)
00BAFD  2  10 06        	BPL	LAB_297B	; branch if +ve
00BAFF  2  A9 2D        	LDA	#$2D		; else character = "-"
00BB01  2  C8           	INY
00BB02  2  99 EE 00     	STA	Decss,Y		; store leading character "-" if negative
00BB05  2               LAB_297B
00BB05  2  85 B0        	STA	FAC1_s		; clear FAC1 sign (b7)
00BB07  2  84 BA        	STY	Sendl		; save index
00BB09  2  A6 AC        	LDX	FAC1_e		; get FAC1 exponent
00BB0B  2  D0 06        	BNE	LAB_2989	; branch if FAC1<>0
00BB0D  2               				; exponent was $00 so FAC1 is 0
00BB0D  2  C8           	INY
00BB0E  2  A9 30        	LDA	#'0'		; set character = "0"
00BB10  2  4C 11 BC     	JMP	LAB_2A89	; save last character, [EOT] and exit
00BB13  2               
00BB13  2               				; FAC1 is some non zero value
00BB13  2               LAB_2989
00BB13  2  A9 00        	LDA	#$00		; clear (number exponent count)
00BB15  2  E0 81        	CPX	#$81		; compare FAC1 exponent with $81 (>1.00000)
00BB17  2               
00BB17  2  B0 09        	BCS	LAB_299A	; branch if FAC1=>1
00BB19  2               
00BB19  2               				; FAC1<1
00BB19  2  A9 EE        	LDA	#<LAB_294F	; set pointer low byte to 1,000,000
00BB1B  2  A0 C1        	LDY	#>LAB_294F	; set pointer high byte to 1,000,000
00BB1D  2  20 9B B7     	JSR	LAB_25FB	; do convert AY, FCA1*(AY)
00BB20  2  A9 FA        	LDA	#$FA		; set number exponent count (-6)
00BB22  2               LAB_299A
00BB22  2  85 A8        	STA	numexp		; save number exponent count
00BB24  2               LAB_299C
00BB24  2  A9 EA        	LDA	#<LAB_294B	; set pointer low byte to 999999.4375 (max before sci note)
00BB26  2  A0 C1        	LDY	#>LAB_294B	; set pointer high byte to 999999.4375
00BB28  2  20 79 B9     	JSR	LAB_27F8	; compare FAC1 with (AY)
00BB2B  2  F0 1E        	BEQ	LAB_29C3	; exit if FAC1 = (AY)
00BB2D  2               
00BB2D  2  10 12        	BPL	LAB_29B9	; go do /10 if FAC1 > (AY)
00BB2F  2               
00BB2F  2               				; FAC1 < (AY)
00BB2F  2               LAB_29A7
00BB2F  2  A9 E6        	LDA	#<LAB_2947	; set pointer low byte to 99999.9375
00BB31  2  A0 C1        	LDY	#>LAB_2947	; set pointer high byte to 99999.9375
00BB33  2  20 79 B9     	JSR	LAB_27F8	; compare FAC1 with (AY)
00BB36  2  F0 02        	BEQ	LAB_29B2	; branch if FAC1 = (AY) (allow decimal places)
00BB38  2               
00BB38  2  10 0E        	BPL	LAB_29C0	; branch if FAC1 > (AY) (no decimal places)
00BB3A  2               
00BB3A  2               				; FAC1 <= (AY)
00BB3A  2               LAB_29B2
00BB3A  2  20 39 B8     	JSR	LAB_269E	; multiply by 10
00BB3D  2  C6 A8        	DEC	numexp		; decrement number exponent count
00BB3F  2  D0 EE        	BNE	LAB_29A7	; go test again (branch always)
00BB41  2               
00BB41  2               LAB_29B9
00BB41  2  20 52 B8     	JSR	LAB_26B9	; divide by 10
00BB44  2  E6 A8        	INC	numexp		; increment number exponent count
00BB46  2  D0 DC        	BNE	LAB_299C	; go test again (branch always)
00BB48  2               
00BB48  2               ; now we have just the digits to do
00BB48  2               
00BB48  2               LAB_29C0
00BB48  2  20 1C B6     	JSR	LAB_244E	; add 0.5 to FAC1 (round FAC1)
00BB4B  2               LAB_29C3
00BB4B  2  20 B2 B9     	JSR	LAB_2831	; convert FAC1 floating-to-fixed
00BB4E  2  A2 01        	LDX	#$01		; set default digits before dp = 1
00BB50  2  A5 A8        	LDA	numexp		; get number exponent count
00BB52  2  18           	CLC			; clear carry for add
00BB53  2  69 07        	ADC	#$07		; up to 6 digits before point
00BB55  2  30 09        	BMI	LAB_29D8	; if -ve then 1 digit before dp
00BB57  2               
00BB57  2  C9 08        	CMP	#$08		; A>=8 if n>=1E6
00BB59  2  B0 06        	BCS	LAB_29D9	; branch if >= $08
00BB5B  2               
00BB5B  2               				; carry is clear
00BB5B  2  69 FF        	ADC	#$FF		; take 1 from digit count
00BB5D  2  AA           	TAX			; copy to A
00BB5E  2  A9 02        	LDA	#$02		;.set exponent adjust
00BB60  2               LAB_29D8
00BB60  2  38           	SEC			; set carry for subtract
00BB61  2               LAB_29D9
00BB61  2  E9 02        	SBC	#$02		; -2
00BB63  2  85 A9        	STA	expcnt		;.save exponent adjust
00BB65  2  86 A8        	STX	numexp		; save digits before dp count
00BB67  2  8A           	TXA			; copy to A
00BB68  2  F0 02        	BEQ	LAB_29E4	; branch if no digits before dp
00BB6A  2               
00BB6A  2  10 13        	BPL	LAB_29F7	; branch if digits before dp
00BB6C  2               
00BB6C  2               LAB_29E4
00BB6C  2  A4 BA        	LDY	Sendl		; get output string index
00BB6E  2  A9 2E        	LDA	#$2E		; character "."
00BB70  2  C8           	INY			; increment index
00BB71  2  99 EE 00     	STA	Decss,Y		; save to output string
00BB74  2  8A           	TXA			;.
00BB75  2  F0 06        	BEQ	LAB_29F5	;.
00BB77  2               
00BB77  2  A9 30        	LDA	#'0'		; character "0"
00BB79  2  C8           	INY			; increment index
00BB7A  2  99 EE 00     	STA	Decss,Y		; save to output string
00BB7D  2               LAB_29F5
00BB7D  2  84 BA        	STY	Sendl		; save output string index
00BB7F  2               LAB_29F7
00BB7F  2  A0 00        	LDY	#$00		; clear index (point to 100,000)
00BB81  2  A2 80        	LDX	#$80		;
00BB83  2               LAB_29FB
00BB83  2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
00BB85  2  18           	CLC			; clear carry for add
00BB86  2  79 64 C2     	ADC	LAB_2A9C,Y	; add -ve LSB
00BB89  2  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
00BB8B  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
00BB8D  2  79 63 C2     	ADC	LAB_2A9B,Y	; add -ve NMSB
00BB90  2  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
00BB92  2  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
00BB94  2  79 62 C2     	ADC	LAB_2A9A,Y	; add -ve MSB
00BB97  2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
00BB99  2  E8           	INX			;
00BB9A  2  B0 04        	BCS	LAB_2A18	;
00BB9C  2               
00BB9C  2  10 E5        	BPL	LAB_29FB	; not -ve so try again
00BB9E  2               
00BB9E  2  30 02        	BMI	LAB_2A1A	;
00BBA0  2               
00BBA0  2               LAB_2A18
00BBA0  2  30 E1        	BMI	LAB_29FB	;
00BBA2  2               
00BBA2  2               LAB_2A1A
00BBA2  2  8A           	TXA			;
00BBA3  2  90 04        	BCC	LAB_2A21	;
00BBA5  2               
00BBA5  2  49 FF        	EOR	#$FF		;
00BBA7  2  69 0A        	ADC	#$0A		;
00BBA9  2               LAB_2A21
00BBA9  2  69 2F        	ADC	#'0'-1		; add "0"-1 to result
00BBAB  2  C8           	INY			; increment index ..
00BBAC  2  C8           	INY			; .. to next less ..
00BBAD  2  C8           	INY			; .. power of ten
00BBAE  2  84 95        	STY	Cvaral		; save as current var address low byte
00BBB0  2  A4 BA        	LDY	Sendl		; get output string index
00BBB2  2  C8           	INY			; increment output string index
00BBB3  2  AA           	TAX			; copy character to X
00BBB4  2  29 7F        	AND	#$7F		; mask out top bit
00BBB6  2  99 EE 00     	STA	Decss,Y		; save to output string
00BBB9  2  C6 A8        	DEC	numexp		; decrement # of characters before the dp
00BBBB  2  D0 06        	BNE	LAB_2A3B	; branch if still characters to do
00BBBD  2               
00BBBD  2               				; else output the point
00BBBD  2  A9 2E        	LDA	#$2E		; character "."
00BBBF  2  C8           	INY			; increment output string index
00BBC0  2  99 EE 00     	STA	Decss,Y		; save to output string
00BBC3  2               LAB_2A3B
00BBC3  2  84 BA        	STY	Sendl		; save output string index
00BBC5  2  A4 95        	LDY	Cvaral		; get current var address low byte
00BBC7  2  8A           	TXA			; get character back
00BBC8  2  49 FF        	EOR	#$FF		;
00BBCA  2  29 80        	AND	#$80		;
00BBCC  2  AA           	TAX			;
00BBCD  2  C0 12        	CPY	#$12		; compare index with max
00BBCF  2  D0 B2        	BNE	LAB_29FB	; loop if not max
00BBD1  2               
00BBD1  2               				; now remove trailing zeroes
00BBD1  2  A4 BA        	LDY	Sendl		; get output string index
00BBD3  2               LAB_2A4B
00BBD3  2  B9 EE 00     	LDA	Decss,Y		; get character from output string
00BBD6  2  88           	DEY			; decrement output string index
00BBD7  2  C9 30        	CMP	#'0'		; compare with "0"
00BBD9  2  F0 F8        	BEQ	LAB_2A4B	; loop until non "0" character found
00BBDB  2               
00BBDB  2  C9 2E        	CMP	#'.'		; compare with "."
00BBDD  2  F0 01        	BEQ	LAB_2A58	; branch if was dp
00BBDF  2               
00BBDF  2               				; restore last character
00BBDF  2  C8           	INY			; increment output string index
00BBE0  2               LAB_2A58
00BBE0  2  A9 2B        	LDA	#$2B		; character "+"
00BBE2  2  A6 A9        	LDX	expcnt		; get exponent count
00BBE4  2  F0 2E        	BEQ	LAB_2A8C	; if zero go set null terminator and exit
00BBE6  2               
00BBE6  2               				; exponent isn't zero so write exponent
00BBE6  2  10 08        	BPL	LAB_2A68	; branch if exponent count +ve
00BBE8  2               
00BBE8  2  A9 00        	LDA	#$00		; clear A
00BBEA  2  38           	SEC			; set carry for subtract
00BBEB  2  E5 A9        	SBC	expcnt		; subtract exponent count adjust (convert -ve to +ve)
00BBED  2  AA           	TAX			; copy exponent count to X
00BBEE  2  A9 2D        	LDA	#'-'		; character "-"
00BBF0  2               LAB_2A68
00BBF0  2  99 F0 00     	STA	Decss+2,Y	; save to output string
00BBF3  2  A9 45        	LDA	#$45		; character "E"
00BBF5  2  99 EF 00     	STA	Decss+1,Y	; save exponent sign to output string
00BBF8  2  8A           	TXA			; get exponent count back
00BBF9  2  A2 2F        	LDX	#'0'-1		; one less than "0" character
00BBFB  2  38           	SEC			; set carry for subtract
00BBFC  2               LAB_2A74
00BBFC  2  E8           	INX			; increment 10's character
00BBFD  2  E9 0A        	SBC	#$0A		;.subtract 10 from exponent count
00BBFF  2  B0 FB        	BCS	LAB_2A74	; loop while still >= 0
00BC01  2               
00BC01  2  69 3A        	ADC	#':'		; add character ":" ($30+$0A, result is 10 less that value)
00BC03  2  99 F2 00     	STA	Decss+4,Y	; save to output string
00BC06  2  8A           	TXA			; copy 10's character
00BC07  2  99 F1 00     	STA	Decss+3,Y	; save to output string
00BC0A  2  A9 00        	LDA	#$00		; set null terminator
00BC0C  2  99 F3 00     	STA	Decss+5,Y	; save to output string
00BC0F  2  F0 08        	BEQ	LAB_2A91	; go set string pointer (AY) and exit (branch always)
00BC11  2               
00BC11  2               				; save last character, [EOT] and exit
00BC11  2               LAB_2A89
00BC11  2  99 EE 00     	STA	Decss,Y		; save last character to output string
00BC14  2               
00BC14  2               				; set null terminator and exit
00BC14  2               LAB_2A8C
00BC14  2  A9 00        	LDA	#$00		; set null terminator
00BC16  2  99 EF 00     	STA	Decss+1,Y	; save after last character
00BC19  2               
00BC19  2               				; set string pointer (AY) and exit
00BC19  2               LAB_2A91
00BC19  2  A9 EF        	LDA	#<Decssp1	; get result string low pointer
00BC1B  2  A0 00        	LDY	#>Decssp1	; get result string high pointer
00BC1D  2  60           	RTS
00BC1E  2               
00BC1E  2               ; perform power function
00BC1E  2               
00BC1E  2               LAB_POWER
00BC1E  2  F0 42        	BEQ	LAB_EXP		; go do  EXP()
00BC20  2               
00BC20  2  A5 B3        	LDA	FAC2_e		; get FAC2 exponent
00BC22  2  D0 03        	BNE	LAB_2ABF	; branch if FAC2<>0
00BC24  2               
00BC24  2  4C B4 B6     	JMP	LAB_24F3	; clear FAC1 exponent and sign and return
00BC27  2               
00BC27  2               LAB_2ABF
00BC27  2  A2 9C        	LDX	#<func_l	; set destination pointer low byte
00BC29  2  A0 00        	LDY	#>func_l	; set destination pointer high byte
00BC2B  2  20 09 B9     	JSR	LAB_2778	; pack FAC1 into (XY)
00BC2E  2  A5 B7        	LDA	FAC2_s		; get FAC2 sign (b7)
00BC30  2  10 0F        	BPL	LAB_2AD9	; branch if FAC2>0
00BC32  2               
00BC32  2               				; else FAC2 is -ve and can only be raised to an
00BC32  2               				; integer power which gives an x +j0 result
00BC32  2  20 E3 B9     	JSR	LAB_INT		; perform INT
00BC35  2  A9 9C        	LDA	#<func_l	; set source pointer low byte
00BC37  2  A0 00        	LDY	#>func_l	; set source pointer high byte
00BC39  2  20 79 B9     	JSR	LAB_27F8	; compare FAC1 with (AY)
00BC3C  2  D0 03        	BNE	LAB_2AD9	; branch if FAC1 <> (AY) to allow Function Call error
00BC3E  2               				; this will leave FAC1 -ve and cause a Function Call
00BC3E  2               				; error when LOG() is called
00BC3E  2               
00BC3E  2  98           	TYA			; clear sign b7
00BC3F  2  A4 5B        	LDY	Temp3		; save mantissa 3 from INT() function as sign in Y
00BC41  2               				; for possible later negation, b0
00BC41  2               LAB_2AD9
00BC41  2  20 27 B6     	JSR	LAB_279D	; save FAC1 sign and copy ABS(FAC2) to FAC1
00BC44  2  98           	TYA			; copy sign back ..
00BC45  2  48           	PHA			; .. and save it
00BC46  2  20 5D B7     	JSR	LAB_LOG		; do LOG(n)
00BC49  2  A9 9C        	LDA	#<garb_l	; set pointer low byte
00BC4B  2  A0 00        	LDY	#>garb_l	; set pointer high byte
00BC4D  2  20 9B B7     	JSR	LAB_25FB	; do convert AY, FCA1*(AY) (square the value)
00BC50  2  20 62 BC     	JSR	LAB_EXP		; go do EXP(n)
00BC53  2  68           	PLA			; pull sign from stack
00BC54  2  4A           	LSR			; b0 is to be tested, shift to Cb
00BC55  2  90 0A        	BCC	LAB_2AF9	; if no bit then exit
00BC57  2               
00BC57  2               				; Perform negation
00BC57  2               ; do - FAC1
00BC57  2               
00BC57  2               LAB_GTHAN
00BC57  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00BC59  2  F0 06        	BEQ	LAB_2AF9	; exit if FAC1_e = $00
00BC5B  2               
00BC5B  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
00BC5D  2  49 FF        	EOR	#$FF		; complement it
00BC5F  2  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
00BC61  2               LAB_2AF9
00BC61  2  60           	RTS
00BC62  2               
00BC62  2               ; perform EXP()	(x^e)
00BC62  2               
00BC62  2               LAB_EXP
00BC62  2  A9 F2        	LDA	#<LAB_2AFA	; set 1.443 pointer low byte
00BC64  2  A0 C1        	LDY	#>LAB_2AFA	; set 1.443 pointer high byte
00BC66  2  20 9B B7     	JSR	LAB_25FB	; do convert AY, FCA1*(AY)
00BC69  2  A5 B9        	LDA	FAC1_r		; get FAC1 rounding byte
00BC6B  2  69 50        	ADC	#$50		; +$50/$100
00BC6D  2  90 03        	BCC	LAB_2B2B	; skip rounding if no carry
00BC6F  2               
00BC6F  2  20 43 B9     	JSR	LAB_27C2	; round FAC1 (no check)
00BC72  2               LAB_2B2B
00BC72  2  85 A3        	STA	FAC2_r		; save FAC2 rounding byte
00BC74  2  20 2F B9     	JSR	LAB_27AE	; copy FAC1 to FAC2
00BC77  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00BC79  2  C9 88        	CMP	#$88		; compare with EXP limit (256d)
00BC7B  2  90 03        	BCC	LAB_2B39	; branch if less
00BC7D  2               
00BC7D  2               LAB_2B36
00BC7D  2  20 30 B8     	JSR	LAB_2690	; handle overflow and underflow
00BC80  2               LAB_2B39
00BC80  2  20 E3 B9     	JSR	LAB_INT		; perform INT
00BC83  2  A5 5B        	LDA	Temp3		; get mantissa 3 from INT() function
00BC85  2  18           	CLC			; clear carry for add
00BC86  2  69 81        	ADC	#$81		; normalise +1
00BC88  2  F0 F3        	BEQ	LAB_2B36	; if $00 go handle overflow
00BC8A  2               
00BC8A  2  38           	SEC			; set carry for subtract
00BC8B  2  E9 01        	SBC	#$01		; now correct for exponent
00BC8D  2  48           	PHA			; save FAC2 exponent
00BC8E  2               
00BC8E  2               				; swap FAC1 and FAC2
00BC8E  2  A2 04        	LDX	#$04		; 4 bytes to do
00BC90  2               LAB_2B49
00BC90  2  B5 B3        	LDA	FAC2_e,X	; get FAC2,X
00BC92  2  B4 AC        	LDY	FAC1_e,X	; get FAC1,X
00BC94  2  95 AC        	STA	FAC1_e,X	; save FAC1,X
00BC96  2  94 B3        	STY	FAC2_e,X	; save FAC2,X
00BC98  2  CA           	DEX			; decrement count/index
00BC99  2  10 F5        	BPL	LAB_2B49	; loop if not all done
00BC9B  2               
00BC9B  2  A5 A3        	LDA	FAC2_r		; get FAC2 rounding byte
00BC9D  2  85 B9        	STA	FAC1_r		; save as FAC1 rounding byte
00BC9F  2  20 08 B6     	JSR	LAB_SUBTRACT	; perform subtraction, FAC2 from FAC1
00BCA2  2  20 57 BC     	JSR	LAB_GTHAN	; do - FAC1
00BCA5  2  A9 F6        	LDA	#<LAB_2AFE	; set counter pointer low byte
00BCA7  2  A0 C1        	LDY	#>LAB_2AFE	; set counter pointer high byte
00BCA9  2  20 CA BC     	JSR	LAB_2B84	; go do series evaluation
00BCAC  2  A9 00        	LDA	#$00		; clear A
00BCAE  2  85 B8        	STA	FAC_sc		; clear sign compare (FAC1 EOR FAC2)
00BCB0  2  68           	PLA			;.get saved FAC2 exponent
00BCB1  2  4C 15 B8     	JMP	LAB_2675	; test and adjust accumulators and return
00BCB4  2               
00BCB4  2               ; ^2 then series evaluation
00BCB4  2               
00BCB4  2               LAB_2B6E
00BCB4  2  85 BA        	STA	Cptrl		; save count pointer low byte
00BCB6  2  84 BB        	STY	Cptrh		; save count pointer high byte
00BCB8  2  20 FF B8     	JSR	LAB_276E	; pack FAC1 into Adatal
00BCBB  2  A9 A4        	LDA	#<Adatal	; set pointer low byte (Y already $00)
00BCBD  2  20 9B B7     	JSR	LAB_25FB	; do convert AY, FCA1*(AY)
00BCC0  2  20 CE BC     	JSR	LAB_2B88	; go do series evaluation
00BCC3  2  A9 A4        	LDA	#<Adatal	; pointer to original # low byte
00BCC5  2  A0 00        	LDY	#>Adatal	; pointer to original # high byte
00BCC7  2  4C 9B B7     	JMP	LAB_25FB	; do convert AY, FCA1*(AY) and return
00BCCA  2               
00BCCA  2               ; series evaluation
00BCCA  2               
00BCCA  2               LAB_2B84
00BCCA  2  85 BA        	STA	Cptrl		; save count pointer low byte
00BCCC  2  84 BB        	STY	Cptrh		; save count pointer high byte
00BCCE  2               LAB_2B88
00BCCE  2  A2 A8        	LDX	#<numexp	; set pointer low byte
00BCD0  2  20 01 B9     	JSR	LAB_2770	; set pointer high byte and pack FAC1 into numexp
00BCD3  2  B1 BA        	LDA	(Cptrl),Y	; get constants count
00BCD5  2  85 B1        	STA	numcon		; save constants count
00BCD7  2  A4 BA        	LDY	Cptrl		; get count pointer low byte
00BCD9  2  C8           	INY			; increment it (now constants pointer)
00BCDA  2  98           	TYA			; copy it
00BCDB  2  D0 02        	BNE	LAB_2B97	; skip next if no overflow
00BCDD  2               
00BCDD  2  E6 BB        	INC	Cptrh		; else increment high byte
00BCDF  2               LAB_2B97
00BCDF  2  85 BA        	STA	Cptrl		; save low byte
00BCE1  2  A4 BB        	LDY	Cptrh		; get high byte
00BCE3  2               LAB_2B9B
00BCE3  2  20 9B B7     	JSR	LAB_25FB	; do convert AY, FCA1*(AY)
00BCE6  2  A5 BA        	LDA	Cptrl		; get constants pointer low byte
00BCE8  2  A4 BB        	LDY	Cptrh		; get constants pointer high byte
00BCEA  2  18           	CLC			; clear carry for add
00BCEB  2  69 04        	ADC	#$04		; +4 to  low pointer (4 bytes per constant)
00BCED  2  90 01        	BCC	LAB_2BA8	; skip next if no overflow
00BCEF  2               
00BCEF  2  C8           	INY			; increment high byte
00BCF0  2               LAB_2BA8
00BCF0  2  85 BA        	STA	Cptrl		; save pointer low byte
00BCF2  2  84 BB        	STY	Cptrh		; save pointer high byte
00BCF4  2  20 20 B6     	JSR	LAB_246C	; add (AY) to FAC1
00BCF7  2  A9 A8        	LDA	#<numexp	; set pointer low byte to partial @ numexp
00BCF9  2  A0 00        	LDY	#>numexp	; set pointer high byte to partial @ numexp
00BCFB  2  C6 B1        	DEC	numcon		; decrement constants count
00BCFD  2  D0 E4        	BNE	LAB_2B9B	; loop until all done
00BCFF  2               
00BCFF  2  60           	RTS
00BD00  2               
00BD00  2               ; RND(n), 32 bit Galoise version. make n=0 for 19th next number in sequence or n<>0
00BD00  2               ; to get 19th next number in sequence after seed n. This version of the PRNG uses
00BD00  2               ; the Galois method and a sample of 65536 bytes produced gives the following values.
00BD00  2               
00BD00  2               ; Entropy = 7.997442 bits per byte
00BD00  2               ; Optimum compression would reduce these 65536 bytes by 0 percent
00BD00  2               
00BD00  2               ; Chi square distribution for 65536 samples is 232.01, and
00BD00  2               ; randomly would exceed this value 75.00 percent of the time
00BD00  2               
00BD00  2               ; Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
00BD00  2               ; Monte Carlo value for Pi is 3.122871269, error 0.60 percent
00BD00  2               ; Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
00BD00  2               
00BD00  2               LAB_RND
00BD00  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00BD02  2  F0 07        	BEQ	NextPRN		; do next random # if zero
00BD04  2               
00BD04  2               					; else get seed into random number store
00BD04  2  A2 D8        	LDX	#Rbyte4		; set PRNG pointer low byte
00BD06  2  A0 00        	LDY	#$00		; set PRNG pointer high byte
00BD08  2  20 09 B9     	JSR	LAB_2778	; pack FAC1 into (XY)
00BD0B  2               NextPRN
00BD0B  2  A2 C5        	LDX	#$C5		; set EOR byte #$AF
00BD0D  2  A0 13        	LDY	#$13		; do this nineteen times
00BD0F  2               LoopPRN
00BD0F  2  06 D9        	ASL	Rbyte1		; shift PRNG most significant byte
00BD11  2  26 DA        	ROL	Rbyte2		; shift PRNG middle byte
00BD13  2  26 DB        	ROL	Rbyte3		; shift PRNG least significant byte
00BD15  2  26 D8        	ROL	Rbyte4		; shift PRNG extra byte
00BD17  2  90 05        	BCC	Ninc1		; branch if bit 32 clear
00BD19  2               
00BD19  2  8A           	TXA				; set EOR byte
00BD1A  2  45 D9        	EOR	Rbyte1		; EOR PRNG extra byte
00BD1C  2  85 D9        	STA	Rbyte1		; save new PRNG extra byte
00BD1E  2               Ninc1
00BD1E  2  88           	DEY				; decrement loop count
00BD1F  2  D0 EE        	BNE	LoopPRN		; loop if not all done
00BD21  2               
00BD21  2  A2 02        	LDX	#$02		; three bytes to copy
00BD23  2               CopyPRNG
00BD23  2  B5 D9        	LDA	Rbyte1,X	; get PRNG byte
00BD25  2  95 AD        	STA	FAC1_1,X	; save FAC1 byte
00BD27  2  CA           	DEX
00BD28  2  10 F9        	BPL	CopyPRNG	; loop if not complete
00BD2A  2               
00BD2A  2  A9 80        	LDA	#$80		; set the exponent
00BD2C  2  85 AC        	STA	FAC1_e		; save FAC1 exponent
00BD2E  2               
00BD2E  2  0A           	ASL			; clear A
00BD2F  2  85 B0        	STA	FAC1_s		; save FAC1 sign
00BD31  2               
00BD31  2  4C 96 B6     	JMP	LAB_24D5	; normalise FAC1 and return
00BD34  2               
00BD34  2               ; perform COS()
00BD34  2               
00BD34  2               LAB_COS
00BD34  2  A9 13        	LDA	#<LAB_2C78	; set (pi/2) pointer low byte
00BD36  2  A0 C2        	LDY	#>LAB_2C78	; set (pi/2) pointer high byte
00BD38  2  20 20 B6     	JSR	LAB_246C	; add (AY) to FAC1
00BD3B  2               
00BD3B  2               ; perform SIN()
00BD3B  2               
00BD3B  2               LAB_SIN
00BD3B  2  20 2C B9     	JSR	LAB_27AB	; round and copy FAC1 to FAC2
00BD3E  2  A9 28        	LDA	#<LAB_2C7C	; set (2*pi) pointer low byte
00BD40  2  A0 C2        	LDY	#>LAB_2C7C	; set (2*pi) pointer high byte
00BD42  2  A6 B7        	LDX	FAC2_s		; get FAC2 sign (b7)
00BD44  2  20 5B B8     	JSR	LAB_26C2	; divide by (AY) (X=sign)
00BD47  2  20 2C B9     	JSR	LAB_27AB	; round and copy FAC1 to FAC2
00BD4A  2  20 E3 B9     	JSR	LAB_INT		; perform INT
00BD4D  2  A9 00        	LDA	#$00		; clear byte
00BD4F  2  85 B8        	STA	FAC_sc		; clear sign compare (FAC1 EOR FAC2)
00BD51  2  20 08 B6     	JSR	LAB_SUBTRACT	; perform subtraction, FAC2 from FAC1
00BD54  2  A9 5A        	LDA	#<LAB_2C80	; set 0.25 pointer low byte
00BD56  2  A0 C2        	LDY	#>LAB_2C80	; set 0.25 pointer high byte
00BD58  2  20 05 B6     	JSR	LAB_2455	; perform subtraction, (AY) from FAC1
00BD5B  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
00BD5D  2  48           	PHA			; save FAC1 sign
00BD5E  2  10 0D        	BPL	LAB_2C35	; branch if +ve
00BD60  2               
00BD60  2               				; FAC1 sign was -ve
00BD60  2  20 1C B6     	JSR	LAB_244E	; add 0.5 to FAC1
00BD63  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
00BD65  2  30 09        	BMI	LAB_2C38	; branch if -ve
00BD67  2               
00BD67  2  A5 63        	LDA	Cflag		; get comparison evaluation flag
00BD69  2  49 FF        	EOR	#$FF		; toggle flag
00BD6B  2  85 63        	STA	Cflag		; save comparison evaluation flag
00BD6D  2               LAB_2C35
00BD6D  2  20 57 BC     	JSR	LAB_GTHAN	; do - FAC1
00BD70  2               LAB_2C38
00BD70  2  A9 5A        	LDA	#<LAB_2C80	; set 0.25 pointer low byte
00BD72  2  A0 C2        	LDY	#>LAB_2C80	; set 0.25 pointer high byte
00BD74  2  20 20 B6     	JSR	LAB_246C	; add (AY) to FAC1
00BD77  2  68           	PLA			; restore FAC1 sign
00BD78  2  10 03        	BPL	LAB_2C45	; branch if was +ve
00BD7A  2               
00BD7A  2               				; else correct FAC1
00BD7A  2  20 57 BC     	JSR	LAB_GTHAN	; do - FAC1
00BD7D  2               LAB_2C45
00BD7D  2  A9 17        	LDA	#<LAB_2C84	; set pointer low byte to counter
00BD7F  2  A0 C2        	LDY	#>LAB_2C84	; set pointer high byte to counter
00BD81  2  4C B4 BC     	JMP	LAB_2B6E	; ^2 then series evaluation and return
00BD84  2               
00BD84  2               ; perform TAN()
00BD84  2               
00BD84  2               LAB_TAN
00BD84  2  20 FF B8     	JSR	LAB_276E	; pack FAC1 into Adatal
00BD87  2  A9 00        	LDA	#$00		; clear byte
00BD89  2  85 63        	STA	Cflag		; clear comparison evaluation flag
00BD8B  2  20 3B BD     	JSR	LAB_SIN		; go do SIN(n)
00BD8E  2  A2 9C        	LDX	#<func_l	; set sin(n) pointer low byte
00BD90  2  A0 00        	LDY	#>func_l	; set sin(n) pointer high byte
00BD92  2  20 09 B9     	JSR	LAB_2778	; pack FAC1 into (XY)
00BD95  2  A9 A4        	LDA	#<Adatal	; set n pointer low addr
00BD97  2  A0 00        	LDY	#>Adatal	; set n pointer high addr
00BD99  2  20 DF B8     	JSR	LAB_UFAC	; unpack memory (AY) into FAC1
00BD9C  2  A9 00        	LDA	#$00		; clear byte
00BD9E  2  85 B0        	STA	FAC1_s		; clear FAC1 sign (b7)
00BDA0  2  A5 63        	LDA	Cflag		; get comparison evaluation flag
00BDA2  2  20 AC BD     	JSR	LAB_2C74	; save flag and go do series evaluation
00BDA5  2               
00BDA5  2  A9 9C        	LDA	#<func_l	; set sin(n) pointer low byte
00BDA7  2  A0 00        	LDY	#>func_l	; set sin(n) pointer high byte
00BDA9  2  4C 63 B8     	JMP	LAB_26CA	; convert AY and do (AY)/FAC1
00BDAC  2               
00BDAC  2               LAB_2C74
00BDAC  2  48           	PHA			; save comparison evaluation flag
00BDAD  2  4C 6D BD     	JMP	LAB_2C35	; go do series evaluation
00BDB0  2               
00BDB0  2               ; perform USR()
00BDB0  2               
00BDB0  2               LAB_USR
00BDB0  2  20 0A 00     	JSR	Usrjmp		; call user code
00BDB3  2  20 5C B5     	JSR	LAB_PEEKY	; return byte in A
00BDB6  2  4C 37 AC     	JMP	LAB_1BFB	; scan for ")", else do syntax error then warm start
00BDB9  2               
00BDB9  2               ; perform ATN()
00BDB9  2               
00BDB9  2               LAB_ATN
00BDB9  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
00BDBB  2  48           	PHA			; save sign
00BDBC  2  10 03        	BPL	LAB_2CA1	; branch if +ve
00BDBE  2               
00BDBE  2  20 57 BC     	JSR	LAB_GTHAN	; else do - FAC1
00BDC1  2               LAB_2CA1
00BDC1  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00BDC3  2  48           	PHA			; push exponent
00BDC4  2  C9 81        	CMP	#$81		; compare with 1
00BDC6  2  90 07        	BCC	LAB_2CAF	; branch if FAC1<1
00BDC8  2               
00BDC8  2  A9 4D        	LDA	#<LAB_259C	; set 1 pointer low byte
00BDCA  2  A0 C2        	LDY	#>LAB_259C	; set 1 pointer high byte
00BDCC  2  20 63 B8     	JSR	LAB_26CA	; convert AY and do (AY)/FAC1
00BDCF  2               LAB_2CAF
00BDCF  2  A9 2C        	LDA	#<LAB_2CC9	; set pointer low byte to counter
00BDD1  2  A0 C2        	LDY	#>LAB_2CC9	; set pointer high byte to counter
00BDD3  2  20 B4 BC     	JSR	LAB_2B6E	; ^2 then series evaluation
00BDD6  2  68           	PLA			; restore old FAC1 exponent
00BDD7  2  C9 81        	CMP	#$81		; compare with 1
00BDD9  2  90 07        	BCC	LAB_2CC2	; branch if FAC1<1
00BDDB  2               
00BDDB  2  A9 13        	LDA	#<LAB_2C78	; set (pi/2) pointer low byte
00BDDD  2  A0 C2        	LDY	#>LAB_2C78	; set (pi/2) pointer high byte
00BDDF  2  20 05 B6     	JSR	LAB_2455	; perform subtraction, (AY) from FAC1
00BDE2  2               LAB_2CC2
00BDE2  2  68           	PLA			; restore FAC1 sign
00BDE3  2  10 16        	BPL	LAB_2D04	; exit if was +ve
00BDE5  2               
00BDE5  2  4C 57 BC     	JMP	LAB_GTHAN	; else do - FAC1 and return
00BDE8  2               
00BDE8  2               ; perform BITSET
00BDE8  2               
00BDE8  2               LAB_BITSET
00BDE8  2  20 2A B5     	JSR	LAB_GADB	; get two parameters for POKE or WAIT
00BDEB  2  E0 08        	CPX	#$08		; only 0 to 7 are allowed
00BDED  2  B0 20        	BCS	FCError		; branch if > 7
00BDEF  2               
00BDEF  2  A9 00        	LDA	#$00		; clear A
00BDF1  2  38           	SEC			; set the carry
00BDF2  2               S_Bits
00BDF2  2  2A           	ROL			; shift bit
00BDF3  2  CA           	DEX			; decrement bit number
00BDF4  2  10 FC        	BPL	S_Bits		; loop if still +ve
00BDF6  2               
00BDF6  2  E8           	INX			; make X = $00
00BDF7  2  01 11        	ORA	(Itempl,X)	; or with byte via temporary integer (addr)
00BDF9  2  81 11        	STA	(Itempl,X)	; save byte via temporary integer (addr)
00BDFB  2               LAB_2D04
00BDFB  2  60           	RTS
00BDFC  2               
00BDFC  2               ; perform BITCLR
00BDFC  2               
00BDFC  2               LAB_BITCLR
00BDFC  2  20 2A B5     	JSR	LAB_GADB	; get two parameters for POKE or WAIT
00BDFF  2  E0 08        	CPX	#$08		; only 0 to 7 are allowed
00BE01  2  B0 0C        	BCS	FCError		; branch if > 7
00BE03  2               
00BE03  2  A9 FF        	LDA	#$FF		; set A
00BE05  2               S_Bitc
00BE05  2  2A           	ROL			; shift bit
00BE06  2  CA           	DEX			; decrement bit number
00BE07  2  10 FC        	BPL	S_Bitc		; loop if still +ve
00BE09  2               
00BE09  2  E8           	INX			; make X = $00
00BE0A  2  21 11        	AND	(Itempl,X)	; and with byte via temporary integer (addr)
00BE0C  2  81 11        	STA	(Itempl,X)	; save byte via temporary integer (addr)
00BE0E  2  60           	RTS
00BE0F  2               
00BE0F  2               FCError
00BE0F  2  4C 7F AF     	JMP	LAB_FCER	; do function call error then warm start
00BE12  2               
00BE12  2               ; perform BITTST()
00BE12  2               
00BE12  2               LAB_BTST
00BE12  2  20 BC 00     	JSR	LAB_IGBY	; increment BASIC pointer
00BE15  2  20 2A B5     	JSR	LAB_GADB	; get two parameters for POKE or WAIT
00BE18  2  E0 08        	CPX	#$08		; only 0 to 7 are allowed
00BE1A  2  B0 F3        	BCS	FCError		; branch if > 7
00BE1C  2               
00BE1C  2  20 C2 00     	JSR	LAB_GBYT	; get next BASIC byte
00BE1F  2  C9 29        	CMP	#')'		; is next character ")"
00BE21  2  F0 03        	BEQ	TST_OK		; if ")" go do rest of function
00BE23  2               
00BE23  2  4C 4A AC     	JMP	LAB_SNER	; do syntax error then warm start
00BE26  2               
00BE26  2               TST_OK
00BE26  2  20 BC 00     	JSR	LAB_IGBY	; update BASIC execute pointer (to character past ")")
00BE29  2  A9 00        	LDA	#$00		; clear A
00BE2B  2  38           	SEC			; set the carry
00BE2C  2               T_Bits
00BE2C  2  2A           	ROL			; shift bit
00BE2D  2  CA           	DEX			; decrement bit number
00BE2E  2  10 FC        	BPL	T_Bits		; loop if still +ve
00BE30  2               
00BE30  2  E8           	INX			; make X = $00
00BE31  2  21 11        	AND	(Itempl,X)	; AND with byte via temporary integer (addr)
00BE33  2  F0 02        	BEQ	LAB_NOTT	; branch if zero (already correct)
00BE35  2               
00BE35  2  A9 FF        	LDA	#$FF		; set for -1 result
00BE37  2               LAB_NOTT
00BE37  2  4C 5C B9     	JMP	LAB_27DB	; go do SGN tail
00BE3A  2               
00BE3A  2               ; perform BIN$()
00BE3A  2               
00BE3A  2               LAB_BINS
00BE3A  2  E0 19        	CPX	#$19		; max + 1
00BE3C  2  B0 48        	BCS	BinFErr		; exit if too big ( > or = )
00BE3E  2               
00BE3E  2  86 78        	STX	TempB		; save # of characters ($00 = leading zero remove)
00BE40  2  A9 18        	LDA	#$18		; need A byte long space
00BE42  2  20 8D B1     	JSR	LAB_MSSP	; make string space A bytes long
00BE45  2  A0 17        	LDY	#$17		; set index
00BE47  2  A2 18        	LDX	#$18		; character count
00BE49  2               NextB1
00BE49  2  46 11        	LSR	nums_1		; shift highest byte
00BE4B  2  66 12        	ROR	nums_2		; shift middle byte
00BE4D  2  66 13        	ROR	nums_3		; shift lowest byte bit 0 to carry
00BE4F  2  8A           	TXA			; load with "0"/2
00BE50  2  2A           	ROL			; shift in carry
00BE51  2  91 AD        	STA	(str_pl),Y	; save to temp string + index
00BE53  2  88           	DEY			; decrement index
00BE54  2  10 F3        	BPL	NextB1		; loop if not done
00BE56  2               
00BE56  2  A5 78        	LDA	TempB		; get # of characters
00BE58  2  F0 0A        	BEQ	EndBHS		; branch if truncate
00BE5A  2               
00BE5A  2  AA           	TAX			; copy length to X
00BE5B  2  38           	SEC			; set carry for add !
00BE5C  2  49 FF        	EOR	#$FF		; 1's complement
00BE5E  2  69 18        	ADC	#$18		; add 24d
00BE60  2  F0 1C        	BEQ	GoPr2		; if zero print whole string
00BE62  2               
00BE62  2  D0 0F        	BNE	GoPr1		; else go make output string
00BE64  2               
00BE64  2               ; this is the exit code and is also used by HEX$()
00BE64  2               ; truncate string to remove leading "0"s
00BE64  2               
00BE64  2               EndBHS
00BE64  2  A8           	TAY			; clear index (A=0, X=length here)
00BE65  2               NextB2
00BE65  2  B1 AD        	LDA	(str_pl),Y	; get character from string
00BE67  2  C9 30        	CMP	#'0'		; compare with "0"
00BE69  2  D0 07        	BNE	GoPr		; if not "0" then go print string from here
00BE6B  2               
00BE6B  2  CA           	DEX			; decrement character count
00BE6C  2  F0 03        	BEQ	GoPr3		; if zero then end of string so go print it
00BE6E  2               
00BE6E  2  C8           	INY			; else increment index
00BE6F  2  10 F4        	BPL	NextB2		; loop always
00BE71  2               
00BE71  2               ; make fixed length output string - ignore overflows!
00BE71  2               
00BE71  2               GoPr3
00BE71  2  E8           	INX			; need at least 1 character
00BE72  2               GoPr
00BE72  2  98           	TYA			; copy result
00BE73  2               GoPr1
00BE73  2  18           	CLC			; clear carry for add
00BE74  2  65 AD        	ADC	str_pl		; add low address
00BE76  2  85 AD        	STA	str_pl		; save low address
00BE78  2  A9 00        	LDA	#$00			; do high byte
00BE7A  2  65 AE        	ADC	str_ph		; add high address
00BE7C  2  85 AE        	STA	str_ph		; save high address
00BE7E  2               GoPr2
00BE7E  2  86 AC        	STX	str_ln		; X holds string length
00BE80  2  20 BC 00     	JSR	LAB_IGBY	; update BASIC execute pointer (to character past ")")
00BE83  2  4C DA B1     	JMP	LAB_RTST	; check for space on descriptor stack then put address
00BE86  2               				; and length on descriptor stack and update stack pointers
00BE86  2               
00BE86  2               BinFErr
00BE86  2  4C 7F AF     	JMP	LAB_FCER	; do function call error then warm start
00BE89  2               
00BE89  2               ; perform HEX$()
00BE89  2               
00BE89  2               LAB_HEXS
00BE89  2  E0 07        	CPX	#$07		; max + 1
00BE8B  2  B0 F9        	BCS	BinFErr		; exit if too big ( > or = )
00BE8D  2               
00BE8D  2  86 78        	STX	TempB		; save # of characters
00BE8F  2               
00BE8F  2  A9 06        	LDA	#$06		; need 6 bytes for string
00BE91  2  20 8D B1     	JSR	LAB_MSSP	; make string space A bytes long
00BE94  2  A0 05        	LDY	#$05		; set string index
00BE96  2               
00BE96  2               ; *** disable decimal mode patch - comment next line ***
00BE96  2               ;	SED			; need decimal mode for nibble convert
00BE96  2  A5 13        	LDA	nums_3		; get lowest byte
00BE98  2  20 B5 BE     	JSR	LAB_A2HX	; convert A to ASCII hex byte and output
00BE9B  2  A5 12        	LDA	nums_2		; get middle byte
00BE9D  2  20 B5 BE     	JSR	LAB_A2HX	; convert A to ASCII hex byte and output
00BEA0  2  A5 11        	LDA	nums_1		; get highest byte
00BEA2  2  20 B5 BE     	JSR	LAB_A2HX	; convert A to ASCII hex byte and output
00BEA5  2               ; *** disable decimal mode patch - comment next line ***
00BEA5  2               ;	CLD			; back to binary
00BEA5  2               
00BEA5  2  A2 06        	LDX	#$06		; character count
00BEA7  2  A5 78        	LDA	TempB		; get # of characters
00BEA9  2  F0 B9        	BEQ	EndBHS		; branch if truncate
00BEAB  2               
00BEAB  2  AA           	TAX			; copy length to X
00BEAC  2  38           	SEC			; set carry for add !
00BEAD  2  49 FF        	EOR	#$FF		; 1's complement
00BEAF  2  69 06        	ADC	#$06		; add 6d
00BEB1  2  F0 CB        	BEQ	GoPr2		; if zero print whole string
00BEB3  2               
00BEB3  2  D0 BE        	BNE	GoPr1		; else go make output string (branch always)
00BEB5  2               
00BEB5  2               ; convert A to ASCII hex byte and output .. note set decimal mode before calling
00BEB5  2               
00BEB5  2               LAB_A2HX
00BEB5  2  AA           	TAX			; save byte
00BEB6  2  29 0F        	AND	#$0F		; mask off top bits
00BEB8  2  20 C0 BE     	JSR	LAB_AL2X	; convert low nibble to ASCII and output
00BEBB  2  8A           	TXA			; get byte back
00BEBC  2  4A           	LSR			; /2	shift high nibble to low nibble
00BEBD  2  4A           	LSR			; /4
00BEBE  2  4A           	LSR			; /8
00BEBF  2  4A           	LSR			; /16
00BEC0  2               LAB_AL2X
00BEC0  2  C9 0A        	CMP	#$0A		; set carry for +1 if >9
00BEC2  2               ;; *** begin disable decimal mode patch ***
00BEC2  2               ;; *** insert
00BEC2  2  90 02        	BCC	LAB_AL20	; skip adjust if <= 9
00BEC4  2  69 06        	ADC	#$06		; adjust for A to F
00BEC6  2               LAB_AL20
00BEC6  2               ;; *** end   disable decimal mode patch ***
00BEC6  2  69 30        	ADC	#'0'		; add ASCII "0"
00BEC8  2  91 AD        	STA	(str_pl),Y	; save to temp string
00BECA  2  88           	DEY			; decrement counter
00BECB  2  60           	RTS
00BECC  2               
00BECC  2               LAB_NLTO
00BECC  2  85 AC        	STA	FAC1_e		; save FAC1 exponent
00BECE  2  A9 00        	LDA	#$00		; clear sign compare
00BED0  2               LAB_MLTE
00BED0  2  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
00BED2  2  8A           	TXA			; restore character
00BED3  2  20 A7 BA     	JSR	LAB_2912	; evaluate new ASCII digit
00BED6  2               
00BED6  2               ; gets here if the first character was "$" for hex
00BED6  2               ; get hex number
00BED6  2               
00BED6  2               LAB_CHEX
00BED6  2  20 BC 00     	JSR	LAB_IGBY	; increment and scan memory
00BED9  2  90 0A        	BCC	LAB_ISHN	; branch if numeric character
00BEDB  2               
00BEDB  2  09 20        	ORA	#$20		; case convert, allow "A" to "F" and "a" to "f"
00BEDD  2  E9 61        	SBC	#'a'		; subtract "a" (carry set here)
00BEDF  2  C9 06        	CMP	#$06		; compare normalised with $06 (max+1)
00BEE1  2  B0 2A        	BCS	LAB_EXCH	; exit if >"f" or <"0"
00BEE3  2               
00BEE3  2  69 0A        	ADC	#$0A		; convert to nibble
00BEE5  2               LAB_ISHN
00BEE5  2  29 0F        	AND	#$0F		; convert to binary
00BEE7  2  AA           	TAX			; save nibble
00BEE8  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00BEEA  2  F0 E4        	BEQ	LAB_MLTE	; skip multiply if zero
00BEEC  2               
00BEEC  2  69 04        	ADC	#$04		; add four to exponent (*16 - carry clear here)
00BEEE  2  90 DC        	BCC	LAB_NLTO	; if no overflow do evaluate digit
00BEF0  2               
00BEF0  2               LAB_MLTO
00BEF0  2  4C 25 B7     	JMP	LAB_2564	; do overflow error and warm start
00BEF3  2               
00BEF3  2               LAB_NXCH
00BEF3  2  AA           	TAX			; save bit
00BEF4  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00BEF6  2  F0 06        	BEQ	LAB_MLBT	; skip multiply if zero
00BEF8  2               
00BEF8  2  E6 AC        	INC	FAC1_e		; increment FAC1 exponent (*2)
00BEFA  2  F0 F4        	BEQ	LAB_MLTO	; do overflow error if = $00
00BEFC  2               
00BEFC  2  A9 00        	LDA	#$00		; clear sign compare
00BEFE  2               LAB_MLBT
00BEFE  2  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
00BF00  2  8A           	TXA			; restore bit
00BF01  2  20 A7 BA     	JSR	LAB_2912	; evaluate new ASCII digit
00BF04  2               
00BF04  2               ; gets here if the first character was  "%" for binary
00BF04  2               ; get binary number
00BF04  2               
00BF04  2               LAB_CBIN
00BF04  2  20 BC 00     	JSR	LAB_IGBY	; increment and scan memory
00BF07  2  49 30        	EOR	#'0'		; convert "0" to 0 etc.
00BF09  2  C9 02        	CMP	#$02		; compare with max+1
00BF0B  2  90 E6        	BCC	LAB_NXCH	; branch exit if < 2
00BF0D  2               
00BF0D  2               LAB_EXCH
00BF0D  2  4C 8C BA     	JMP	LAB_28F6	; evaluate -ve flag and return
00BF10  2               
00BF10  2               ; ctrl-c check routine. includes limited "life" byte save for INGET routine
00BF10  2               ; now also the code that checks to see if an interrupt has occurred
00BF10  2               
00BF10  2               CTRLC
00BF10  2  AD 00 02     	LDA	ccflag		; get [CTRL-C] check flag
00BF13  2  D0 18        	BNE	LAB_FBA2	; exit if inhibited
00BF15  2               
00BF15  2  20 52 C1     	JSR	V_INPT		; scan input device
00BF18  2  90 0B        	BCC	LAB_FBA0	; exit if buffer empty
00BF1A  2               
00BF1A  2  8D 01 02     	STA	ccbyte		; save received byte
00BF1D  2  A2 20        	LDX	#$20		; "life" timer for bytes
00BF1F  2  8E 02 02     	STX	ccnull		; set countdown
00BF22  2  4C 64 A5     	JMP	LAB_1636	; return to BASIC
00BF25  2               
00BF25  2               LAB_FBA0
00BF25  2  AE 02 02     	LDX	ccnull		; get countdown byte
00BF28  2  F0 03        	BEQ	LAB_FBA2	; exit if finished
00BF2A  2               
00BF2A  2  CE 02 02     	DEC	ccnull		; else decrement countdown
00BF2D  2               LAB_FBA2
00BF2D  2               .ifdef IRQVEC
00BF2D  2  A2 DC        	LDX	#NmiBase	; set pointer to NMI values
00BF2F  2  20 38 BF     	JSR	LAB_CKIN	; check interrupt
00BF32  2  A2 DF        	LDX	#IrqBase	; set pointer to IRQ values
00BF34  2  20 38 BF     	JSR	LAB_CKIN	; check interrupt
00BF37  2               .endif
00BF37  2               LAB_CRTS
00BF37  2  60           	RTS
00BF38  2               
00BF38  2               ; check whichever interrupt is indexed by X
00BF38  2               
00BF38  2               LAB_CKIN
00BF38  2  B5 00        	LDA	PLUS_0,X	; get interrupt flag byte
00BF3A  2  10 FB        	BPL	LAB_CRTS	; branch if interrupt not enabled
00BF3C  2               
00BF3C  2               ; we disable the interrupt here and make two new commands RETIRQ and RETNMI to
00BF3C  2               ; automatically enable the interrupt when we exit
00BF3C  2               
00BF3C  2  0A           	ASL			; move happened bit to setup bit
00BF3D  2  29 40        	AND	#$40		; mask happened bits
00BF3F  2  F0 F6        	BEQ	LAB_CRTS	; if no interrupt then exit
00BF41  2               
00BF41  2  95 00        	STA	PLUS_0,X	; save interrupt flag byte
00BF43  2               
00BF43  2  8A           	TXA			; copy index ..
00BF44  2  A8           	TAY			; .. to Y
00BF45  2               
00BF45  2  68           	PLA			; dump return address low byte, call from CTRL-C
00BF46  2  68           	PLA			; dump return address high byte
00BF47  2               
00BF47  2  A9 05        	LDA	#$05		; need 5 bytes for GOSUB
00BF49  2  20 10 A1     	JSR	LAB_1212	; check room on stack for A bytes
00BF4C  2  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
00BF4E  2  48           	PHA			; push on stack
00BF4F  2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
00BF51  2  48           	PHA			; push on stack
00BF52  2  A5 88        	LDA	Clineh		; get current line high byte
00BF54  2  48           	PHA			; push on stack
00BF55  2  A5 87        	LDA	Clinel		; get current line low byte
00BF57  2  48           	PHA			; push on stack
00BF58  2  A9 8D        	LDA	#TK_GOSUB	; token for GOSUB
00BF5A  2  48           	PHA			; push on stack
00BF5B  2               
00BF5B  2  B9 01 00     	LDA	PLUS_1,Y	; get interrupt code pointer low byte
00BF5E  2  85 C3        	STA	Bpntrl		; save as BASIC execute pointer low byte
00BF60  2  B9 02 00     	LDA	PLUS_2,Y	; get interrupt code pointer high byte
00BF63  2  85 C4        	STA	Bpntrh		; save as BASIC execute pointer high byte
00BF65  2               
00BF65  2  4C 0B A5     	JMP	LAB_15C2	; go to interpreter inner loop
00BF68  2               				; can't RTS, we used the stack! the RTS from the ctrl-c
00BF68  2               				; check will be taken when the RETIRQ/RETNMI/RETURN is
00BF68  2               				; executed at the end of the subroutine
00BF68  2               
00BF68  2               ; get byte from input device, no waiting
00BF68  2               ; returns with carry set if byte in A
00BF68  2               
00BF68  2               INGET
00BF68  2               ; shouldn't this check ccnull before V_INPT?
00BF68  2               ; shouldn't INPUT call this instead of directly calling V_INPT?
00BF68  2  20 52 C1     	JSR	V_INPT		; call scan input device
00BF6B  2  B0 09        	BCS	LAB_FB95	; if byte go reset timer
00BF6D  2               
00BF6D  2  AD 02 02     	LDA	ccnull		; get countdown
00BF70  2  F0 09        	BEQ	LAB_FB96	; exit if empty
00BF72  2               
00BF72  2  AD 01 02     	LDA	ccbyte		; get last received byte
00BF75  2  38           	SEC			; flag we got a byte
00BF76  2               LAB_FB95
00BF76  2  A2 00        	LDX	#$00		; clear X
00BF78  2  8E 02 02     	STX	ccnull		; clear timer because we got a byte
00BF7B  2               LAB_FB96
00BF7B  2  60           	RTS
00BF7C  2               
00BF7C  2               ; these routines only enable the interrupts if the setup flag is set
00BF7C  2               ; if not they have no effect
00BF7C  2               
00BF7C  2               ; perform IRQ {ON|OFF|CLEAR}
00BF7C  2               LAB_IRQ
00BF7C  2               .ifdef IRQVEC
00BF7C  2  A2 DF        	LDX	#IrqBase	; set pointer to IRQ values
00BF7E  2  2C           	.byte	$2C		; make next line BIT abs.
00BF7F  2               .endif
00BF7F  2               ; perform NMI {ON|OFF|CLEAR}
00BF7F  2               
00BF7F  2               LAB_NMI
00BF7F  2               .ifdef IRQVEC
00BF7F  2  A2 DC        	LDX	#NmiBase	; set pointer to NMI values
00BF81  2  C9 93        	CMP	#TK_ON		; compare with token for ON
00BF83  2  F0 11        	BEQ	LAB_INON	; go turn on interrupt
00BF85  2               
00BF85  2  C9 CC        	CMP	#TK_OFF		; compare with token for OFF
00BF87  2  F0 07        	BEQ	LAB_IOFF	; go turn off interrupt
00BF89  2               
00BF89  2  49 A2        	EOR	#TK_CLEAR	; compare with token for CLEAR, A = $00 if = TK_CLEAR
00BF8B  2  F0 0E        	BEQ	LAB_INEX	; go clear interrupt flags and return
00BF8D  2  4C 4A AC     	JMP	LAB_SNER	; do syntax error then warm start
00BF90  2               
00BF90  2               LAB_IOFF
00BF90  2  A9 7F        	LDA	#$7F		; clear A
00BF92  2  35 00        	AND	PLUS_0,X	; AND with interrupt setup flag
00BF94  2  10 05        	BPL	LAB_INEX	; go clear interrupt enabled flag and return
00BF96  2               
00BF96  2               LAB_INON
00BF96  2  B5 00        	LDA	PLUS_0,X	; get interrupt setup flag
00BF98  2  0A           	ASL			; Shift bit to enabled flag
00BF99  2  15 00        	ORA	PLUS_0,X	; OR with flag byte
00BF9B  2               LAB_INEX
00BF9B  2  95 00        	STA	PLUS_0,X	; save interrupt flag byte
00BF9D  2               .endif
00BF9D  2  4C BC 00     	JMP	LAB_IGBY	; update BASIC execute pointer and return
00BFA0  2               
00BFA0  2               ; these routines set up the pointers and flags for the interrupt routines
00BFA0  2               ; note that the interrupts are also enabled by these commands
00BFA0  2               
00BFA0  2               ; perform ON IRQ
00BFA0  2               .ifdef IRQVEC
00BFA0  2               LAB_SIRQ
00BFA0  2  58           	CLI			; enable interrupts
00BFA1  2  A2 DF        	LDX	#IrqBase	; set pointer to IRQ values
00BFA3  2  2C           	.byte	$2C		; make next line BIT abs.
00BFA4  2               
00BFA4  2               ; perform ON NMI
00BFA4  2               
00BFA4  2               LAB_SNMI
00BFA4  2  A2 DC        	LDX	#NmiBase	; set pointer to NMI values
00BFA6  2  86 78        	STX	TempB		; save interrupt pointer
00BFA8  2  20 BC 00     	JSR	LAB_IGBY	; increment and scan memory (past token)
00BFAB  2  20 A1 A7     	JSR	LAB_GFPN	; get fixed-point number into temp integer
00BFAE  2  A5 79        	LDA	Smeml		; get start of mem low byte
00BFB0  2  A6 7A        	LDX	Smemh		; get start of mem high byte
00BFB2  2  20 75 A3     	JSR	LAB_SHLN	; search Basic for temp integer line number from AX
00BFB5  2  B0 03        	BCS	LAB_LFND	; if carry set go set-up interrupt
00BFB7  2               
00BFB7  2  4C BB A6     	JMP	LAB_16F7	; else go to "Undefined statement" error and warm start
00BFBA  2               
00BFBA  2               LAB_LFND
00BFBA  2  A6 78        	LDX	TempB		; get interrupt pointer
00BFBC  2  A5 AA        	LDA	Baslnl		; get pointer low byte
00BFBE  2  E9 01        	SBC	#$01		; -1 (carry already set for subtract)
00BFC0  2  95 01        	STA	PLUS_1,X	; save as interrupt pointer low byte
00BFC2  2  A5 AB        	LDA	Baslnh		; get pointer high byte
00BFC4  2  E9 00        	SBC	#$00		; subtract carry
00BFC6  2  95 02        	STA	PLUS_2,X	; save as interrupt pointer high byte
00BFC8  2               
00BFC8  2  A9 C0        	LDA	#$C0		; set interrupt enabled/setup bits
00BFCA  2  95 00        	STA	PLUS_0,X	; set interrupt flags
00BFCC  2               LAB_IRTS
00BFCC  2               .endif
00BFCC  2  60           	RTS
00BFCD  2               
00BFCD  2               ; return from IRQ service, restores the enabled flag.
00BFCD  2               ; perform RETIRQ
00BFCD  2               LAB_RETIRQ
00BFCD  2               .ifdef IRQVEC
00BFCD  2  D0 FD        	BNE	LAB_IRTS	; exit if following token (to allow syntax error)
00BFCF  2               
00BFCF  2  A5 DF        	LDA	IrqBase		; get interrupt flags
00BFD1  2  0A           	ASL			; copy setup to enabled (b7)
00BFD2  2  05 DF        	ORA	IrqBase		; OR in setup flag
00BFD4  2  85 DF        	STA	IrqBase		; save enabled flag
00BFD6  2  4C C2 A6     	JMP	LAB_16E8	; go do rest of RETURN
00BFD9  2               .endif
00BFD9  2               
00BFD9  2               ; return from NMI service, restores the enabled flag.
00BFD9  2               ; perform RETNMI
00BFD9  2               LAB_RETNMI
00BFD9  2               .ifdef IRQVEC
00BFD9  2  D0 F1        	BNE	LAB_IRTS	; exit if following token (to allow syntax error)
00BFDB  2               
00BFDB  2  A5 DC        	LDA	NmiBase		; get set-up flag
00BFDD  2  0A           	ASL			; copy setup to enabled (b7)
00BFDE  2  05 DC        	ORA	NmiBase		; OR in setup flag
00BFE0  2  85 DC        	STA	NmiBase		; save enabled flag
00BFE2  2  4C C2 A6     	JMP	LAB_16E8	; go do rest of RETURN
00BFE5  2               .endif
00BFE5  2               
00BFE5  2               ; MAX() MIN() preprocess
00BFE5  2               
00BFE5  2               LAB_MMPP
00BFE5  2  20 30 AB     	JSR	LAB_EVEZ	; process expression
00BFE8  2  4C 17 AB     	JMP	LAB_CTNM	; check if source is numeric, else do type mismatch
00BFEB  2               
00BFEB  2               ; perform MAX()
00BFEB  2               
00BFEB  2               LAB_MAX
00BFEB  2  20 19 C0     	JSR	LAB_PHFA	; push FAC1, evaluate expression,
00BFEE  2               				; pull FAC2 and compare with FAC1
00BFEE  2  10 FB        	BPL	LAB_MAX		; branch if no swap to do
00BFF0  2               
00BFF0  2  A5 B4        	LDA	FAC2_1		; get FAC2 mantissa1
00BFF2  2  09 80        	ORA	#$80		; set top bit (clear sign from compare)
00BFF4  2  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
00BFF6  2  20 25 B6     	JSR	LAB_279B	; copy FAC2 to FAC1
00BFF9  2  F0 F0        	BEQ	LAB_MAX		; go do next (branch always)
00BFFB  2               
00BFFB  2               ; perform MIN()
00BFFB  2               
00BFFB  2               LAB_MIN
00BFFB  2  20 19 C0     	JSR	LAB_PHFA	; push FAC1, evaluate expression,
00BFFE  2               				; pull FAC2 and compare with FAC1
00BFFE  2  30 FB        	BMI	LAB_MIN		; branch if no swap to do
00C000  2               
00C000  2  F0 F9        	BEQ	LAB_MIN		; branch if no swap to do
00C002  2               
00C002  2  A5 B4        	LDA	FAC2_1		; get FAC2 mantissa1
00C004  2  09 80        	ORA	#$80		; set top bit (clear sign from compare)
00C006  2  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
00C008  2  20 25 B6     	JSR	LAB_279B	; copy FAC2 to FAC1
00C00B  2  F0 EE        	BEQ	LAB_MIN		; go do next (branch always)
00C00D  2               
00C00D  2               ; exit routine. don't bother returning to the loop code
00C00D  2               ; check for correct exit, else so syntax error
00C00D  2               
00C00D  2               LAB_MMEC
00C00D  2  C9 29        	CMP	#')'		; is it end of function?
00C00F  2  D0 05        	BNE	LAB_MMSE	; if not do MAX MIN syntax error
00C011  2               
00C011  2  68           	PLA			; dump return address low byte
00C012  2  68           	PLA			; dump return address high byte
00C013  2  4C BC 00     	JMP	LAB_IGBY	; update BASIC execute pointer (to chr past ")")
00C016  2               
00C016  2               LAB_MMSE
00C016  2  4C 4A AC     	JMP	LAB_SNER	; do syntax error then warm start
00C019  2               
00C019  2               ; check for next, evaluate and return or exit
00C019  2               ; this is the routine that does most of the work
00C019  2               
00C019  2               LAB_PHFA
00C019  2  20 C2 00     	JSR	LAB_GBYT	; get next BASIC byte
00C01C  2  C9 2C        	CMP	#','		; is there more ?
00C01E  2  D0 ED        	BNE	LAB_MMEC	; if not go do end check
00C020  2               
00C020  2               				; push FAC1
00C020  2  20 3B B9     	JSR	LAB_27BA	; round FAC1
00C023  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign
00C025  2  09 7F        	ORA	#$7F		; set all non sign bits
00C027  2  25 AD        	AND	FAC1_1		; AND FAC1 mantissa1 (AND in sign bit)
00C029  2  48           	PHA			; push on stack
00C02A  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
00C02C  2  48           	PHA			; push on stack
00C02D  2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
00C02F  2  48           	PHA			; push on stack
00C030  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00C032  2  48           	PHA			; push on stack
00C033  2               
00C033  2  20 BC 00     	JSR	LAB_IGBY	; scan and get next BASIC byte (after ",")
00C036  2  20 14 AB     	JSR	LAB_EVNM	; evaluate expression and check is numeric,
00C039  2               				; else do type mismatch
00C039  2               
00C039  2               				; pop FAC2 (MAX/MIN expression so far)
00C039  2  68           	PLA			; pop exponent
00C03A  2  85 B3        	STA	FAC2_e		; save FAC2 exponent
00C03C  2  68           	PLA			; pop mantissa3
00C03D  2  85 B6        	STA	FAC2_3		; save FAC2 mantissa3
00C03F  2  68           	PLA			; pop mantissa1
00C040  2  85 B5        	STA	FAC2_2		; save FAC2 mantissa2
00C042  2  68           	PLA			; pop sign/mantissa1
00C043  2  85 B4        	STA	FAC2_1		; save FAC2 sign/mantissa1
00C045  2  85 B7        	STA	FAC2_s		; save FAC2 sign
00C047  2               
00C047  2               				; compare FAC1 with (packed) FAC2
00C047  2  A9 B3        	LDA	#<FAC2_e	; set pointer low byte to FAC2
00C049  2  A0 00        	LDY	#>FAC2_e	; set pointer high byte to FAC2
00C04B  2  4C 79 B9     	JMP	LAB_27F8	; compare FAC1 with FAC2 (AY) and return
00C04E  2               				; returns A=$00 if FAC1 = (AY)
00C04E  2               				; returns A=$01 if FAC1 > (AY)
00C04E  2               				; returns A=$FF if FAC1 < (AY)
00C04E  2               
00C04E  2               ; perform WIDTH
00C04E  2               
00C04E  2               LAB_WDTH
00C04E  2  C9 2C        	CMP	#','		; is next byte ","
00C050  2  F0 1B        	BEQ	LAB_TBSZ	; if so do tab size
00C052  2               
00C052  2  20 E5 B4     	JSR	LAB_GTBY	; get byte parameter
00C055  2  8A           	TXA			; copy width to A
00C056  2  F0 0A        	BEQ	LAB_NSTT	; branch if set for infinite line
00C058  2               
00C058  2  E0 10        	CPX	#$10		; else make min width = 16d
00C05A  2  90 45        	BCC	TabErr		; if less do function call error and exit
00C05C  2               
00C05C  2               ; this next compare ensures that we can't exit WIDTH via an error leaving the
00C05C  2               ; tab size greater than the line length.
00C05C  2               
00C05C  2  E4 64        	CPX	TabSiz		; compare with tab size
00C05E  2  B0 02        	BCS	LAB_NSTT	; branch if >= tab size
00C060  2               
00C060  2  86 64        	STX	TabSiz		; else make tab size = terminal width
00C062  2               LAB_NSTT
00C062  2  86 0F        	STX	TWidth		; set the terminal width
00C064  2  20 C2 00     	JSR	LAB_GBYT	; get BASIC byte back
00C067  2  F0 1A        	BEQ	WExit		; exit if no following
00C069  2               
00C069  2  C9 2C        	CMP	#','		; else is it ","
00C06B  2  D0 A9        	BNE	LAB_MMSE	; if not do syntax error
00C06D  2               
00C06D  2               LAB_TBSZ
00C06D  2  20 E2 B4     	JSR	LAB_SGBY	; scan and get byte parameter
00C070  2  8A           	TXA			; copy TAB size
00C071  2  30 2E        	BMI	TabErr		; if >127 do function call error and exit
00C073  2               
00C073  2  E0 01        	CPX	#$01		; compare with min-1
00C075  2  90 2A        	BCC	TabErr		; if <=1 do function call error and exit
00C077  2               
00C077  2  A5 0F        	LDA	TWidth		; set flags for width
00C079  2  F0 06        	BEQ	LAB_SVTB	; skip check if infinite line
00C07B  2               
00C07B  2  E4 0F        	CPX	TWidth		; compare TAB with width
00C07D  2  F0 02        	BEQ	LAB_SVTB	; ok if =
00C07F  2               
00C07F  2  B0 20        	BCS	TabErr		; branch if too big
00C081  2               
00C081  2               LAB_SVTB
00C081  2  86 64        	STX	TabSiz		; save TAB size
00C083  2               
00C083  2               ; calculate tab column limit from TAB size. The Iclim is set to the last tab
00C083  2               ; position on a line that still has at least one whole tab width between it
00C083  2               ; and the end of the line.
00C083  2               
00C083  2               WExit
00C083  2  A5 0F        	LDA	TWidth		; get width
00C085  2  F0 06        	BEQ	LAB_SULP	; branch if infinite line
00C087  2               
00C087  2  C5 64        	CMP	TabSiz		; compare with tab size
00C089  2  B0 03        	BCS	LAB_WDLP	; branch if >= tab size
00C08B  2               
00C08B  2  85 64        	STA	TabSiz		; else make tab size = terminal width
00C08D  2               LAB_SULP
00C08D  2  38           	SEC			; set carry for subtract
00C08E  2               LAB_WDLP
00C08E  2  E5 64        	SBC	TabSiz		; subtract tab size
00C090  2  B0 FC        	BCS	LAB_WDLP	; loop while no borrow
00C092  2               
00C092  2  65 64        	ADC	TabSiz		; add tab size back
00C094  2  18           	CLC			; clear carry for add
00C095  2  65 64        	ADC	TabSiz		; add tab size back again
00C097  2  85 10        	STA	Iclim		; save for now
00C099  2  A5 0F        	LDA	TWidth		; get width back
00C09B  2  38           	SEC			; set carry for subtract
00C09C  2  E5 10        	SBC	Iclim		; subtract remainder
00C09E  2  85 10        	STA	Iclim		; save tab column limit
00C0A0  2               LAB_NOSQ
00C0A0  2  60           	RTS
00C0A1  2               
00C0A1  2               TabErr
00C0A1  2  4C 7F AF     	JMP	LAB_FCER	; do function call error then warm start
00C0A4  2               
00C0A4  2               ; perform SQR()
00C0A4  2               
00C0A4  2               LAB_SQR
00C0A4  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign
00C0A6  2  30 F9        	BMI	TabErr		; if -ve do function call error
00C0A8  2               
00C0A8  2  A5 AC        	LDA	FAC1_e		; get exponent
00C0AA  2  F0 F4        	BEQ	LAB_NOSQ	; if zero just return
00C0AC  2               
00C0AC  2               				; else do root
00C0AC  2  20 2C B9     	JSR	LAB_27AB	; round and copy FAC1 to FAC2
00C0AF  2  A9 00        	LDA	#$00		; clear A
00C0B1  2               
00C0B1  2  85 77        	STA	FACt_3		; clear remainder
00C0B3  2  85 76        	STA	FACt_2		; ..
00C0B5  2  85 75        	STA	FACt_1		; ..
00C0B7  2  85 78        	STA	TempB		; ..
00C0B9  2               
00C0B9  2  85 AF        	STA	FAC1_3		; clear root
00C0BB  2  85 AE        	STA	FAC1_2		; ..
00C0BD  2  85 AD        	STA	FAC1_1		; ..
00C0BF  2               
00C0BF  2  A2 18        	LDX	#$18		; 24 pairs of bits to do
00C0C1  2  A5 B3        	LDA	FAC2_e		; get exponent
00C0C3  2  4A           	LSR			; check odd/even
00C0C4  2  B0 0E        	BCS	LAB_SQE2	; if odd only 1 shift first time
00C0C6  2               
00C0C6  2               LAB_SQE1
00C0C6  2  06 B6        	ASL	FAC2_3		; shift highest bit of number ..
00C0C8  2  26 B5        	ROL	FAC2_2		; ..
00C0CA  2  26 B4        	ROL	FAC2_1		; ..
00C0CC  2  26 77        	ROL	FACt_3		; .. into remainder
00C0CE  2  26 76        	ROL	FACt_2		; ..
00C0D0  2  26 75        	ROL	FACt_1		; ..
00C0D2  2  26 78        	ROL	TempB		; .. never overflows
00C0D4  2               LAB_SQE2
00C0D4  2  06 B6        	ASL	FAC2_3		; shift highest bit of number ..
00C0D6  2  26 B5        	ROL	FAC2_2		; ..
00C0D8  2  26 B4        	ROL	FAC2_1		; ..
00C0DA  2  26 77        	ROL	FACt_3		; .. into remainder
00C0DC  2  26 76        	ROL	FACt_2		; ..
00C0DE  2  26 75        	ROL	FACt_1		; ..
00C0E0  2  26 78        	ROL	TempB		; .. never overflows
00C0E2  2               
00C0E2  2  06 AF        	ASL	FAC1_3		; root = root * 2
00C0E4  2  26 AE        	ROL	FAC1_2		; ..
00C0E6  2  26 AD        	ROL	FAC1_1		; .. never overflows
00C0E8  2               
00C0E8  2  A5 AF        	LDA	FAC1_3		; get root low byte
00C0EA  2  2A           	ROL			; *2
00C0EB  2  85 5B        	STA	Temp3		; save partial low byte
00C0ED  2  A5 AE        	LDA	FAC1_2		; get root low mid byte
00C0EF  2  2A           	ROL			; *2
00C0F0  2  85 5C        	STA	Temp3+1		; save partial low mid byte
00C0F2  2  A5 AD        	LDA	FAC1_1		; get root high mid byte
00C0F4  2  2A           	ROL			; *2
00C0F5  2  85 5D        	STA	Temp3+2		; save partial high mid byte
00C0F7  2  A9 00        	LDA	#$00		; get root high byte (always $00)
00C0F9  2  2A           	ROL			; *2
00C0FA  2  85 5E        	STA	Temp3+3		; save partial high byte
00C0FC  2               
00C0FC  2               				; carry clear for subtract +1
00C0FC  2  A5 77        	LDA	FACt_3		; get remainder low byte
00C0FE  2  E5 5B        	SBC	Temp3		; subtract partial low byte
00C100  2  85 5B        	STA	Temp3		; save partial low byte
00C102  2               
00C102  2  A5 76        	LDA	FACt_2		; get remainder low mid byte
00C104  2  E5 5C        	SBC	Temp3+1		; subtract partial low mid byte
00C106  2  85 5C        	STA	Temp3+1		; save partial low mid byte
00C108  2               
00C108  2  A5 75        	LDA	FACt_1		; get remainder high mid byte
00C10A  2  E5 5D        	SBC	Temp3+2		; subtract partial high mid byte
00C10C  2  A8           	TAY			; copy partial high mid byte
00C10D  2               
00C10D  2  A5 78        	LDA	TempB		; get remainder high byte
00C10F  2  E5 5E        	SBC	Temp3+3		; subtract partial high byte
00C111  2  90 0E        	BCC	LAB_SQNS	; skip sub if remainder smaller
00C113  2               
00C113  2  85 78        	STA	TempB		; save remainder high byte
00C115  2               
00C115  2  84 75        	STY	FACt_1		; save remainder high mid byte
00C117  2               
00C117  2  A5 5C        	LDA	Temp3+1		; get remainder low mid byte
00C119  2  85 76        	STA	FACt_2		; save remainder low mid byte
00C11B  2               
00C11B  2  A5 5B        	LDA	Temp3		; get partial low byte
00C11D  2  85 77        	STA	FACt_3		; save remainder low byte
00C11F  2               
00C11F  2  E6 AF        	INC	FAC1_3		; increment root low byte (never any rollover)
00C121  2               LAB_SQNS
00C121  2  CA           	DEX			; decrement bit pair count
00C122  2  D0 A2        	BNE	LAB_SQE1	; loop if not all done
00C124  2               
00C124  2  38           	SEC			; set carry for subtract
00C125  2  A5 B3        	LDA	FAC2_e		; get exponent
00C127  2  E9 80        	SBC	#$80		; normalise
00C129  2  6A           	ROR			; /2 and re-bias to $80
00C12A  2  69 00        	ADC	#$00		; add bit zero back in (allow for half shift)
00C12C  2  85 AC        	STA	FAC1_e		; save it
00C12E  2  4C 96 B6     	JMP	LAB_24D5	; normalise FAC1 and return
00C131  2               
00C131  2               ; perform VARPTR()
00C131  2               
00C131  2               LAB_VARPTR
00C131  2  20 BC 00     	JSR	LAB_IGBY	; increment and scan memory
00C134  2  20 00 AE     	JSR	LAB_GVAR	; get var address
00C137  2  20 37 AC     	JSR	LAB_1BFB	; scan for ")" , else do syntax error then warm start
00C13A  2  A4 95        	LDY	Cvaral		; get var address low byte
00C13C  2  A5 96        	LDA	Cvarah		; get var address high byte
00C13E  2  4C AF B0     	JMP	LAB_AYFC	; save and convert integer AY to FAC1 and return
00C141  2               
00C141  2               ; perform PI
00C141  2               
00C141  2               LAB_PI
00C141  2  A9 28        	LDA	#<LAB_2C7C	; set (2*pi) pointer low byte
00C143  2  A0 C2        	LDY	#>LAB_2C7C	; set (2*pi) pointer high byte
00C145  2  20 DF B8     	JSR	LAB_UFAC	; unpack memory (AY) into FAC1
00C148  2  C6 AC        	DEC	FAC1_e		; make result = PI
00C14A  2  60           	RTS
00C14B  2               
00C14B  2               ; perform TWOPI
00C14B  2               
00C14B  2               LAB_TWOPI
00C14B  2  A9 28        	LDA	#<LAB_2C7C	; set (2*pi) pointer low byte
00C14D  2  A0 C2        	LDY	#>LAB_2C7C	; set (2*pi) pointer high byte
00C14F  2  4C DF B8     	JMP	LAB_UFAC	; unpack memory (AY) into FAC1 and return
00C152  2               
00C152  2               ; system dependant I/O vectors
00C152  2               ; these are in RAM and are set by the monitor at start-up
00C152  2  6C 06 02     V_INPT	JMP	(VEC_IN)	; non-halting scan input device
00C155  2  6C 08 02     V_OUTP	JMP	(VEC_OUT)	; send byte to output device
00C158  2  6C 0A 02     V_LOAD	JMP	(VEC_LD)	; load BASIC program
00C15B  2  6C 0C 02     V_SAVE	JMP	(VEC_SV)	; save BASIC program
00C15E  2               
00C15E  2               
00C15E  2               ; The rest are tables messages and code for RAM
00C15E  2               ; Initialised on startup, can be overwritten by MON_INIT
00C15E  2               PG2_TABS
00C15E  2  00           	.byte	$00		; ctrl-c flag		-	$00 = enabled
00C15F  2  00           	.byte	$00		; ctrl-c byte		-	GET needs this
00C160  2  00           	.byte	$00		; ctrl-c byte timeout	-	GET needs this
00C161  2  00           	.byte	$00		; spare byte, aligns to even
00C162  2  10 BF        	.word	CTRLC		; ctrl c check vector	-	monitor may set this
00C164  2               ;	.word	xxxx		; non halting key input	-	monitor must set this
00C164  2               ;	.word	xxxx		; output vector		-	monitor must set this
00C164  2               ;	.word	xxxx		; load vector		-	monitor must set this
00C164  2               ;	.word	xxxx		; save vector		-	monitor must set this
00C164  2               ;	.word	xxxx		; spare vector
00C164  2               PG2_TABE
00C164  2               
00C164  2               ; character get subroutine for zero page
00C164  2               ; LAB_IGBY: step though memory to get next byte, skipping spaces
00C164  2               ; LAB_GBYT: get current byte, skipping spaces
00C164  2               ; callers expect X,Y to be preserved
00C164  2               ; returns A=char, EQ=ELSE or : or [NUL], CC=digit, CS=not digit
00C164  2               ; corrupts TempB
00C164  2               ; This could be optimised by ensuring all calls allow Y to be corrupted or Y=0
00C164  2               ; Looks like DIM and IF are the only callers that use Y
00C164  2               
00C164  2               ; For a 1.8432MHz 6502 including the JSR and RTS
00C164  2               ; fastest (>=":")	=  29 cycles =  15.7uS
00C164  2               ; slowest (<":")	=  40 cycles =  21.7uS
00C164  2               ; space skip	= +21 cycles = +11.4uS
00C164  2               ; inc across page	=  +4 cycles =  +2.2uS
00C164  2               
00C164  2               ; the target address for the LDA at LAB_2CF4 becomes the BASIC execute pointer once the
00C164  2               ; block is copied to its destination, any non-zero page address will do at assembly
00C164  2               ; time, to assemble a three byte instruction.
00C164  2               
00C164  2               ; page 0 initialisation table from $BC
00C164  2               ; increment and scan memory
00C164  2               
00C164  2               .if ZPROUT=0
00C164  2               LAB_IGBY			; don't put in zero page, don't self-modify
00C164  2               .endif
00C164  2               
00C164  2               LAB_2CEE
00C164  2  E6 C3        	INC	Bpntrl		; increment BASIC execute pointer low byte
00C166  2  D0 02        	BNE	LAB_2CF4	; branch if no carry
00C168  2               				; else
00C168  2  E6 C4        	INC	Bpntrh		; increment BASIC execute pointer high byte
00C16A  2               
00C16A  2               ; code copied to page 0 from $C2
00C16A  2               
00C16A  2               LAB_2CF4
00C16A  2               .if ZPROUT
00C16A  2  AD FF FF     	LDA	$FFFF		; get byte to scan (addr set by call routine)
00C16D  2               .else
00C16D  2               LAB_GBYT
00C16D  2               	STY	TempB
00C16D  2               	LDY	#0
00C16D  2               	LDA	(Bpntrl),Y
00C16D  2               	LDY	TempB
00C16D  2               .endif
00C16D  2  C9 C3        	CMP	#TK_ELSE	; compare with the token for ELSE
00C16F  2  F0 0E        	BEQ	LAB_2D05	; exit if ELSE, not numeric, carry set
00C171  2               
00C171  2  C9 3A        	CMP	#':'		; compare with ":"
00C173  2  B0 0A        	BCS	LAB_2D05	; exit if >= ":", not numeric, carry set
00C175  2               
00C175  2  C9 20        	CMP	#' '		; compare with " "
00C177  2  F0 EB        	BEQ	LAB_2CEE	; if " " get next
00C179  2               
00C179  2  38           	SEC			; set carry for SBC
00C17A  2  E9 30        	SBC	#'0'		; subtract "0"
00C17C  2  38           	SEC			; set carry for SBC
00C17D  2  E9 D0        	SBC	#$D0		; subtract -"0"
00C17F  2               				; clear carry if byte = "0"-"9"
00C17F  2               LAB_2D05
00C17F  2  60           	RTS
00C180  2               
00C180  2               ; page zero initialisation table $00-$12 inclusive
00C180  2               
00C180  2               StrTab
00C180  2               .if (ZPWARM <> $02)
00C180  2  4C           	.byte	$4C		; JMP opcode
00C181  2  03 A0        	.word	LAB_COLD	; initial warm start vector (cold start)
00C183  2               .else
00C183  2               	.byte	$00		; drop two bytes if 6510 target, I/O port at 0000/0001
00C183  2               .endif
00C183  2  4C           	.byte	$4C		; JMP opcode
00C184  2  03 A0        	.word	LAB_COLD	; initial warm start vector (cold start)
00C186  2  00 00        	.word	$0000		;
00C188  2  00 00        	.word	$0000		;
00C18A  2  4C           	.byte	$4C		; JMP opcode
00C18B  2  D2 B5        	.word	LAB_USRVC	; initial user function vector, calls (FAC1)
00C18D  2  00           	.byte	$00		; default NULL count
00C18E  2  00           	.byte	$00		; clear terminal position
00C18F  2  00           	.byte	$00		; default terminal width byte
00C190  2  F2           	.byte	$F2		; default limit for TAB = 14
00C191  2  00 03        	.word	Ram_base	; start of user RAM
00C193  2               EndTab
00C193  2               
00C193  2               LAB_MSZM
00C193  2  0D 0A 4D 65  	.byte	$0D,$0A,"Memory size ",$00
00C197  2  6D 6F 72 79  
00C19B  2  20 73 69 7A  
00C1A2  2               LAB_SMSG
00C1A2  2  45 6E 68 61  	.byte	"Enhanced BASIC ",VERSION,$0D,$0A,$00
00C1A6  2  6E 63 65 64  
00C1AA  2  20 42 41 53  
00C1BB  2               LAB_FREE
00C1BB  2  20 42 79 74  	.byte	" Bytes free",$0D,$0A,$00
00C1BF  2  65 73 20 66  
00C1C3  2  72 65 65 0D  
00C1C9  2               
00C1C9  2               ; numeric constants and series
00C1C9  2               
00C1C9  2               				; constants and series for LOG(n)
00C1C9  2               LAB_25A0
00C1C9  2  02           	.byte	$02		; counter
00C1CA  2  80 19 56 62  	.byte	$80,$19,$56,$62	; 0.59898
00C1CE  2  80 76 22 F3  	.byte	$80,$76,$22,$F3	; 0.96147
00C1D2  2               ;##	.byte	$80,$76,$22,$F1	; 0.96147
00C1D2  2  82 38 AA 40  	.byte	$82,$38,$AA,$40	; 2.88539
00C1D6  2               ;##	.byte	$82,$38,$AA,$45	; 2.88539
00C1D6  2               
00C1D6  2               LAB_25AD
00C1D6  2  80 35 04 F3  	.byte	$80,$35,$04,$F3	; 0.70711	1/root 2
00C1DA  2               LAB_25B1
00C1DA  2  81 35 04 F3  	.byte	$81,$35,$04,$F3	; 1.41421	root 2
00C1DE  2               LAB_25B5
00C1DE  2  80 80 00 00  	.byte	$80,$80,$00,$00	; -0.5
00C1E2  2               LAB_25B9
00C1E2  2  80 31 72 18  	.byte	$80,$31,$72,$18	; 0.69315	LOG(2)
00C1E6  2               
00C1E6  2               				; numeric PRINT constants
00C1E6  2               LAB_2947
00C1E6  2  91 43 4F F8  	.byte	$91,$43,$4F,$F8	; 99999.9375 (max value with at least one decimal)
00C1EA  2               LAB_294B
00C1EA  2  94 74 23 F7  	.byte	$94,$74,$23,$F7	; 999999.4375 (max value before scientific notation)
00C1EE  2               LAB_294F
00C1EE  2  94 74 24 00  	.byte	$94,$74,$24,$00	; 1000000
00C1F2  2               
00C1F2  2               				; EXP(n) constants and series
00C1F2  2               LAB_2AFA
00C1F2  2  81 38 AA 3B  	.byte	$81,$38,$AA,$3B	; 1.4427	(1/LOG base 2 e)
00C1F6  2               LAB_2AFE
00C1F6  2  06           	.byte	$06		; counter
00C1F7  2  74 63 90 8C  	.byte	$74,$63,$90,$8C	; 2.17023e-4
00C1FB  2  77 23 0C AB  	.byte	$77,$23,$0C,$AB	; 0.00124
00C1FF  2  7A 1E 94 00  	.byte	$7A,$1E,$94,$00	; 0.00968
00C203  2  7C 63 42 80  	.byte	$7C,$63,$42,$80	; 0.05548
00C207  2  7E 75 FE D0  	.byte	$7E,$75,$FE,$D0	; 0.24023
00C20B  2  80 31 72 15  	.byte	$80,$31,$72,$15	; 0.69315
00C20F  2  81 00 00 00  	.byte	$81,$00,$00,$00	; 1.00000
00C213  2               
00C213  2               ;##	.byte	$07		; counter
00C213  2               ;##	.byte	$74,$94,$2E,$40	; -1/7! (-1/5040)
00C213  2               ;##	.byte	$77,$2E,$4F,$70	;  1/6! ( 1/720)
00C213  2               ;##	.byte	$7A,$88,$02,$6E	; -1/5! (-1/120)
00C213  2               ;##	.byte	$7C,$2A,$A0,$E6	;  1/4! ( 1/24)
00C213  2               ;##	.byte	$7E,$AA,$AA,$50	; -1/3! (-1/6)
00C213  2               ;##	.byte	$7F,$7F,$FF,$FF	;  1/2! ( 1/2)
00C213  2               ;##	.byte	$81,$80,$00,$00	; -1/1! (-1/1)
00C213  2               ;##	.byte	$81,$00,$00,$00	;  1/0! ( 1/1)
00C213  2               
00C213  2               				; trigonometric constants and series
00C213  2               LAB_2C78
00C213  2  81 49 0F DB  	.byte	$81,$49,$0F,$DB	; 1.570796371 (pi/2) as floating #
00C217  2               LAB_2C84
00C217  2  04           	.byte	$04		; counter
00C218  2  86 1E D7 FB  	.byte	$86,$1E,$D7,$FB	; 39.7109
00C21C  2               ;##	.byte	$86,$1E,$D7,$BA	; 39.7109
00C21C  2  87 99 26 65  	.byte	$87,$99,$26,$65	;-76.575
00C220  2               ;##	.byte	$87,$99,$26,$64	;-76.575
00C220  2  87 23 34 58  	.byte	$87,$23,$34,$58	; 81.6022
00C224  2  86 A5 5D E1  	.byte	$86,$A5,$5D,$E1	;-41.3417
00C228  2               ;##	.byte	$86,$A5,$5D,$E0	;-41.3417
00C228  2               LAB_2C7C
00C228  2  83 49 0F DB  	.byte	$83,$49,$0F,$DB	; 6.28319 (2*pi) as floating #
00C22C  2               ;##	.byte	$83,$49,$0F,$DA	; 6.28319 (2*pi) as floating #
00C22C  2               
00C22C  2               LAB_2CC9
00C22C  2  08           	.byte	$08		; counter
00C22D  2  78 3A C5 37  	.byte	$78,$3A,$C5,$37	; 0.00285
00C231  2  7B 83 A2 5C  	.byte	$7B,$83,$A2,$5C	;-0.0160686
00C235  2  7C 2E DD 4D  	.byte	$7C,$2E,$DD,$4D	; 0.0426915
00C239  2  7D 99 B0 1E  	.byte	$7D,$99,$B0,$1E	;-0.0750429
00C23D  2  7D 59 ED 24  	.byte	$7D,$59,$ED,$24	; 0.106409
00C241  2  7E 91 72 00  	.byte	$7E,$91,$72,$00	;-0.142036
00C245  2  7E 4C B9 73  	.byte	$7E,$4C,$B9,$73	; 0.199926
00C249  2  7F AA AA 53  	.byte	$7F,$AA,$AA,$53	;-0.333331
00C24D  2               
00C24D  2               ;##	.byte	$08		; counter
00C24D  2               ;##	.byte	$78,$3B,$D7,$4A	; 1/17
00C24D  2               ;##	.byte	$7B,$84,$6E,$02	;-1/15
00C24D  2               ;##	.byte	$7C,$2F,$C1,$FE	; 1/13
00C24D  2               ;##	.byte	$7D,$9A,$31,$74	;-1/11
00C24D  2               ;##	.byte	$7D,$5A,$3D,$84	; 1/9
00C24D  2               ;##	.byte	$7E,$91,$7F,$C8	;-1/7
00C24D  2               ;##	.byte	$7E,$4C,$BB,$E4	; 1/5
00C24D  2               ;##	.byte	$7F,$AA,$AA,$6C	;-1/3
00C24D  2               
00C24D  2               LAB_1D96	= *+1		; $00,$00 used for undefined variables
00C24D  2               LAB_259C
00C24D  2  81 00 00 00  	.byte	$81,$00,$00,$00	; 1.000000, used for INC
00C251  2               LAB_2AFD
00C251  2  81 80 00 00  	.byte	$81,$80,$00,$00	; -1.00000, used for DEC. must be on the same page as +1.00
00C255  2               
00C255  2               				; misc constants
00C255  2               LAB_1DF7
00C255  2  90           	.byte	$90		;-32768 (uses first three bytes from 0.5)
00C256  2               LAB_2A96
00C256  2  80 00 00 00  	.byte	$80,$00,$00,$00	; 0.5
00C25A  2               LAB_2C80
00C25A  2  7F 00 00 00  	.byte	$7F,$00,$00,$00	; 0.25
00C25E  2               LAB_26B5
00C25E  2  84 20 00 00  	.byte	$84,$20,$00,$00	; 10.0000 divide by 10 constant
00C262  2               
00C262  2               ; This table is used in converting numbers to ASCII.
00C262  2               
00C262  2               LAB_2A9A
00C262  2               LAB_2A9B = LAB_2A9A+1
00C262  2               LAB_2A9C = LAB_2A9B+1
00C262  2  FE 79 60     	.byte	$FE,$79,$60	; -100000
00C265  2  00 27 10     	.byte	$00,$27,$10	; 10000
00C268  2  FF FC 18     	.byte	$FF,$FC,$18	; -1000
00C26B  2  00 00 64     	.byte	$00,$00,$64	; 100
00C26E  2  FF FF F6     	.byte	$FF,$FF,$F6	; -10
00C271  2  00 00 01     	.byte	$00,$00,$01	; 1
00C274  2               
00C274  2               LAB_CTBL
00C274  2  67 A5        	.word	LAB_END-1	; END
00C276  2  A2 A4        	.word	LAB_FOR-1	; FOR
00C278  2  AB AA        	.word	LAB_NEXT-1	; NEXT
00C27A  2  D4 A6        	.word	LAB_DATA-1	; DATA
00C27C  2  95 A9        	.word	LAB_INPUT-1	; INPUT
00C27E  2  B4 AD        	.word	LAB_DIM-1	; DIM
00C280  2  B7 A9        	.word	LAB_READ-1	; READ
00C282  2  FF A7        	.word	LAB_LET-1	; LET
00C284  2  D1 A7        	.word	LAB_DEC-1	; DEC		new command
00C286  2  33 A6        	.word	LAB_GOTO-1	; GOTO
00C288  2  F2 A5        	.word	LAB_RUN-1	; RUN
00C28A  2  02 A7        	.word	LAB_IF-1	; IF
00C28C  2  88 A5        	.word	LAB_RESTORE-1	; RESTORE	modified command
00C28E  2  16 A6        	.word	LAB_GOSUB-1	; GOSUB
00C290  2  CC BF        	.word	LAB_RETIRQ-1	; RETIRQ	new command
00C292  2  D8 BF        	.word	LAB_RETNMI-1	; RETNMI	new command
00C294  2  BF A6        	.word	LAB_RETURN-1	; RETURN
00C296  2  69 A7        	.word	LAB_REM-1	; REM
00C298  2  65 A5        	.word	LAB_STOP-1	; STOP
00C29A  2  72 A7        	.word	LAB_ON-1	; ON		modified command
00C29C  2  C6 A5        	.word	LAB_NULL-1	; NULL		modified command
00C29E  2  D4 A7        	.word	LAB_INC-1	; INC		new command
00C2A0  2  EA B5        	.word	LAB_WAIT-1	; WAIT
00C2A2  2  57 C1        	.word	V_LOAD-1	; LOAD
00C2A4  2  5A C1        	.word	V_SAVE-1	; SAVE
00C2A6  2  CA B0        	.word	LAB_DEF-1	; DEF
00C2A8  2  5F B5        	.word	LAB_POKE-1	; POKE
00C2AA  2  7B B5        	.word	LAB_DOKE-1	; DOKE		new command
00C2AC  2  C8 B5        	.word	LAB_CALL-1	; CALL		new command
00C2AE  2  FC A5        	.word	LAB_DO-1	; DO		new command
00C2B0  2  65 A6        	.word	LAB_LOOP-1	; LOOP		new command
00C2B2  2  A4 A8        	.word	LAB_PRINT-1	; PRINT
00C2B4  2  CC A5        	.word	LAB_CONT-1	; CONT
00C2B6  2  ED A3        	.word	LAB_LIST-1	; LIST
00C2B8  2  EA A3        	.word	LAB_CLEAR-1	; CLEAR
00C2BA  2  9A A3        	.word	LAB_NEW-1	; NEW
00C2BC  2  4D C0        	.word	LAB_WDTH-1	; WIDTH		new command
00C2BE  2  73 A8        	.word	LAB_GET-1	; GET		new command
00C2C0  2  A0 B5        	.word	LAB_SWAP-1	; SWAP		new command
00C2C2  2  E7 BD        	.word	LAB_BITSET-1	; BITSET	new command
00C2C4  2  FB BD        	.word	LAB_BITCLR-1	; BITCLR	new command
00C2C6  2  7B BF        	.word	LAB_IRQ-1	; IRQ		new command
00C2C8  2  7E BF        	.word	LAB_NMI-1	; NMI		new command
00C2CA  2  EA CA        	.word	LAB_CLS-1	; CLS		new command
00C2CC  2  02 CB        	.word	LAB_MOVE-1	; MOVE		new command
00C2CE  2  11 CB        	.word	LAB_DRAW-1	; DRAW		new command
00C2D0  2  20 CB        	.word	LAB_PIXEL-1	; PIXEL		new command
00C2D2  2  7D CB        	.word	LAB_COLOR-1	; COLOR		new command
00C2D4  2  8C CB        	.word	LAB_PALETTE-1	; PALETTE	new command
00C2D6  2  F3 CA        	.word	LAB_VDU-1	; VDU new command
00C2D8  2  A3 CB        	.word   LAB_VREFRESH-1 ; REFRESH  new command
00C2DA  2  2F CB        	.word	LAB_RECT-1
00C2DC  2  4A CB        	.word   LAB_CIRCLE-1
00C2DE  2  62 CB        	.word	LAB_TRIANGLE-1
00C2E0  2  1E CD        	.word	LAB_PLAY-1
00C2E2  2  15 CD        	.word	LAB_SILENCE-1
00C2E4  2  E1 CA        	.word   LAB_SANE-1
00C2E6  2  00 CC        	.word	LAB_SPRITE-1
00C2E8  2  28 CC        	.word	LAB_SDRAW-1
00C2EA  2  8D CC        	.word	LAB_SCLEAR-1
00C2EC  2  46 CC        	.word	LAB_SMOVE-1
00C2EE  2  AC CB        	.word	LAB_SDIM-1
00C2F0  2  D2 CB        	.word   LAB_WDIM-1
00C2F2  2  27 CC        	.word	LAB_CSPRITE-1
00C2F4  2  DF CC        	.word   LAB_VTILE-1
00C2F6  2  B6 CC        	.word	LAB_VTDIM-1
00C2F8  2               
00C2F8  2               ; function preprocess routine table
00C2F8  2               
00C2F8  2               LAB_FTPL
00C2F8  2               LAB_FTPM	= LAB_FTPL+$01
00C2F8  2  BA AC        	.word	LAB_PPFN-1	; SGN(n)	process numeric expression in ()
00C2FA  2  BA AC        	.word	LAB_PPFN-1	; INT(n)		"
00C2FC  2  BA AC        	.word	LAB_PPFN-1	; ABS(n)		"
00C2FE  2  2F AB        	.word	LAB_EVEZ-1	; USR(x)	process any expression
00C300  2  33 AC        	.word	LAB_1BF7-1	; FRE(x)		"
00C302  2  33 AC        	.word	LAB_1BF7-1	; POS(x)		"
00C304  2  BA AC        	.word	LAB_PPFN-1	; SQR(n)	process numeric expression in ()
00C306  2  BA AC        	.word	LAB_PPFN-1	; RND(n)		"
00C308  2  BA AC        	.word	LAB_PPFN-1	; LOG(n)		"
00C30A  2  BA AC        	.word	LAB_PPFN-1	; EXP(n)		"
00C30C  2  BA AC        	.word	LAB_PPFN-1	; COS(n)		"
00C30E  2  BA AC        	.word	LAB_PPFN-1	; SIN(n)		"
00C310  2  BA AC        	.word	LAB_PPFN-1	; TAN(n)		"
00C312  2  BA AC        	.word	LAB_PPFN-1	; ATN(n)		"
00C314  2  BA AC        	.word	LAB_PPFN-1	; PEEK(n)		"
00C316  2  BA AC        	.word	LAB_PPFN-1	; DEEK(n)		"
00C318  2  00 00        	.word	$0000		; SADD()	none
00C31A  2  B4 AC        	.word	LAB_PPFS-1	; LEN($)	process string expression in ()
00C31C  2  BA AC        	.word	LAB_PPFN-1	; STR$(n)	process numeric expression in ()
00C31E  2  B4 AC        	.word	LAB_PPFS-1	; VAL($)	process string expression in ()
00C320  2  B4 AC        	.word	LAB_PPFS-1	; ASC($)		"
00C322  2  B4 AC        	.word	LAB_PPFS-1	; UCASE$($)		"
00C324  2  B4 AC        	.word	LAB_PPFS-1	; LCASE$($)		"
00C326  2  BA AC        	.word	LAB_PPFN-1	; CHR$(n)	process numeric expression in ()
00C328  2  E1 AC        	.word	LAB_BHSS-1	; HEX$(n)		"
00C32A  2  E1 AC        	.word	LAB_BHSS-1	; BIN$(n)		"
00C32C  2  00 00        	.word	$0000		; BITTST()	none
00C32E  2  E4 BF        	.word	LAB_MMPP-1	; MAX()		process numeric expression
00C330  2  E4 BF        	.word	LAB_MMPP-1	; MIN()			"
00C332  2  C0 AC        	.word	LAB_PPBI-1	; PI		advance pointer
00C334  2  C0 AC        	.word	LAB_PPBI-1	; TWOPI			"
00C336  2  00 00        	.word	$0000		; VARPTR()	none
00C338  2  C5 AC        	.word	LAB_LRMS-1	; LEFT$()	process string expression
00C33A  2  C5 AC        	.word	LAB_LRMS-1	; RIGHT$()		"
00C33C  2  C5 AC        	.word	LAB_LRMS-1	; MID$()		"
00C33E  2  BA AC        	.word	LAB_PPFN-1	; COLLISION()	none
00C340  2               
00C340  2               ; action addresses for functions
00C340  2               
00C340  2               LAB_FTBL
00C340  2               LAB_FTBM	= LAB_FTBL+$01
00C340  2  58 B9        	.word	LAB_SGN-1	; SGN()
00C342  2  E2 B9        	.word	LAB_INT-1	; INT()
00C344  2  75 B9        	.word	LAB_ABS-1	; ABS()
00C346  2  AF BD        	.word	LAB_USR-1	; USR()
00C348  2  9A B0        	.word	LAB_FRE-1	; FRE()
00C34A  2  BA B0        	.word	LAB_POS-1	; POS()
00C34C  2  A3 C0        	.word	LAB_SQR-1	; SQR()
00C34E  2  FF BC        	.word	LAB_RND-1	; RND()		modified function
00C350  2  5C B7        	.word	LAB_LOG-1	; LOG()
00C352  2  61 BC        	.word	LAB_EXP-1	; EXP()
00C354  2  33 BD        	.word	LAB_COS-1	; COS()
00C356  2  3A BD        	.word	LAB_SIN-1	; SIN()
00C358  2  83 BD        	.word	LAB_TAN-1	; TAN()
00C35A  2  B8 BD        	.word	LAB_ATN-1	; ATN()
00C35C  2  54 B5        	.word	LAB_PEEK-1	; PEEK()
00C35E  2  68 B5        	.word	LAB_DEEK-1	; DEEK()	new function
00C360  2  AD B4        	.word	LAB_SADD-1	; SADD()	new function
00C362  2  C6 B4        	.word	LAB_LENS-1	; LEN()
00C364  2  7C B1        	.word	LAB_STRS-1	; STR$()
00C366  2  F3 B4        	.word	LAB_VAL-1	; VAL()
00C368  2  D1 B4        	.word	LAB_ASC-1	; ASC()
00C36A  2  8B B4        	.word	LAB_UCASE-1	; UCASE$()	new function
00C36C  2  6A B4        	.word	LAB_LCASE-1	; LCASE$()	new function
00C36E  2  DC B3        	.word	LAB_CHRS-1	; CHR$()
00C370  2  88 BE        	.word	LAB_HEXS-1	; HEX$()	new function
00C372  2  39 BE        	.word	LAB_BINS-1	; BIN$()	new function
00C374  2  11 BE        	.word	LAB_BTST-1	; BITTST()	new function
00C376  2  EA BF        	.word	LAB_MAX-1	; MAX()		new function
00C378  2  FA BF        	.word	LAB_MIN-1	; MIN()		new function
00C37A  2  40 C1        	.word	LAB_PI-1	; PI		new function
00C37C  2  4A C1        	.word	LAB_TWOPI-1	; TWOPI		new function
00C37E  2  30 C1        	.word	LAB_VARPTR-1	; VARPTR()	new function
00C380  2  EE B3        	.word	LAB_LEFT-1	; LEFT$()
00C382  2  F7 B3        	.word	LAB_RIGHT-1	; RIGHT$()
00C384  2  26 B4        	.word	LAB_MIDS-1	; MID$()
00C386  2  8E CC        	.word	LAB_COLLISION-1 ; COLLISION()
00C388  2               
00C388  2               ; hierarchy and action addresses for operator
00C388  2               
00C388  2               LAB_OPPT
00C388  2  79           	.byte	$79		; +
00C389  2  22 B6        	.word	LAB_ADD-1
00C38B  2  79           	.byte	$79		; -
00C38C  2  07 B6        	.word	LAB_SUBTRACT-1
00C38E  2  7B           	.byte	$7B		; *
00C38F  2  9D B7        	.word	LAB_MULTIPLY-1
00C391  2  7B           	.byte	$7B		; /
00C392  2  65 B8        	.word	LAB_DIVIDE-1
00C394  2  7F           	.byte	$7F		; ^
00C395  2  1D BC        	.word	LAB_POWER-1
00C397  2  50           	.byte	$50		; AND
00C398  2  2A AD        	.word	LAB_AND-1
00C39A  2  46           	.byte	$46		; EOR		new operator
00C39B  2  10 AD        	.word	LAB_EOR-1
00C39D  2  46           	.byte	$46		; OR
00C39E  2  1D AD        	.word	LAB_OR-1
00C3A0  2  56           	.byte	$56		; >>		new operator
00C3A1  2  D6 AD        	.word	LAB_RSHIFT-1
00C3A3  2  56           	.byte	$56		; <<		new operator
00C3A4  2  BE AD        	.word	LAB_LSHIFT-1
00C3A6  2  7D           	.byte	$7D		; >
00C3A7  2  56 BC        	.word	LAB_GTHAN-1
00C3A9  2  5A           	.byte	$5A		; =
00C3AA  2  5E AC        	.word	LAB_EQUAL-1
00C3AC  2  64           	.byte	$64		; <
00C3AD  2  4B AD        	.word	LAB_LTHAN-1
00C3AF  2               
00C3AF  2               ; keywords start with ..
00C3AF  2               ; this is the first character table and must be in alphabetic order
00C3AF  2               
00C3AF  2               TAB_1STC
00C3AF  2  2A           	.byte	"*"
00C3B0  2  2B           	.byte	"+"
00C3B1  2  2D           	.byte	"-"
00C3B2  2  2F           	.byte	"/"
00C3B3  2  3C           	.byte	"<"
00C3B4  2  3D           	.byte	"="
00C3B5  2  3E           	.byte	">"
00C3B6  2  3F           	.byte	"?"
00C3B7  2  41           	.byte	"A"
00C3B8  2  42           	.byte	"B"
00C3B9  2  43           	.byte	"C"
00C3BA  2  44           	.byte	"D"
00C3BB  2  45           	.byte	"E"
00C3BC  2  46           	.byte	"F"
00C3BD  2  47           	.byte	"G"
00C3BE  2  48           	.byte	"H"
00C3BF  2  49           	.byte	"I"
00C3C0  2  4C           	.byte	"L"
00C3C1  2  4D           	.byte	"M"
00C3C2  2  4E           	.byte	"N"
00C3C3  2  4F           	.byte	"O"
00C3C4  2  50           	.byte	"P"
00C3C5  2  52           	.byte	"R"
00C3C6  2  53           	.byte	"S"
00C3C7  2  54           	.byte	"T"
00C3C8  2  55           	.byte	"U"
00C3C9  2  56           	.byte	"V"
00C3CA  2  57           	.byte	"W"
00C3CB  2  5E           	.byte	"^"
00C3CC  2  00           	.byte	$00		; table terminator
00C3CD  2               
00C3CD  2               ; pointers to keyword tables
00C3CD  2               
00C3CD  2               TAB_CHRT
00C3CD  2  07 C4        	.word	TAB_STAR	; table for "*"
00C3CF  2  09 C4        	.word	TAB_PLUS	; table for "+"
00C3D1  2  0B C4        	.word	TAB_MNUS	; table for "-"
00C3D3  2  0D C4        	.word	TAB_SLAS	; table for "/"
00C3D5  2  0F C4        	.word	TAB_LESS	; table for "<"
00C3D7  2  13 C4        	.word	TAB_EQUL	; table for "="
00C3D9  2  15 C4        	.word	TAB_MORE	; table for ">"
00C3DB  2  19 C4        	.word	TAB_QEST	; table for "?"
00C3DD  2  1B C4        	.word	TAB_ASCA	; table for "A"
00C3DF  2  2B C4        	.word	TAB_ASCB	; table for "B"
00C3E1  2  44 C4        	.word	TAB_ASCC	; table for "C"
00C3E3  2  7A C4        	.word	TAB_ASCD	; table for "D"
00C3E5  2  97 C4        	.word	TAB_ASCE	; table for "E"
00C3E7  2  A6 C4        	.word	TAB_ASCF	; table for "F"
00C3E9  2  B0 C4        	.word	TAB_ASCG	; table for "G"
00C3EB  2  BD C4        	.word	TAB_ASCH	; table for "H"
00C3ED  2  C3 C4        	.word	TAB_ASCI	; table for "I"
00C3EF  2  D5 C4        	.word	TAB_ASCL	; table for "L"
00C3F1  2  FA C4        	.word	TAB_ASCM	; table for "M"
00C3F3  2  0C C5        	.word	TAB_ASCN	; table for "N"
00C3F5  2  1E C5        	.word	TAB_ASCO	; table for "O"
00C3F7  2  26 C5        	.word	TAB_ASCP	; table for "P"
00C3F9  2  4B C5        	.word	TAB_ASCR	; table for "R"
00C3FB  2  85 C5        	.word	TAB_ASCS	; table for "S"
00C3FD  2  D5 C5        	.word	TAB_ASCT	; table for "T"
00C3FF  2  F9 C5        	.word	TAB_ASCU	; table for "U"
00C401  2  0A C6        	.word	TAB_ASCV	; table for "V"
00C403  2  19 C6        	.word	TAB_ASCW	; table for "W"
00C405  2  2C C6        	.word	TAB_POWR	; table for "^"
00C407  2               
00C407  2               ; tables for each start character, note if a longer keyword with the same start
00C407  2               ; letters as a shorter one exists then it must come first, else the list is in
00C407  2               ; alphabetical order as follows ..
00C407  2               
00C407  2               ; [keyword,token
00C407  2               ; [keyword,token]]
00C407  2               ; end marker (#$00)
00C407  2               
00C407  2               TAB_STAR
00C407  2  CF 00        	.byte TK_MUL,$00			; *
00C409  2               TAB_PLUS
00C409  2  CD 00        	.byte TK_PLUS,$00			; +
00C40B  2               TAB_MNUS
00C40B  2  CE 00        	.byte TK_MINUS,$00			; -
00C40D  2               TAB_SLAS
00C40D  2  D0 00        	.byte TK_DIV,$00			; /
00C40F  2               TAB_LESS
00C40F  2               LBB_LSHIFT
00C40F  2  3C D6        	.byte	"<",TK_LSHIFT		; <<	note - "<<" must come before "<"
00C411  2  D9           	.byte TK_LT					; <
00C412  2  00           	.byte	$00
00C413  2               TAB_EQUL
00C413  2  D8 00        	.byte TK_EQUAL,$00			; =
00C415  2               TAB_MORE
00C415  2               LBB_RSHIFT
00C415  2  3E D5        	.byte	">",TK_RSHIFT		; >>	note - ">>" must come before ">"
00C417  2  D7           	.byte TK_GT					; >
00C418  2  00           	.byte	$00
00C419  2               TAB_QEST
00C419  2  9F 00        	.byte TK_PRINT,$00			; ?
00C41B  2               TAB_ASCA
00C41B  2               LBB_ABS
00C41B  2  42 53 28 DC  	.byte	"BS(",TK_ABS		; ABS(
00C41F  2               LBB_AND
00C41F  2  4E 44 D2     	.byte	"ND",TK_AND			; AND
00C422  2               LBB_ASC
00C422  2  53 43 28 EE  	.byte	"SC(",TK_ASC		; ASC(
00C426  2               LBB_ATN
00C426  2  54 4E 28 E7  	.byte	"TN(",TK_ATN		; ATN(
00C42A  2  00           	.byte	$00
00C42B  2               TAB_ASCB
00C42B  2               LBB_BINS
00C42B  2  49 4E 24 28  	.byte	"IN$(",TK_BINS		; BIN$(
00C42F  2  F3           
00C430  2               LBB_BITCLR
00C430  2  49 54 43 4C  	.byte	"ITCLR",TK_BITCLR	; BITCLR
00C434  2  52 A8        
00C436  2               LBB_BITSET
00C436  2  49 54 53 45  	.byte	"ITSET",TK_BITSET	; BITSET
00C43A  2  54 A7        
00C43C  2               LBB_BITTST
00C43C  2  49 54 54 53  	.byte	"ITTST(",TK_BITTST	; BITTST(
00C440  2  54 28 F4     
00C443  2  00           	.byte	$00
00C444  2               TAB_ASCC
00C444  2               LBB_CALL
00C444  2  41 4C 4C 9C  	.byte	"ALL",TK_CALL		; CALL
00C448  2               LBB_CHRS
00C448  2  48 52 24 28  	.byte	"HR$(",TK_CHRS		; CHR$(
00C44C  2  F1           
00C44D  2               LBB_VCIRCLE
00C44D  2  49 52 43 4C  	.byte	"IRCLE",TK_CIRCLE	; CIRCLE
00C451  2  45 B4        
00C453  2               LBB_CLEAR
00C453  2  4C 45 41 52  	.byte	"LEAR",TK_CLEAR		; CLEAR
00C457  2  A2           
00C458  2               LBB_VCLS
00C458  2  4C 53 AB     	.byte	"LS",TK_CLS			; CLS
00C45B  2               LBB_VCOLLISION
00C45B  2  4F 4C 4C 49  	.byte	"OLLISION(",TK_COLLISION	; COLLISION
00C45F  2  53 49 4F 4E  
00C463  2  28 FD        
00C465  2               LBB_VCOLOR
00C465  2  4F 4C 4F 52  	.byte	"OLOR",TK_COLOR		; COLOR
00C469  2  AF           
00C46A  2               LBB_CONT
00C46A  2  4F 4E 54 A0  	.byte	"ONT",TK_CONT		; CONT
00C46E  2               LBB_COS
00C46E  2  4F 53 28 E4  	.byte	"OS(",TK_COS		; COS(
00C472  2               LBB_VCSPRITE
00C472  2  53 50 52 49  	.byte	"SPRITE",TK_CSPRITE	; CSPRITE
00C476  2  54 45 BF     
00C479  2  00           	.byte	$00
00C47A  2               TAB_ASCD
00C47A  2               LBB_DATA
00C47A  2  41 54 41 83  	.byte	"ATA",TK_DATA		; DATA
00C47E  2               LBB_DEC
00C47E  2  45 43 88     	.byte	"EC",TK_DEC			; DEC
00C481  2               LBB_DEEK
00C481  2  45 45 4B 28  	.byte	"EEK(",TK_DEEK		; DEEK(
00C485  2  E9           
00C486  2               LBB_DEF
00C486  2  45 46 99     	.byte	"EF",TK_DEF			; DEF
00C489  2               LBB_DIM
00C489  2  49 4D 85     	.byte	"IM",TK_DIM			; DIM
00C48C  2               LBB_DOKE
00C48C  2  4F 4B 45 9B  	.byte	"OKE",TK_DOKE		; DOKE note - "DOKE" must come before "DO"
00C490  2               LBB_DO
00C490  2  4F 9D        	.byte	"O",TK_DO			; DO
00C492  2               LBB_VDRAW
00C492  2  52 41 57 AD  	.byte	"RAW",TK_DRAW		; DRAW
00C496  2  00           	.byte	$00
00C497  2               TAB_ASCE
00C497  2               LBB_ELSE
00C497  2  4C 53 45 C3  	.byte	"LSE",TK_ELSE		; ELSE
00C49B  2               LBB_END
00C49B  2  4E 44 80     	.byte	"ND",TK_END			; END
00C49E  2               LBB_EOR
00C49E  2  4F 52 D3     	.byte	"OR",TK_EOR			; EOR
00C4A1  2               LBB_EXP
00C4A1  2  58 50 28 E3  	.byte	"XP(",TK_EXP		; EXP(
00C4A5  2  00           	.byte	$00
00C4A6  2               TAB_ASCF
00C4A6  2               LBB_FN
00C4A6  2  4E C5        	.byte	"N",TK_FN			; FN
00C4A8  2               LBB_FOR
00C4A8  2  4F 52 81     	.byte	"OR",TK_FOR			; FOR
00C4AB  2               LBB_FRE
00C4AB  2  52 45 28 DE  	.byte	"RE(",TK_FRE		; FRE(
00C4AF  2  00           	.byte	$00
00C4B0  2               TAB_ASCG
00C4B0  2               LBB_GET
00C4B0  2  45 54 A5     	.byte	"ET",TK_GET			; GET
00C4B3  2               LBB_GOSUB
00C4B3  2  4F 53 55 42  	.byte	"OSUB",TK_GOSUB		; GOSUB
00C4B7  2  8D           
00C4B8  2               LBB_GOTO
00C4B8  2  4F 54 4F 89  	.byte	"OTO",TK_GOTO		; GOTO
00C4BC  2  00           	.byte	$00
00C4BD  2               TAB_ASCH
00C4BD  2               LBB_HEXS
00C4BD  2  45 58 24 28  	.byte	"EX$(",TK_HEXS		; HEX$(
00C4C1  2  F2           
00C4C2  2  00           	.byte	$00
00C4C3  2               TAB_ASCI
00C4C3  2               LBB_IF
00C4C3  2  46 8B        	.byte	"F",TK_IF			; IF
00C4C5  2               LBB_INC
00C4C5  2  4E 43 95     	.byte	"NC",TK_INC			; INC
00C4C8  2               LBB_INPUT
00C4C8  2  4E 50 55 54  	.byte	"NPUT",TK_INPUT		; INPUT
00C4CC  2  84           
00C4CD  2               LBB_INT
00C4CD  2  4E 54 28 DB  	.byte	"NT(",TK_INT		; INT(
00C4D1  2               LBB_IRQ
00C4D1  2  52 51 A9     	.byte	"RQ",TK_IRQ			; IRQ
00C4D4  2  00           	.byte	$00
00C4D5  2               TAB_ASCL
00C4D5  2               LBB_LCASES
00C4D5  2  43 41 53 45  	.byte	"CASE$(",TK_LCASES
00C4D9  2  24 28 F0     
00C4DC  2               					; LCASE$(
00C4DC  2               LBB_LEFTS
00C4DC  2  45 46 54 24  	.byte	"EFT$(",TK_LEFTS	; LEFT$(
00C4E0  2  28 FA        
00C4E2  2               LBB_LEN
00C4E2  2  45 4E 28 EB  	.byte	"EN(",TK_LEN		; LEN(
00C4E6  2               LBB_LET
00C4E6  2  45 54 87     	.byte	"ET",TK_LET			; LET
00C4E9  2               LBB_LIST
00C4E9  2  49 53 54 A1  	.byte	"IST",TK_LIST		; LIST
00C4ED  2               LBB_LOAD
00C4ED  2  4F 41 44 97  	.byte	"OAD",TK_LOAD		; LOAD
00C4F1  2               LBB_LOG
00C4F1  2  4F 47 28 E2  	.byte	"OG(",TK_LOG		; LOG(
00C4F5  2               LBB_LOOP
00C4F5  2  4F 4F 50 9E  	.byte	"OOP",TK_LOOP		; LOOP
00C4F9  2  00           	.byte	$00
00C4FA  2               TAB_ASCM
00C4FA  2               LBB_MAX
00C4FA  2  41 58 28 F5  	.byte	"AX(",TK_MAX		; MAX(
00C4FE  2               LBB_MIDS
00C4FE  2  49 44 24 28  	.byte	"ID$(",TK_MIDS		; MID$(
00C502  2  FC           
00C503  2               LBB_MIN
00C503  2  49 4E 28 F6  	.byte	"IN(",TK_MIN		; MIN(
00C507  2               LBB_VMOVE
00C507  2  4F 56 45 AC  	.byte	"OVE",TK_MOVE		; MOVE
00C50B  2  00           	.byte	$00
00C50C  2               TAB_ASCN
00C50C  2               LBB_NEW
00C50C  2  45 57 A3     	.byte	"EW",TK_NEW			; NEW
00C50F  2               LBB_NEXT
00C50F  2  45 58 54 82  	.byte	"EXT",TK_NEXT		; NEXT
00C513  2               LBB_NMI
00C513  2  4D 49 AA     	.byte	"MI",TK_NMI			; NMI
00C516  2               LBB_NOT
00C516  2  4F 54 C8     	.byte	"OT",TK_NOT			; NOT
00C519  2               LBB_NULL
00C519  2  55 4C 4C 94  	.byte	"ULL",TK_NULL		; NULL
00C51D  2  00           	.byte	$00
00C51E  2               TAB_ASCO
00C51E  2               LBB_OFF
00C51E  2  46 46 CC     	.byte	"FF",TK_OFF			; OFF
00C521  2               LBB_ON
00C521  2  4E 93        	.byte	"N",TK_ON			; ON
00C523  2               LBB_OR
00C523  2  52 D4        	.byte	"R",TK_OR			; OR
00C525  2  00           	.byte	$00
00C526  2               TAB_ASCP
00C526  2               LBB_VPALETTE
00C526  2  41 4C 45 54  	.byte	"ALETTE",TK_PALETTE	; PALETTE
00C52A  2  54 45 B0     
00C52D  2               LBB_PEEK
00C52D  2  45 45 4B 28  	.byte	"EEK(",TK_PEEK		; PEEK(
00C531  2  E8           
00C532  2               LBB_VPIXEL
00C532  2  49 58 45 4C  	.byte	"IXEL",TK_PIXEL		; PIXEL
00C536  2  AE           
00C537  2               LBB_PI
00C537  2  49 F7        	.byte	"I",TK_PI			; PI
00C539  2               LBB_PLAY
00C539  2  4C 41 59 B6  	.byte	"LAY",TK_PLAY		; PLAY
00C53D  2               LBB_POKE
00C53D  2  4F 4B 45 9A  	.byte	"OKE",TK_POKE		; POKE
00C541  2               LBB_POS
00C541  2  4F 53 28 DF  	.byte	"OS(",TK_POS		; POS(
00C545  2               LBB_PRINT
00C545  2  52 49 4E 54  	.byte	"RINT",TK_PRINT		; PRINT
00C549  2  9F           
00C54A  2  00           	.byte	$00
00C54B  2               TAB_ASCR
00C54B  2               LBB_READ
00C54B  2  45 41 44 86  	.byte	"EAD",TK_READ		; READ
00C54F  2               LBB_VRECT
00C54F  2  45 43 54 B3  	.byte	"ECT",TK_RECT		; RECT
00C553  2               LBB_VREFRESH
00C553  2  45 46 52 45  	.byte	"EFRESH",TK_REFRESH	; REFRESH
00C557  2  53 48 B2     
00C55A  2               LBB_REM
00C55A  2  45 4D 91     	.byte	"EM",TK_REM			; REM
00C55D  2               LBB_RESTORE
00C55D  2  45 53 54 4F  	.byte	"ESTORE",TK_RESTORE
00C561  2  52 45 8C     
00C564  2               					; RESTORE
00C564  2               LBB_RETIRQ
00C564  2  45 54 49 52  	.byte	"ETIRQ",TK_RETIRQ	; RETIRQ
00C568  2  51 8E        
00C56A  2               LBB_RETNMI
00C56A  2  45 54 4E 4D  	.byte	"ETNMI",TK_RETNMI	; RETNMI
00C56E  2  49 8F        
00C570  2               LBB_RETURN
00C570  2  45 54 55 52  	.byte	"ETURN",TK_RETURN	; RETURN
00C574  2  4E 90        
00C576  2               LBB_RIGHTS
00C576  2  49 47 48 54  	.byte	"IGHT$(",TK_RIGHTS
00C57A  2  24 28 FB     
00C57D  2               					; RIGHT$(
00C57D  2               LBB_RND
00C57D  2  4E 44 28 E1  	.byte	"ND(",TK_RND		; RND(
00C581  2               LBB_RUN
00C581  2  55 4E 8A     	.byte	"UN",TK_RUN			; RUN
00C584  2  00           	.byte	$00
00C585  2               TAB_ASCS
00C585  2               LBB_SADD
00C585  2  41 44 44 28  	.byte	"ADD(",TK_SADD		; SADD(
00C589  2  EA           
00C58A  2               LBB_VSANE
00C58A  2  41 4E 45 B8  	.byte	"ANE",TK_SANE		; SANE
00C58E  2               LBB_SAVE
00C58E  2  41 56 45 98  	.byte	"AVE",TK_SAVE		; SAVE
00C592  2               LBB_SGN
00C592  2  47 4E 28 DA  	.byte	"GN(",TK_SGN		; SGN(
00C596  2               LBB_SILENCE
00C596  2  49 4C 45 4E  	.byte	"ILENCE",TK_SILENCE	; SILENCE
00C59A  2  43 45 B7     
00C59D  2               LBB_SIN
00C59D  2  49 4E 28 E5  	.byte	"IN(",TK_SIN		; SIN(
00C5A1  2               LBB_SPC
00C5A1  2  50 43 28 C6  	.byte	"PC(",TK_SPC		; SPC(
00C5A5  2               LBB_VSCLEAR
00C5A5  2  43 4C 45 41  	.byte	"CLEAR",TK_SCLEAR	; SCLEAR
00C5A9  2  52 BB        
00C5AB  2               LBB_VSDIM
00C5AB  2  44 49 4D BD  	.byte	"DIM",TK_SDIM		; SDIM
00C5AF  2               LBB_VSDRAW
00C5AF  2  44 52 41 57  	.byte	"DRAW",TK_SDRAW		; SDRAW
00C5B3  2  BA           
00C5B4  2               LBB_VSMOVE
00C5B4  2  4D 4F 56 45  	.byte	"MOVE",TK_SMOVE		; SMOVE
00C5B8  2  BC           
00C5B9  2               LBB_VSPRITE
00C5B9  2  50 52 49 54  	.byte	"PRITE",TK_SPRITE	; SPRITE
00C5BD  2  45 B9        
00C5BF  2               LBB_SQR
00C5BF  2  51 52 28 E0  	.byte	"QR(",TK_SQR		; SQR(
00C5C3  2               LBB_STEP
00C5C3  2  54 45 50 C9  	.byte	"TEP",TK_STEP		; STEP
00C5C7  2               LBB_STOP
00C5C7  2  54 4F 50 92  	.byte	"TOP",TK_STOP		; STOP
00C5CB  2               LBB_STRS
00C5CB  2  54 52 24 28  	.byte	"TR$(",TK_STRS		; STR$(
00C5CF  2  EC           
00C5D0  2               LBB_SWAP
00C5D0  2  57 41 50 A6  	.byte	"WAP",TK_SWAP		; SWAP
00C5D4  2  00           	.byte	$00
00C5D5  2               TAB_ASCT
00C5D5  2               LBB_TAB
00C5D5  2  41 42 28 C2  	.byte	"AB(",TK_TAB		; TAB(
00C5D9  2               LBB_TAN
00C5D9  2  41 4E 28 E6  	.byte	"AN(",TK_TAN		; TAN(
00C5DD  2               LBB_VTDIM
00C5DD  2  44 49 4D C1  	.byte	"DIM",TK_TDIM		; TDIM
00C5E1  2               LBB_THEN
00C5E1  2  48 45 4E C7  	.byte	"HEN",TK_THEN		; THEN
00C5E5  2               LBB_VTILE
00C5E5  2  49 4C 45 C0  	.byte	"ILE",TK_TILE		; TILE
00C5E9  2               LBB_TO
00C5E9  2  4F C4        	.byte	"O",TK_TO			; TO
00C5EB  2               LBB_VTRIANGLE
00C5EB  2  52 49 41 4E  	.byte	"RIANGLE",TK_TRIANGLE	; TRIANGLE
00C5EF  2  47 4C 45 B5  
00C5F3  2               LBB_TWOPI
00C5F3  2  57 4F 50 49  	.byte	"WOPI",TK_TWOPI		; TWOPI
00C5F7  2  F8           
00C5F8  2  00           	.byte	$00
00C5F9  2               TAB_ASCU
00C5F9  2               LBB_UCASES
00C5F9  2  43 41 53 45  	.byte	"CASE$(",TK_UCASES
00C5FD  2  24 28 EF     
00C600  2               					; UCASE$(
00C600  2               LBB_UNTIL
00C600  2  4E 54 49 4C  	.byte	"NTIL",TK_UNTIL		; UNTIL
00C604  2  CA           
00C605  2               LBB_USR
00C605  2  53 52 28 DD  	.byte	"SR(",TK_USR		; USR(
00C609  2  00           	.byte	$00
00C60A  2               TAB_ASCV
00C60A  2               LBB_VAL
00C60A  2  41 4C 28 ED  	.byte	"AL(",TK_VAL		; VAL(
00C60E  2               LBB_VPTR
00C60E  2  41 52 50 54  	.byte	"ARPTR(",TK_VPTR	; VARPTR(
00C612  2  52 28 F9     
00C615  2               LBB_VVDU
00C615  2  44 55 B1     	.byte	"DU",TK_VDU			; VDU
00C618  2  00           	.byte	$00
00C619  2               TAB_ASCW
00C619  2               LBB_WAIT
00C619  2  41 49 54 96  	.byte	"AIT",TK_WAIT		; WAIT
00C61D  2               LBB_VWDIM
00C61D  2  44 49 4D BE  	.byte	"DIM",TK_WDIM		; WDIM
00C621  2               LBB_WHILE
00C621  2  48 49 4C 45  	.byte	"HILE",TK_WHILE		; WHILE
00C625  2  CB           
00C626  2               LBB_WIDTH
00C626  2  49 44 54 48  	.byte	"IDTH",TK_WIDTH		; WIDTH
00C62A  2  A4           
00C62B  2  00           	.byte	$00
00C62C  2               TAB_POWR
00C62C  2  D1 00        	.byte	TK_POWER,$00		; ^
00C62E  2               
00C62E  2               ; new decode table for LIST
00C62E  2               ; Table is ..
00C62E  2               ; byte - keyword length, keyword first character
00C62E  2               ; word - pointer to rest of keyword from dictionary
00C62E  2               
00C62E  2               ; note if length is 1 then the pointer is ignored
00C62E  2               
00C62E  2               LAB_KEYT
00C62E  2  03 45        	.byte	3,'E'
00C630  2  9B C4        	.word	LBB_END		; END
00C632  2  03 46        	.byte	3,'F'
00C634  2  A8 C4        	.word	LBB_FOR		; FOR
00C636  2  04 4E        	.byte	4,'N'
00C638  2  0F C5        	.word	LBB_NEXT	; NEXT
00C63A  2  04 44        	.byte	4,'D'
00C63C  2  7A C4        	.word	LBB_DATA	; DATA
00C63E  2  05 49        	.byte	5,'I'
00C640  2  C8 C4        	.word	LBB_INPUT	; INPUT
00C642  2  03 44        	.byte	3,'D'
00C644  2  89 C4        	.word	LBB_DIM		; DIM
00C646  2  04 52        	.byte	4,'R'
00C648  2  4B C5        	.word	LBB_READ	; READ
00C64A  2  03 4C        	.byte	3,'L'
00C64C  2  E6 C4        	.word	LBB_LET		; LET
00C64E  2  03 44        	.byte	3,'D'
00C650  2  7E C4        	.word	LBB_DEC		; DEC
00C652  2  04 47        	.byte	4,'G'
00C654  2  B8 C4        	.word	LBB_GOTO	; GOTO
00C656  2  03 52        	.byte	3,'R'
00C658  2  81 C5        	.word	LBB_RUN		; RUN
00C65A  2  02 49        	.byte	2,'I'
00C65C  2  C3 C4        	.word	LBB_IF		; IF
00C65E  2  07 52        	.byte	7,'R'
00C660  2  5D C5        	.word	LBB_RESTORE	; RESTORE
00C662  2  05 47        	.byte	5,'G'
00C664  2  B3 C4        	.word	LBB_GOSUB	; GOSUB
00C666  2  06 52        	.byte	6,'R'
00C668  2  64 C5        	.word	LBB_RETIRQ	; RETIRQ
00C66A  2  06 52        	.byte	6,'R'
00C66C  2  6A C5        	.word	LBB_RETNMI	; RETNMI
00C66E  2  06 52        	.byte	6,'R'
00C670  2  70 C5        	.word	LBB_RETURN	; RETURN
00C672  2  03 52        	.byte	3,'R'
00C674  2  5A C5        	.word	LBB_REM		; REM
00C676  2  04 53        	.byte	4,'S'
00C678  2  C7 C5        	.word	LBB_STOP	; STOP
00C67A  2  02 4F        	.byte	2,'O'
00C67C  2  21 C5        	.word	LBB_ON		; ON
00C67E  2  04 4E        	.byte	4,'N'
00C680  2  19 C5        	.word	LBB_NULL	; NULL
00C682  2  03 49        	.byte	3,'I'
00C684  2  C5 C4        	.word	LBB_INC		; INC
00C686  2  04 57        	.byte	4,'W'
00C688  2  19 C6        	.word	LBB_WAIT	; WAIT
00C68A  2  04 4C        	.byte	4,'L'
00C68C  2  ED C4        	.word	LBB_LOAD	; LOAD
00C68E  2  04 53        	.byte	4,'S'
00C690  2  8E C5        	.word	LBB_SAVE	; SAVE
00C692  2  03 44        	.byte	3,'D'
00C694  2  86 C4        	.word	LBB_DEF		; DEF
00C696  2  04 50        	.byte	4,'P'
00C698  2  3D C5        	.word	LBB_POKE	; POKE
00C69A  2  04 44        	.byte	4,'D'
00C69C  2  8C C4        	.word	LBB_DOKE	; DOKE
00C69E  2  04 43        	.byte	4,'C'
00C6A0  2  44 C4        	.word	LBB_CALL	; CALL
00C6A2  2  02 44        	.byte	2,'D'
00C6A4  2  90 C4        	.word	LBB_DO		; DO
00C6A6  2  04 4C        	.byte	4,'L'
00C6A8  2  F5 C4        	.word	LBB_LOOP	; LOOP
00C6AA  2  05 50        	.byte	5,'P'
00C6AC  2  45 C5        	.word	LBB_PRINT	; PRINT
00C6AE  2  04 43        	.byte	4,'C'
00C6B0  2  6A C4        	.word	LBB_CONT	; CONT
00C6B2  2  04 4C        	.byte	4,'L'
00C6B4  2  E9 C4        	.word	LBB_LIST	; LIST
00C6B6  2  05 43        	.byte	5,'C'
00C6B8  2  53 C4        	.word	LBB_CLEAR	; CLEAR
00C6BA  2  03 4E        	.byte	3,'N'
00C6BC  2  0C C5        	.word	LBB_NEW		; NEW
00C6BE  2  05 57        	.byte	5,'W'
00C6C0  2  26 C6        	.word	LBB_WIDTH	; WIDTH
00C6C2  2  03 47        	.byte	3,'G'
00C6C4  2  B0 C4        	.word	LBB_GET		; GET
00C6C6  2  04 53        	.byte	4,'S'
00C6C8  2  D0 C5        	.word	LBB_SWAP	; SWAP
00C6CA  2  06 42        	.byte	6,'B'
00C6CC  2  36 C4        	.word	LBB_BITSET	; BITSET
00C6CE  2  06 42        	.byte	6,'B'
00C6D0  2  30 C4        	.word	LBB_BITCLR	; BITCLR
00C6D2  2  03 49        	.byte	3,'I'
00C6D4  2  D1 C4        	.word	LBB_IRQ		; IRQ
00C6D6  2  03 4E        	.byte	3,'N'
00C6D8  2  13 C5        	.word	LBB_NMI		; NMI
00C6DA  2  03 43        	.byte	3,'C'
00C6DC  2  58 C4        	.word	LBB_VCLS	; CLS
00C6DE  2  04 4D        	.byte	4,'M'
00C6E0  2  07 C5        	.word	LBB_VMOVE	; MOVE
00C6E2  2  04 44        	.byte	4,'D'
00C6E4  2  92 C4        	.word	LBB_VDRAW	; DRAW
00C6E6  2  05 50        	.byte	5,'P'
00C6E8  2  32 C5        	.word	LBB_VPIXEL	; PIXEL
00C6EA  2  05 43        	.byte	5,'C'
00C6EC  2  65 C4        	.word	LBB_VCOLOR	; COLOR
00C6EE  2  07 50        	.byte	7,'P'
00C6F0  2  26 C5        	.word	LBB_VPALETTE ; PALETTE
00C6F2  2  03 56        	.byte	3,'V'
00C6F4  2  15 C6        	.word	LBB_VVDU  	 ; VDU
00C6F6  2  07 52        	.byte	7,'R'
00C6F8  2  53 C5        	.word	LBB_VREFRESH ; RERESH
00C6FA  2  04 52        	.byte	4,'R'
00C6FC  2  4F C5        	.word	LBB_VRECT	; RECT
00C6FE  2  06 43        	.byte	6,'C'
00C700  2  4D C4        	.word	LBB_VCIRCLE	; CIRCLE
00C702  2  08 54        	.byte	8,'T'
00C704  2  EB C5        	.word	LBB_VTRIANGLE	; TRIANGLE
00C706  2  04 50        	.byte	4,'P'
00C708  2  39 C5        	.word	LBB_PLAY	; PLAY
00C70A  2  07 53        	.byte	7,'S'
00C70C  2  96 C5        	.word	LBB_SILENCE	; SILENCE
00C70E  2  04 53        	.byte   4,'S'
00C710  2  8A C5        	.word	LBB_VSANE	; SANE
00C712  2  06 53        	.byte	6,'S'
00C714  2  B9 C5        	.word	LBB_VSPRITE	; SPRITE
00C716  2  05 53        	.byte	5,'S'
00C718  2  AF C5        	.word	LBB_VSDRAW	; SDRAW
00C71A  2  05 53        	.byte	5,'S'
00C71C  2  A5 C5        	.word	LBB_VSCLEAR	; SCLEAR
00C71E  2  05 53        	.byte	5,'S'
00C720  2  B4 C5        	.word	LBB_VSMOVE	; SMOVE
00C722  2  04 53        	.byte	4,'S'
00C724  2  AB C5        	.word	LBB_VSDIM	; SDIM
00C726  2  04 53        	.byte	4,'S'
00C728  2  1D C6        	.word	LBB_VWDIM	; WDIM
00C72A  2  07 43        	.byte	7,'C'
00C72C  2  72 C4        	.word	LBB_VCSPRITE ; CSPRITE
00C72E  2  04 54        	.byte	4,'T'
00C730  2  E5 C5        	.word	LBB_VTILE	; TILE
00C732  2  04 54        	.byte	4,'T'
00C734  2  DD C5        	.word	LBB_VTDIM	; TDIM
00C736  2               
00C736  2               ; secondary commands (can't start a statement)
00C736  2               
00C736  2  04 54        	.byte	4,'T'
00C738  2  D5 C5        	.word	LBB_TAB		; TAB
00C73A  2  04 45        	.byte	4,'E'
00C73C  2  97 C4        	.word	LBB_ELSE	; ELSE
00C73E  2  02 54        	.byte	2,'T'
00C740  2  E9 C5        	.word	LBB_TO		; TO
00C742  2  02 46        	.byte	2,'F'
00C744  2  A6 C4        	.word	LBB_FN		; FN
00C746  2  04 53        	.byte	4,'S'
00C748  2  A1 C5        	.word	LBB_SPC		; SPC
00C74A  2  04 54        	.byte	4,'T'
00C74C  2  E1 C5        	.word	LBB_THEN	; THEN
00C74E  2  03 4E        	.byte	3,'N'
00C750  2  16 C5        	.word	LBB_NOT		; NOT
00C752  2  04 53        	.byte	4,'S'
00C754  2  C3 C5        	.word	LBB_STEP	; STEP
00C756  2  05 55        	.byte	5,'U'
00C758  2  00 C6        	.word	LBB_UNTIL	; UNTIL
00C75A  2  05 57        	.byte	5,'W'
00C75C  2  21 C6        	.word	LBB_WHILE	; WHILE
00C75E  2  03 4F        	.byte	3,'O'
00C760  2  1E C5        	.word	LBB_OFF		; OFF
00C762  2               
00C762  2               ; operators
00C762  2               
00C762  2  01 2B        	.byte	1,'+'
00C764  2  00 00        	.word	$0000		; +
00C766  2  01 2D        	.byte	1,'-'
00C768  2  00 00        	.word	$0000		; -
00C76A  2  01 2A        	.byte	1,'*'
00C76C  2  00 00        	.word	$0000		; *
00C76E  2  01 2F        	.byte	1,'/'
00C770  2  00 00        	.word	$0000		; /
00C772  2  01 5E        	.byte	1,'^'
00C774  2  00 00        	.word	$0000		; ^
00C776  2  03 41        	.byte	3,'A'
00C778  2  1F C4        	.word	LBB_AND		; AND
00C77A  2  03 45        	.byte	3,'E'
00C77C  2  9E C4        	.word	LBB_EOR		; EOR
00C77E  2  02 4F        	.byte	2,'O'
00C780  2  23 C5        	.word	LBB_OR		; OR
00C782  2  02 3E        	.byte	2,'>'
00C784  2  15 C4        	.word	LBB_RSHIFT	; >>
00C786  2  02 3C        	.byte	2,'<'
00C788  2  0F C4        	.word	LBB_LSHIFT	; <<
00C78A  2  01 3E        	.byte	1,'>'
00C78C  2  00 00        	.word	$0000		; >
00C78E  2  01 3D        	.byte	1,'='
00C790  2  00 00        	.word	$0000		; =
00C792  2  01 3C        	.byte	1,'<'
00C794  2  00 00        	.word	$0000		; <
00C796  2               
00C796  2               ; functions
00C796  2               
00C796  2  04 53        	.byte	4,'S'		;
00C798  2  92 C5        	.word	LBB_SGN		; SGN
00C79A  2  04 49        	.byte	4,'I'		;
00C79C  2  CD C4        	.word	LBB_INT		; INT
00C79E  2  04 41        	.byte	4,'A'		;
00C7A0  2  1B C4        	.word	LBB_ABS		; ABS
00C7A2  2  04 55        	.byte	4,'U'		;
00C7A4  2  05 C6        	.word	LBB_USR		; USR
00C7A6  2  04 46        	.byte	4,'F'		;
00C7A8  2  AB C4        	.word	LBB_FRE		; FRE
00C7AA  2  04 50        	.byte	4,'P'		;
00C7AC  2  41 C5        	.word	LBB_POS		; POS
00C7AE  2  04 53        	.byte	4,'S'		;
00C7B0  2  BF C5        	.word	LBB_SQR		; SQR
00C7B2  2  04 52        	.byte	4,'R'		;
00C7B4  2  7D C5        	.word	LBB_RND		; RND
00C7B6  2  04 4C        	.byte	4,'L'		;
00C7B8  2  F1 C4        	.word	LBB_LOG		; LOG
00C7BA  2  04 45        	.byte	4,'E'		;
00C7BC  2  A1 C4        	.word	LBB_EXP		; EXP
00C7BE  2  04 43        	.byte	4,'C'		;
00C7C0  2  6E C4        	.word	LBB_COS		; COS
00C7C2  2  04 53        	.byte	4,'S'		;
00C7C4  2  9D C5        	.word	LBB_SIN		; SIN
00C7C6  2  04 54        	.byte	4,'T'		;
00C7C8  2  D9 C5        	.word	LBB_TAN		; TAN
00C7CA  2  04 41        	.byte	4,'A'		;
00C7CC  2  26 C4        	.word	LBB_ATN		; ATN
00C7CE  2  05 50        	.byte	5,'P'		;
00C7D0  2  2D C5        	.word	LBB_PEEK	; PEEK
00C7D2  2  05 44        	.byte	5,'D'		;
00C7D4  2  81 C4        	.word	LBB_DEEK	; DEEK
00C7D6  2  05 53        	.byte	5,'S'		;
00C7D8  2  85 C5        	.word	LBB_SADD	; SADD
00C7DA  2  04 4C        	.byte	4,'L'		;
00C7DC  2  E2 C4        	.word	LBB_LEN		; LEN
00C7DE  2  05 53        	.byte	5,'S'		;
00C7E0  2  CB C5        	.word	LBB_STRS	; STR$
00C7E2  2  04 56        	.byte	4,'V'		;
00C7E4  2  0A C6        	.word	LBB_VAL		; VAL
00C7E6  2  04 41        	.byte	4,'A'		;
00C7E8  2  22 C4        	.word	LBB_ASC		; ASC
00C7EA  2  07 55        	.byte	7,'U'		;
00C7EC  2  F9 C5        	.word	LBB_UCASES	; UCASE$
00C7EE  2  07 4C        	.byte	7,'L'		;
00C7F0  2  D5 C4        	.word	LBB_LCASES	; LCASE$
00C7F2  2  05 43        	.byte	5,'C'		;
00C7F4  2  48 C4        	.word	LBB_CHRS	; CHR$
00C7F6  2  05 48        	.byte	5,'H'		;
00C7F8  2  BD C4        	.word	LBB_HEXS	; HEX$
00C7FA  2  05 42        	.byte	5,'B'		;
00C7FC  2  2B C4        	.word	LBB_BINS	; BIN$
00C7FE  2  07 42        	.byte	7,'B'		;
00C800  2  3C C4        	.word	LBB_BITTST	; BITTST
00C802  2  04 4D        	.byte	4,'M'		;
00C804  2  FA C4        	.word	LBB_MAX		; MAX
00C806  2  04 4D        	.byte	4,'M'		;
00C808  2  03 C5        	.word	LBB_MIN		; MIN
00C80A  2  02 50        	.byte	2,'P'		;
00C80C  2  37 C5        	.word	LBB_PI		; PI
00C80E  2  05 54        	.byte	5,'T'		;
00C810  2  F3 C5        	.word	LBB_TWOPI	; TWOPI
00C812  2  07 56        	.byte	7,'V'		;
00C814  2  0E C6        	.word	LBB_VPTR	; VARPTR
00C816  2  06 4C        	.byte	6,'L'		;
00C818  2  DC C4        	.word	LBB_LEFTS	; LEFT$
00C81A  2  07 52        	.byte	7,'R'		;
00C81C  2  76 C5        	.word	LBB_RIGHTS	; RIGHT$
00C81E  2  05 4D        	.byte	5,'M'		;
00C820  2  FE C4        	.word	LBB_MIDS	; MID$
00C822  2  0A 43        	.byte	10,'C'
00C824  2  5B C4        	.word	LBB_VCOLLISION	; COLLISION
00C826  2               
00C826  2               ; BASIC messages, mostly error messages
00C826  2               
00C826  2               LAB_BAER
00C826  2  4C C8        	.word	ERR_NF		; $00 NEXT without FOR
00C828  2  5D C8        	.word	ERR_SN		; $02 syntax
00C82A  2  64 C8        	.word	ERR_RG		; $04 RETURN without GOSUB
00C82C  2  79 C8        	.word	ERR_OD		; $06 out of data
00C82E  2  85 C8        	.word	ERR_FC		; $08 function call
00C830  2  93 C8        	.word	ERR_OV		; $0A overflow
00C832  2  9C C8        	.word	ERR_OM		; $0C out of memory
00C834  2  AA C8        	.word	ERR_US		; $0E undefined statement
00C836  2  BE C8        	.word	ERR_BS		; $10 array bounds
00C838  2  CB C8        	.word	ERR_DD		; $12 double dimension array
00C83A  2  DC C8        	.word	ERR_D0		; $14 divide by 0
00C83C  2  EB C8        	.word	ERR_ID		; $16 illegal direct
00C83E  2  FA C8        	.word	ERR_TM		; $18 type mismatch
00C840  2  08 C9        	.word	ERR_LS		; $1A long string
00C842  2  18 C9        	.word	ERR_ST		; $1C string too complex
00C844  2  2B C9        	.word	ERR_CN		; $1E continue error
00C846  2  3A C9        	.word	ERR_UF		; $20 undefined function
00C848  2  4D C9        	.word	ERR_LD		; $22 LOOP without DO
00C84A  2               
00C84A  2               ; I may implement these two errors to force definition of variables and
00C84A  2               ; dimensioning of arrays before use.
00C84A  2               
00C84A  2  5D C9        	.word	ERR_UV		; $24 undefined variable
00C84C  2               ; the above error has been tested and works (see code and comments below LAB_1D8B)
00C84C  2               
00C84C  2               ;	.word	ERR_UA		; $26 undimensioned array
00C84C  2               
00C84C  2  4E 45 58 54  ERR_NF	.byte	"NEXT without FOR",$00
00C850  2  20 77 69 74  
00C854  2  68 6F 75 74  
00C85D  2  53 79 6E 74  ERR_SN	.byte	"Syntax",$00
00C861  2  61 78 00     
00C864  2  52 45 54 55  ERR_RG	.byte	"RETURN without GOSUB",$00
00C868  2  52 4E 20 77  
00C86C  2  69 74 68 6F  
00C879  2  4F 75 74 20  ERR_OD	.byte	"Out of DATA",$00
00C87D  2  6F 66 20 44  
00C881  2  41 54 41 00  
00C885  2  46 75 6E 63  ERR_FC	.byte	"Function call",$00
00C889  2  74 69 6F 6E  
00C88D  2  20 63 61 6C  
00C893  2  4F 76 65 72  ERR_OV	.byte	"Overflow",$00
00C897  2  66 6C 6F 77  
00C89B  2  00           
00C89C  2  4F 75 74 20  ERR_OM	.byte	"Out of memory",$00
00C8A0  2  6F 66 20 6D  
00C8A4  2  65 6D 6F 72  
00C8AA  2  55 6E 64 65  ERR_US	.byte	"Undefined statement",$00
00C8AE  2  66 69 6E 65  
00C8B2  2  64 20 73 74  
00C8BE  2  41 72 72 61  ERR_BS	.byte	"Array bounds",$00
00C8C2  2  79 20 62 6F  
00C8C6  2  75 6E 64 73  
00C8CB  2  44 6F 75 62  ERR_DD	.byte	"Double dimension",$00
00C8CF  2  6C 65 20 64  
00C8D3  2  69 6D 65 6E  
00C8DC  2  44 69 76 69  ERR_D0	.byte	"Divide by zero",$00
00C8E0  2  64 65 20 62  
00C8E4  2  79 20 7A 65  
00C8EB  2  49 6C 6C 65  ERR_ID	.byte	"Illegal direct",$00
00C8EF  2  67 61 6C 20  
00C8F3  2  64 69 72 65  
00C8FA  2  54 79 70 65  ERR_TM	.byte	"Type mismatch",$00
00C8FE  2  20 6D 69 73  
00C902  2  6D 61 74 63  
00C908  2  53 74 72 69  ERR_LS	.byte	"String too long",$00
00C90C  2  6E 67 20 74  
00C910  2  6F 6F 20 6C  
00C918  2  53 74 72 69  ERR_ST	.byte	"String too complex",$00
00C91C  2  6E 67 20 74  
00C920  2  6F 6F 20 63  
00C92B  2  43 61 6E 27  ERR_CN	.byte	"Can't continue",$00
00C92F  2  74 20 63 6F  
00C933  2  6E 74 69 6E  
00C93A  2  55 6E 64 65  ERR_UF	.byte	"Undefined function",$00
00C93E  2  66 69 6E 65  
00C942  2  64 20 66 75  
00C94D  2  4C 4F 4F 50  ERR_LD	.byte	"LOOP without DO",$00
00C951  2  20 77 69 74  
00C955  2  68 6F 75 74  
00C95D  2  55 6E 64 65  ERR_UV	.byte	"Undefined variable",$00
00C961  2  66 69 6E 65  
00C965  2  64 20 76 61  
00C970  2               ; the above error has been tested and works (see code and comments below LAB_1D8B)
00C970  2               
00C970  2  55 6E 64 69  ERR_UA	.byte	"Undimensioned array",$00
00C974  2  6D 65 6E 73  
00C978  2  69 6F 6E 65  
00C984  2               ; unimplemented
00C984  2               
00C984  2  0D 0A 42 72  LAB_BMSG	.byte	$0D,$0A,"Break",$00
00C988  2  65 61 6B 00  
00C98C  2  20 65 72 72  LAB_EMSG	.byte	" error",$00
00C990  2  6F 72 00     
00C993  2  20 69 6E 20  LAB_LMSG	.byte	" in line ",$00
00C997  2  6C 69 6E 65  
00C99B  2  20 00        
00C99D  2  0D 0A 52 65  LAB_RMSG	.byte	$0D,$0A,"Ready",$0D,$0A,$00
00C9A1  2  61 64 79 0D  
00C9A5  2  0A 00        
00C9A7  2               
00C9A7  2  20 45 78 74  LAB_IMSG	.byte	" Extra ignored",$0D,$0A,$00
00C9AB  2  72 61 20 69  
00C9AF  2  67 6E 6F 72  
00C9B8  2  20 52 65 64  LAB_REDO	.byte	" Redo from start",$0D,$0A,$00
00C9BC  2  6F 20 66 72  
00C9C0  2  6F 6D 20 73  
00C9CB  2               
00C9CB  2               AA_end_basic
00C9CB  2               
00C9CB  1               
00C9CB  1               ; Defines
00C9CB  1               KBD         = $D010          ; input register
00C9CB  1               DSP         = $D012          ; output register
00C9CB  1               
00C9CB  1               ; IO setup for the 2m5.de 6502 emulator environment
00C9CB  1               IO_PAGE	    = $BFF0			; set I/O area +$f0 (internal registers)
00C9CB  1               
00C9CB  1               EMU_flag	= IO_PAGE+$f	; bit 0 = 10ms tick
00C9CB  1               EMU_diag	= IO_PAGE+$c	; bit 7 = force debugger
00C9CB  1               IR_mask		= IO_PAGE+$e	; interrupt enable mask
00C9CB  1               
00C9CB  1               ; now the code. all this does is set up the vectors and interrupt code
00C9CB  1               ; and wait for the user to select [C]old or [W]arm start. nothing else
00C9CB  1               ; fits in less than 256 bytes
00C9CB  1               
00C9CB  1               ;	.org	$FE00		; pretend this is in a 1/2K ROM
00C9CB  1               
00C9CB  1               ; reset vector points here
00C9CB  1               RES_vec
00C9CB  1  D8           	CLD				; clear decimal mode
00C9CC  1  58           	CLI
00C9CD  1  A2 FF        	LDX	#$FF		; empty stack
00C9CF  1  9A           	TXS				; set the stack
00C9D0  1               
00C9D0  1               ; set up vectors and interrupt code, copy them to page 2
00C9D0  1  A0 0C        	LDY	#END_vec-LAB_vec; set index/count
00C9D2  1               LAB_stlp
00C9D2  1  B9 4B CA     	LDA	LAB_vec-1,Y	; get byte from interrupt code
00C9D5  1  99 05 02     	STA	VEC_IN-1,Y	; save to RAM
00C9D8  1  88           	DEY			; decrement index/count
00C9D9  1  D0 F7        	BNE	LAB_stlp	; loop if more to do
00C9DB  1               
00C9DB  1               ; now do the sign-on message, Y = $00 here
00C9DB  1               LAB_signon
00C9DB  1  B9 75 CA     	LDA	LAB_mess,Y	; get byte from sign on message
00C9DE  1  F0 06        	BEQ	LAB_nokey	; exit loop if done
00C9E0  1               
00C9E0  1  20 55 C1     	JSR	V_OUTP		; output character
00C9E3  1  C8           	INY				; increment index
00C9E4  1  D0 F5        	BNE	LAB_signon	; loop, branch always
00C9E6  1               
00C9E6  1               LAB_nokey
00C9E6  1  20 52 C1     	JSR	V_INPT		; call scan input device
00C9E9  1  90 FB        	BCC	LAB_nokey	; loop if no key
00C9EB  1               
00C9EB  1  29 DF        	AND	#$DF		; mask xx0x xxxx, ensure upper case
00C9ED  1  C9 57        	CMP	#'W'		; compare with [W]arm start
00C9EF  1  F0 07        	BEQ	LAB_dowarm	; branch if [W]arm start
00C9F1  1               
00C9F1  1  C9 43        	CMP	#'C'		; compare with [C]old start
00C9F3  1  D0 D6        	BNE	RES_vec		; loop if not [C]old start
00C9F5  1               
00C9F5  1  4C 03 A0     	JMP	LAB_COLD	; do EhBASIC cold start
00C9F8  1               
00C9F8  1               LAB_dowarm
00C9F8  1  4C 00 00     	JMP	LAB_WARM	; do EhBASIC warm start
00C9FB  1               
00C9FB  1               ; Byte out to serial console
00C9FB  1               SCRNout
00C9FB  1  48               PHA             ;*Save A
00C9FC  1               WAIT:
00C9FC  1  AD 12 D0     	LDA DSP
00C9FF  1  D0 FB        	BNE WAIT
00CA01  1  68           	PLA
00CA02  1  8D 12 D0     	STA DSP
00CA05  1  60           	RTS
00CA06  1               
00CA06  1               ; byte in from emulated ACIA
00CA06  1               KBDin
00CA06  1  AD 10 D0     	LDA KBD
00CA09  1  F0 3C        	BEQ LAB_nobyw
00CA0B  1  48           	PHA			; save key
00CA0C  1  A9 00        	LDA #$00	; clear register
00CA0E  1  8D 10 D0     	STA KBD
00CA11  1  68           	PLA			; restore key
00CA12  1  C9 7F        	CMP 	#127    ; convert delete to backspace
00CA14  1  D0 02        	BNE 	conv_bs2del
00CA16  1  A9 08        	LDA 	#8
00CA18  1               conv_bs2del
00CA18  1  C9 1B        	CMP 	#27     ; escape?
00CA1A  1  D0 27        	BNE 	skip_esc_no
00CA1C  1  8A           	TXA       		; discard escape sequence
00CA1D  1  48           	PHA
00CA1E  1  A2 05        	LDX 	#5		; timer loop - 5*10ms
00CA20  1               skip_esc_next
00CA20  1  A9 01        	LDA 	#1		; ack last tick
00CA22  1  8D FF BF     	STA 	EMU_flag
00CA25  1               skip_esc_wait
00CA25  1  AD FF BF     	LDA 	EMU_flag
00CA28  1  29 01        	AND 	#1		; next tick
00CA2A  1  F0 F9        	BEQ 	skip_esc_wait
00CA2C  1  CA           	DEX
00CA2D  1  D0 F1        	BNE 	skip_esc_next
00CA2F  1               skip_esc_discard
00CA2F  1  E8           	INX			; any data = X > 1
00CA30  1  AD 10 D0     	LDA 	KBD
00CA33  1  F0 FA        	BEQ 	skip_esc_discard
00CA35  1  E0 01        	CPX 	#1
00CA37  1  F0 06        	BEQ 	skip_esc_esc
00CA39  1  68           	PLA			; was special key - skip
00CA3A  1  AA           	TAX
00CA3B  1  A9 00        	LDA 	#0
00CA3D  1  18           	CLC
00CA3E  1  60           	RTS
00CA3F  1               skip_esc_esc			; escape only - send to basic
00CA3F  1  68           	PLA
00CA40  1  AA           	TAX
00CA41  1  A9 1B        	LDA 	#27
00CA43  1               
00CA43  1               skip_esc_no
00CA43  1  49 00        	EOR 	#0		; set flags NZ
00CA45  1  38           	SEC			; flag byte received
00CA46  1  60           	RTS
00CA47  1               
00CA47  1               LAB_nobyw
00CA47  1  18           	CLC			; flag no byte received
00CA48  1  60           	RTS
00CA49  1               
00CA49  1               ; LOAD - currently does nothing.
00CA49  1               SBCload				        ; load vector for EhBASIC
00CA49  1  60           	RTS
00CA4A  1               
00CA4A  1               ; SAVE - currently does nothing.
00CA4A  1               SBCsave				        ; save vector for EhBASIC
00CA4A  1  60           	RTS
00CA4B  1               
00CA4B  1               MON_INIT
00CA4B  1  60           	RTS
00CA4C  1               
00CA4C  1               ; vector tables
00CA4C  1               LAB_vec
00CA4C  1  06 CA        	.word	KBDin		; byte in from simulated ACIA
00CA4E  1  FB C9        	.word	SCRNout		; byte out to simulated ACIA
00CA50  1  49 CA        	.word	SBCload		; load program
00CA52  1  4A CA        	.word	SBCsave		; save program
00CA54  1  58 CA        	.word	IRQ_CODE	; vector to handle IRQ
00CA56  1  6C CA        	.word	NMI_CODE	; vector to handle IRQ
00CA58  1               END_vec
00CA58  1               
00CA58  1               
00CA58  1               ; EhBASIC IRQ support
00CA58  1               IRQ_vec
00CA58  1               ;	JMP	(IRQ_indirect)	; jump through a vector in RAM
00CA58  1               				; uncomment if needed
00CA58  1               IRQ_CODE
00CA58  1  85 E2        	STA	irq_a_reg	; save A
00CA5A  1  A5 DF        	LDA	IrqBase		; get the IRQ flag byte
00CA5C  1  D0 03        	BNE	IRQ_IS_SET	; Basic ready to handle?
00CA5E  1  8D FE BF     	STA	IR_mask		; no, silence internal interrupts
00CA61  1               IRQ_IS_SET
00CA61  1  09 20        	ORA	#$20		; 00100000 set IRQ pending
00CA63  1  85 DF        	STA	IrqBase		; save the new IRQ flag byte
00CA65  1  68           	PLA			; pop saved flags
00CA66  1  09 04        	ORA	#4		; set interrupt disable on stack
00CA68  1  48           	PHA			; save flags again for RTI
00CA69  1  A5 E2        	LDA	irq_a_reg	; restore A
00CA6B  1  40           	RTI			; return disabled!
00CA6C  1               
00CA6C  1               ; EhBASIC NMI support
00CA6C  1               NMI_vec
00CA6C  1               ;	JMP	(NMI_indirect)	; jump through a vector in RAM
00CA6C  1               				; uncomment if needed
00CA6C  1               NMI_CODE
00CA6C  1  48           	PHA			; save A
00CA6D  1  A5 DC        	LDA	NmiBase		; get the NMI flag byte
00CA6F  1  09 20        	ORA	#$20		; 00100000 set NMI pending
00CA71  1  85 DC        	STA	NmiBase		; save the new NMI flag byte
00CA73  1  68           	PLA			; restore A
00CA74  1  40           	RTI
00CA75  1               
00CA75  1               LAB_mess
00CA75  1  0D 0A 4E 45  	.byte	$0D,$0A,"NEO6502 EhBASIC start [C]old/[W]arm ?",$00
00CA79  1  4F 36 35 30  
00CA7D  1  32 20 45 68  
00CA9D  1               				; sign on string
00CA9D  1               
00CA9D  1               	.INCLUDE	"neo6502.asm"
00CA9D  2               ;
00CA9D  2               ;
00CA9D  2               ;
00CA9D  2               VDU_CMD = $D020  ; CMD register
00CA9D  2               VDU_XL  = $D021  ; X low
00CA9D  2               VDU_XH  = $D022  ; X high
00CA9D  2               VDU_YL  = $D023  ; Y low
00CA9D  2               VDU_YH  = $D024  ; Y high
00CA9D  2               VDU_WL  = $D025  ; Width low
00CA9D  2               VDU_WH  = $D026  ; Width high
00CA9D  2               VDU_HL  = $D027  ; Height low
00CA9D  2               VDU_HH  = $D028  ; Height high
00CA9D  2               VDU_FP  = $D029  ; Flip Sprite drawing :: 0 - NONE, 1 - HORZ, 2 - VERT, currently not supported
00CA9D  2               VDU_SID = $D02A  ; Sprite Id
00CA9D  2               VDU_DMOD= $D02B	 ; draw mode :: 0 - NORM, 1 - OR, 2 - AND, 3 - XOR, currently allways XOR
00CA9D  2               VDU_MOD = $D02C  ; VDU mode
00CA9D  2               VDU_PAL = $D02D  ; PAL index
00CA9D  2               VDU_COL = $D02E  ; FG color low
00CA9D  2               VDU_BCOL= $D02F  ; FG color high/BG color
00CA9D  2               
00CA9D  2               VDU_RET = $D030  ; return value
00CA9D  2               VDU_CNT = $D031	 ; tmp count register
00CA9D  2               
00CA9D  2               VDU_BUFFER = $D100; 256 bytes buffer for sprite definitions
00CA9D  2               VDU_BUFEND = VDU_BUFFER+256
00CA9D  2               
00CA9D  2               VDU_TBUFFER = $D200; 256 bytes buffer for tile definitions
00CA9D  2               VDU_TBUFEND = VDU_TBUFFER+256
00CA9D  2               
00CA9D  2               ;--------------------------------
00CA9D  2               ; VDU engine
00CA9D  2               CMD_CLS    = $01
00CA9D  2               CMD_MOVE   = $02
00CA9D  2               CMD_COLOR  = $03
00CA9D  2               CMD_PIXEL  = $04
00CA9D  2               CMD_DRAW   = $05
00CA9D  2               CMD_RECT   = $06
00CA9D  2               CMD_CIRCLE = $07
00CA9D  2               CMD_PAL    = $08
00CA9D  2               CMD_VDU    = $09
00CA9D  2               CMD_REFRESH= $0A
00CA9D  2               CMD_TRI    = $0B
00CA9D  2               
00CA9D  2               ; SPRITE engine
00CA9D  2               CMD_SPRITE = $10
00CA9D  2               CMD_CSPRITE= $11	; TBI
00CA9D  2               CMD_SDRAW  = $12
00CA9D  2               CMD_SCLEAR = $13	; TBI
00CA9D  2               CMD_SMOVE  = $14
00CA9D  2               CMD_COLL   = $15
00CA9D  2               
00CA9D  2               ; TILE engine
00CA9D  2               CMD_TILE   = $16
00CA9D  2               
00CA9D  2               CMD_SANE   = $FF
00CA9D  2               
00CA9D  2               ;--------------------------------
00CA9D  2               ; SOUND
00CA9D  2               SND_CMD = $D040	 ; CMD register
00CA9D  2               SND_NOTE= $D041	 ; NOTE
00CA9D  2               SND_DUR = $D042	 ; DURATION
00CA9D  2               
00CA9D  2               ;--------------------------------
00CA9D  2               VDU_WAIT:			; wait for cmd register to empty
00CA9D  2  AD 20 D0     	LDA VDU_CMD
00CAA0  2  D0 FB        	BNE VDU_WAIT	; not empty
00CAA2  2  60           	RTS
00CAA3  2               
00CAA3  2               VDU_GETARG:
00CAA3  2  20 14 AB     	JSR	LAB_EVNM	; evaluate expression and check is numeric,
00CAA6  2               					; else do type mismatch
00CAA6  2  20 43 B5     	JSR	LAB_F2FX	; convert floating-to-fixed
00CAA9  2  A5 11        	LDA Itempl
00CAAB  2  60           	RTS
00CAAC  2               
00CAAC  2               VDU_NEXTARG:
00CAAC  2  20 46 AC     	JSR	LAB_1C01	; scan for ','
00CAAF  2  4C A3 CA     	JMP	VDU_GETARG
00CAB2  2               
00CAB2  2               VDU_GETX:
00CAB2  2  20 A3 CA     	JSR	VDU_GETARG
00CAB5  2  8D 21 D0     	STA VDU_XL
00CAB8  2  A5 12        	LDA Itemph
00CABA  2  8D 22 D0     	STA VDU_XH
00CABD  2  60           	RTS
00CABE  2               
00CABE  2               VDU_GETY:
00CABE  2  20 AC CA     	JSR	VDU_NEXTARG
00CAC1  2  8D 23 D0     	STA VDU_YL
00CAC4  2  A5 12        	LDA Itemph
00CAC6  2  8D 24 D0     	STA VDU_YH
00CAC9  2  60           	RTS
00CACA  2               
00CACA  2               VDU_GETW:
00CACA  2  20 AC CA     	JSR VDU_NEXTARG
00CACD  2  8D 25 D0     	STA VDU_WL
00CAD0  2  A5 12        	LDA Itemph
00CAD2  2  8D 26 D0     	STA VDU_WH
00CAD5  2  60           	RTS
00CAD6  2               
00CAD6  2               VDU_GETH:
00CAD6  2  20 AC CA     	JSR VDU_NEXTARG
00CAD9  2  8D 27 D0     	STA VDU_HL
00CADC  2  A5 12        	LDA Itemph
00CADE  2  8D 28 D0     	STA VDU_HH
00CAE1  2  60           	RTS
00CAE2  2               
00CAE2  2               ;--------------------------------------------------------------------
00CAE2  2               LAB_SANE:
00CAE2  2  20 9D CA     	JSR VDU_WAIT
00CAE5  2  A9 FF        	LDA	#CMD_SANE		; SANE
00CAE7  2  8D 20 D0     	STA VDU_CMD
00CAEA  2  60           	RTS
00CAEB  2               
00CAEB  2               LAB_CLS:
00CAEB  2  20 9D CA     	JSR VDU_WAIT
00CAEE  2  A9 01        	LDA #CMD_CLS	; CLS
00CAF0  2  8D 20 D0     	STA VDU_CMD
00CAF3  2  60           	RTS
00CAF4  2               
00CAF4  2               LAB_VDU:
00CAF4  2  20 9D CA     	JSR VDU_WAIT
00CAF7  2  20 A3 CA     	JSR	VDU_GETARG
00CAFA  2  8D 2C D0     	STA VDU_MOD		; vdu mode
00CAFD  2  A9 09        	LDA #CMD_VDU	; VDU
00CAFF  2  8D 20 D0     	STA VDU_CMD
00CB02  2  60           	RTS
00CB03  2               
00CB03  2               LAB_MOVE:
00CB03  2  20 9D CA     	JSR VDU_WAIT	; wait for previous command is finished
00CB06  2  20 B2 CA     	JSR VDU_GETX
00CB09  2  20 BE CA     	JSR VDU_GETY
00CB0C  2  A9 02        	LDA #CMD_MOVE	; MOVE
00CB0E  2  8D 20 D0     	STA VDU_CMD
00CB11  2  60           	RTS
00CB12  2               
00CB12  2               LAB_DRAW:
00CB12  2  20 9D CA     	JSR VDU_WAIT	; wait for previous command is finished
00CB15  2  20 B2 CA     	JSR VDU_GETX
00CB18  2  20 BE CA     	JSR VDU_GETY
00CB1B  2               					; NEED to add MODE
00CB1B  2  A9 05        	LDA #CMD_DRAW	; DRAW
00CB1D  2  8D 20 D0     	STA VDU_CMD
00CB20  2  60           	RTS
00CB21  2               
00CB21  2               LAB_PIXEL:
00CB21  2  20 9D CA     	JSR VDU_WAIT
00CB24  2  20 B2 CA     	JSR VDU_GETX
00CB27  2  20 BE CA     	JSR VDU_GETY
00CB2A  2               					; NEED to add MODE
00CB2A  2  A9 04        	LDA #CMD_PIXEL	; PIXEL
00CB2C  2  8D 20 D0     	STA VDU_CMD
00CB2F  2  60           	RTS
00CB30  2               
00CB30  2               LAB_RECT:
00CB30  2  20 9D CA     	JSR VDU_WAIT
00CB33  2  20 B2 CA     	JSR VDU_GETX
00CB36  2  20 BE CA     	JSR VDU_GETY
00CB39  2  20 CA CA     	JSR VDU_GETW
00CB3C  2  20 D6 CA     	JSR VDU_GETH
00CB3F  2  20 AC CA     	JSR	VDU_NEXTARG
00CB42  2  8D 2B D0     	STA VDU_DMOD
00CB45  2  A9 06        	LDA #CMD_RECT	; RECT
00CB47  2  8D 20 D0     	STA VDU_CMD
00CB4A  2  60           	RTS
00CB4B  2               
00CB4B  2               LAB_CIRCLE:
00CB4B  2  20 9D CA     	JSR VDU_WAIT
00CB4E  2  20 B2 CA     	JSR VDU_GETX
00CB51  2  20 BE CA     	JSR VDU_GETY
00CB54  2  20 CA CA     	JSR VDU_GETW	; radius
00CB57  2  20 AC CA     	JSR	VDU_NEXTARG
00CB5A  2  8D 2B D0     	STA VDU_DMOD
00CB5D  2  A9 07        	LDA #CMD_CIRCLE	; CIRCLE
00CB5F  2  8D 20 D0     	STA VDU_CMD
00CB62  2  60           	RTS
00CB63  2               
00CB63  2               LAB_TRIANGLE:
00CB63  2  20 9D CA     	JSR VDU_WAIT
00CB66  2  20 B2 CA     	JSR VDU_GETX	; 2nd pt X
00CB69  2  20 BE CA     	JSR VDU_GETY
00CB6C  2  20 CA CA     	JSR VDU_GETW	; 3rd pt X
00CB6F  2  20 D6 CA     	JSR VDU_GETH	; 3rd pt Y
00CB72  2  20 AC CA     	JSR	VDU_NEXTARG
00CB75  2  8D 2B D0     	STA VDU_DMOD
00CB78  2  A9 0B        	LDA #CMD_TRI	; Triangle
00CB7A  2  8D 20 D0     	STA VDU_CMD
00CB7D  2  60           	RTS
00CB7E  2               
00CB7E  2               LAB_COLOR:
00CB7E  2  20 9D CA     	JSR VDU_WAIT
00CB81  2  20 A3 CA     	JSR	VDU_GETARG
00CB84  2  8D 2E D0     	STA VDU_COL
00CB87  2  A9 03        	LDA #CMD_COLOR	; COLOR
00CB89  2  8D 20 D0     	STA VDU_CMD
00CB8C  2  60           	RTS
00CB8D  2               
00CB8D  2               LAB_PALETTE:
00CB8D  2  20 A3 CA     	JSR	VDU_GETARG
00CB90  2  8D 2D D0     	STA VDU_PAL
00CB93  2  20 AC CA     	JSR VDU_NEXTARG
00CB96  2  8D 2E D0     	STA VDU_COL
00CB99  2  A5 12        	LDA Itemph
00CB9B  2  8D 2F D0     	STA VDU_BCOL
00CB9E  2  A9 08        	LDA #CMD_PAL	; PALETTE
00CBA0  2  8D 20 D0     	STA VDU_CMD
00CBA3  2  60           	RTS
00CBA4  2               
00CBA4  2               LAB_VREFRESH:
00CBA4  2  20 9D CA     	JSR VDU_WAIT
00CBA7  2  A9 0A        	LDA #CMD_REFRESH ; REFRESH
00CBA9  2  8D 20 D0     	STA VDU_CMD
00CBAC  2  60           	RTS
00CBAD  2               
00CBAD  2               ;---------------------------------------------------------
00CBAD  2               LAB_SDIM:			; SDIM
00CBAD  2  20 9D CA         JSR VDU_WAIT
00CBB0  2  20 A3 CA     	JSR	VDU_GETARG
00CBB3  2               ;	LDA Itempl		; Index
00CBB3  2               
00CBB3  2               SDIM_NEXT:
00CBB3  2  48           	PHA				; Save index
00CBB4  2  20 C2 00     	JSR	LAB_GBYT	; check next BASIC byte
00CBB7  2  C9 2C        	CMP	#','		; is there more ?
00CBB9  2  D0 16        	BNE SDIM_DONE
00CBBB  2  20 46 AC     	JSR	LAB_1C01	; scan for ','
00CBBE  2  20 A3 CA     	JSR	VDU_GETARG
00CBC1  2  68           	PLA
00CBC2  2  A8           	TAY				; Index
00CBC3  2  A5 11        	LDA Itempl
00CBC5  2  99 00 D1     	STA VDU_BUFFER, Y
00CBC8  2  C8           	INY
00CBC9  2  98           	TYA
00CBCA  2  D0 E7            BNE SDIM_NEXT
00CBCC  2  A2 0A        	LDX	#$0A		; overflow
00CBCE  2  4C 4C A1     	JMP LAB_XERR	; WARM start
00CBD1  2               
00CBD1  2               SDIM_DONE:
00CBD1  2  68           	PLA				; dump index
00CBD2  2  60           	RTS
00CBD3  2               
00CBD3  2               ;----------
00CBD3  2               LAB_WDIM:
00CBD3  2  20 9D CA         JSR VDU_WAIT
00CBD6  2  20 A3 CA     	JSR	VDU_GETARG
00CBD9  2  A5 11        	LDA Itempl		; Index
00CBDB  2               
00CBDB  2               WDIM_NEXT:
00CBDB  2  48           	PHA				; Save index
00CBDC  2  20 C2 00     	JSR	LAB_GBYT	; check next BASIC byte
00CBDF  2  C9 2C        	CMP	#','		; is there more ?
00CBE1  2  D0 1C        	BNE WDIM_DONE
00CBE3  2  20 46 AC     	JSR	LAB_1C01	; scan for ','
00CBE6  2  20 A3 CA     	JSR	VDU_GETARG
00CBE9  2  68           	PLA
00CBEA  2  A8           	TAY				; Index
00CBEB  2  A5 12        	LDA Itemph		; switch byte order!
00CBED  2  99 00 D1     	STA VDU_BUFFER, Y
00CBF0  2  C8           	INY
00CBF1  2  A5 11        	LDA Itempl
00CBF3  2  99 00 D1     	STA VDU_BUFFER, Y
00CBF6  2  C8           	INY
00CBF7  2  98           	TYA
00CBF8  2  D0 E1            BNE WDIM_NEXT
00CBFA  2  A2 0A        	LDX	#$0A		; overflow
00CBFC  2  4C 4C A1     	JMP LAB_XERR	; WARM start
00CBFF  2               
00CBFF  2               WDIM_DONE:			; WORD
00CBFF  2  68           	PLA				; dump index
00CC00  2  60           	RTS
00CC01  2               
00CC01  2               ;------------
00CC01  2               LAB_SPRITE:			; Id W H M F O
00CC01  2  20 9D CA     	JSR	VDU_WAIT
00CC04  2  20 A3 CA     	JSR VDU_GETARG
00CC07  2  8D 2A D0     	STA VDU_SID		; id
00CC0A  2  20 CA CA     	JSR VDU_GETW	; width
00CC0D  2  20 D6 CA     	JSR VDU_GETH	; height
00CC10  2  20 AC CA     	JSR	VDU_NEXTARG
00CC13  2  8D 2B D0     	STA VDU_DMOD	; mode
00CC16  2  20 AC CA     	JSR	VDU_NEXTARG
00CC19  2  8D 29 D0     	STA VDU_FP		; flip
00CC1C  2  20 AC CA     	JSR	VDU_NEXTARG
00CC1F  2  8D 2D D0     	STA VDU_PAL		; offset
00CC22  2  A9 10        	LDA #CMD_SPRITE
00CC24  2  8D 20 D0     	STA	VDU_CMD
00CC27  2  60           	RTS
00CC28  2               
00CC28  2               ;------------
00CC28  2               LAB_CSPRITE:
00CC28  2  60           	RTS
00CC29  2               
00CC29  2               ;------------
00CC29  2               LAB_SDRAW:	; Id X Y C
00CC29  2  20 9D CA     	JSR VDU_WAIT
00CC2C  2  20 A3 CA     	JSR VDU_GETARG
00CC2F  2  8D 2A D0     	STA VDU_SID		; id
00CC32  2  20 46 AC     	JSR	LAB_1C01	; scan for ','
00CC35  2  20 B2 CA     	JSR VDU_GETX	; x
00CC38  2  20 BE CA     	JSR VDU_GETY	; y
00CC3B  2  20 AC CA     	JSR	VDU_NEXTARG
00CC3E  2  8D 2E D0     	STA	VDU_COL
00CC41  2  A9 12        	LDA #CMD_SDRAW
00CC43  2  8D 20 D0     	STA	VDU_CMD
00CC46  2  60           	RTS
00CC47  2               
00CC47  2               ;------------
00CC47  2               LAB_SMOVE:			; Id (dx dy (mod))
00CC47  2  20 9D CA     	JSR VDU_WAIT
00CC4A  2  20 A3 CA     	JSR VDU_GETARG
00CC4D  2  8D 2A D0     	STA VDU_SID		; id
00CC50  2  20 C2 00     	JSR	LAB_GBYT	; check next BASIC byte
00CC53  2  C9 2C        	CMP	#','		; is there more ?
00CC55  2  D0 24        	BNE SMOVE_DONE  ; nope
00CC57  2  20 46 AC     	JSR	LAB_1C01	; scan for ','
00CC5A  2  20 B2 CA     	JSR VDU_GETX
00CC5D  2  20 BE CA     	JSR VDU_GETY
00CC60  2  20 C2 00     	JSR	LAB_GBYT	; check next BASIC byte
00CC63  2  C9 2C        	CMP	#','		; is there more ?
00CC65  2  D0 09        	BNE SMOVE_CONT  ; nope
00CC67  2  20 AC CA     	JSR VDU_NEXTARG
00CC6A  2  8D 2C D0     	STA	VDU_MOD		; modifier
00CC6D  2  4C 75 CC         JMP SMOVE_CMD
00CC70  2               SMOVE_CONT:
00CC70  2  A9 00        	LDA #$00
00CC72  2  8D 2C D0     	STA VDU_MOD
00CC75  2               SMOVE_CMD:
00CC75  2  A9 14        	LDA #CMD_SMOVE
00CC77  2  8D 20 D0     	STA	VDU_CMD
00CC7A  2  60           	RTS
00CC7B  2               
00CC7B  2               SMOVE_DONE:
00CC7B  2  A9 00        	LDA #$00
00CC7D  2  8D 21 D0     	STA VDU_XL
00CC80  2  8D 22 D0     	STA VDU_XH
00CC83  2  8D 23 D0     	STA VDU_YL
00CC86  2  8D 24 D0     	STA VDU_YH
00CC89  2  8D 2C D0     	STA VDU_MOD
00CC8C  2  F0 E7        	BEQ SMOVE_CMD	; always
00CC8E  2               
00CC8E  2               ;-----------
00CC8E  2               LAB_SCLEAR:
00CC8E  2  60           	RTS
00CC8F  2               
00CC8F  2               ;------------
00CC8F  2               ; kind of a cludge: how to do a function with more than 1 parameter?
00CC8F  2               ; for now we use COLOR command to check collision with color
00CC8F  2               LAB_COLLISION:
00CC8F  2  20 9D CA     	JSR VDU_WAIT
00CC92  2  20 43 B5     	JSR	LAB_F2FX	; convert floating-to-fixed
00CC95  2  A5 11        	LDA Itempl
00CC97  2  8D 2A D0     	STA VDU_SID		; th sprite id
00CC9A  2  A9 15        	LDA #CMD_COLL
00CC9C  2  8D 20 D0     	STA VDU_CMD
00CC9F  2  A9 FF        	LDA #$FF
00CCA1  2  8D 31 D0     	STA VDU_CNT
00CCA4  2               COLL_WAIT:
00CCA4  2  EE 31 D0     	INC VDU_CNT
00CCA7  2  AD 30 D0     	LDA VDU_RET
00CCAA  2  F0 F8        	BEQ COLL_WAIT	; 8-bit will be set
00CCAC  2  29 7F        	AND #$7F		; strip it off
00CCAE  2  A8           	TAY
00CCAF  2  A9 00        	LDA #$00
00CCB1  2  8D 30 D0     	STA VDU_RET		; and clear it
00CCB4  2  4C BD B0     	JMP	LAB_1FD0	; convert Y to byte in FAC1 and return
00CCB7  2               
00CCB7  2               ;---------------------------------------------------------
00CCB7  2               ;-----------
00CCB7  2               LAB_VTDIM:			; TDIM equvalent to SDIM
00CCB7  2  20 9D CA         JSR VDU_WAIT
00CCBA  2  20 A3 CA     	JSR	VDU_GETARG
00CCBD  2               ;	LDA Itempl		; Index
00CCBD  2  0A           	ASL
00CCBE  2  0A           	ASL
00CCBF  2  0A           	ASL
00CCC0  2               
00CCC0  2               TDIM_NEXT:
00CCC0  2  48           	PHA				; Save index
00CCC1  2  20 C2 00     	JSR	LAB_GBYT	; check next BASIC byte
00CCC4  2  C9 2C        	CMP	#','		; is there more ?
00CCC6  2  D0 16        	BNE TDIM_DONE
00CCC8  2  20 46 AC     	JSR	LAB_1C01	; scan for ','
00CCCB  2  20 A3 CA     	JSR	VDU_GETARG
00CCCE  2  68           	PLA
00CCCF  2  A8           	TAY				; Index
00CCD0  2  A5 11        	LDA Itempl
00CCD2  2  99 00 D2     	STA VDU_TBUFFER, Y
00CCD5  2  C8           	INY
00CCD6  2  98           	TYA
00CCD7  2  D0 E7            BNE TDIM_NEXT
00CCD9  2  A2 0A        	LDX	#$0A		; overflow
00CCDB  2  4C 4C A1     	JMP LAB_XERR	; WARM start
00CCDE  2               
00CCDE  2               TDIM_DONE:
00CCDE  2  68           	PLA				; dump index
00CCDF  2  60           	RTS
00CCE0  2               
00CCE0  2               ;----------------
00CCE0  2               LAB_VTILE:
00CCE0  2  20 9D CA     	JSR VDU_WAIT
00CCE3  2  20 A3 CA     	JSR VDU_GETARG
00CCE6  2  8D 2A D0     	STA VDU_SID		; id
00CCE9  2  20 46 AC     	JSR	LAB_1C01	; scan for ','
00CCEC  2  20 B2 CA     	JSR VDU_GETX	; x
00CCEF  2  20 BE CA     	JSR VDU_GETY	; y
00CCF2  2  20 AC CA     	JSR VDU_NEXTARG
00CCF5  2  8D 2E D0     	STA VDU_COL		; color
00CCF8  2  A9 00        	LDA #$00
00CCFA  2  8D 2B D0     	STA VDU_DMOD
00CCFD  2  20 C2 00     	JSR	LAB_GBYT	; check next BASIC byte
00CD00  2  C9 2C        	CMP	#','		; is there more ?
00CD02  2  D0 06        	BNE TILE_DONE
00CD04  2  20 AC CA     	JSR VDU_NEXTARG
00CD07  2  8D 2B D0     	STA	VDU_DMOD	; modifier
00CD0A  2               TILE_DONE:
00CD0A  2  A9 16        	LDA #CMD_TILE
00CD0C  2  8D 20 D0     	STA	VDU_CMD
00CD0F  2  60           	RTS
00CD10  2               
00CD10  2               ;---------------------------------------------------------
00CD10  2               SND_WAIT:
00CD10  2  AD 40 D0     	LDA SND_CMD
00CD13  2  D0 FB        	BNE SND_WAIT
00CD15  2  60           	RTS
00CD16  2               
00CD16  2               LAB_SILENCE:
00CD16  2  20 10 CD     	JSR SND_WAIT
00CD19  2  A9 02        	LDA #$02
00CD1B  2  8D 40 D0     	STA SND_CMD
00CD1E  2  60           	RTS
00CD1F  2               
00CD1F  2               LAB_PLAY:
00CD1F  2  20 10 CD     	JSR SND_WAIT
00CD22  2  20 A3 CA     	JSR VDU_GETARG
00CD25  2  A5 11        	LDA Itempl
00CD27  2  8D 41 D0     	STA SND_NOTE
00CD2A  2  20 AC CA     	JSR	VDU_NEXTARG
00CD2D  2  8D 42 D0     	STA SND_DUR
00CD30  2  A9 01        	LDA #$01
00CD32  2  8D 40 D0     	STA SND_CMD
00CD35  2  60           	RTS
00CD36  2               
00CD36  1               
00CD36  1               ; system vectors
00CD36  1  6C CA        	.word	NMI_vec		; NMI vector
00CD38  1  CB C9        	.word	RES_vec		; RESET vector
00CD3A  1  58 CA        	.word	IRQ_vec		; IRQ vector
00CD3A  1               
